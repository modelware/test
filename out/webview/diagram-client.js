"use strict";
var OMLDiagramClient = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a3, prop, b3[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decoratorStart = (base) => {
    var _a4;
    return [, , , __create((_a4 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a4 : null)];
  };
  var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
  var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
  var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
  var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
  var __runInitializers = (array, flags, self2, value) => {
    for (var i2 = 0, fns = array[flags >> 1], n = fns && fns.length; i2 < n; i2++) flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
    return value;
  };
  var __decorateElement = (array, flags, name, decorators, target, extra) => {
    var fn, it2, done, ctx, access, k3 = flags & 7, s3 = !!(flags & 8), p3 = !!(flags & 16);
    var j3 = k3 > 3 ? array.length + 1 : k3 ? s3 ? 1 : 2 : 0, key = __decoratorStrings[k3 + 5];
    var initializers = k3 > 3 && (array[j3 - 1] = []), extraInitializers = array[j3] || (array[j3] = []);
    var desc = k3 && (!p3 && !s3 && (target = target.prototype), k3 < 5 && (k3 > 3 || !p3) && __getOwnPropDesc(k3 < 4 ? target : { get [name]() {
      return __privateGet(this, extra);
    }, set [name](x3) {
      return __privateSet(this, extra, x3);
    } }, name));
    k3 ? p3 && k3 < 4 && __name(extra, (k3 > 2 ? "set " : k3 > 1 ? "get " : "") + name) : __name(target, name);
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      ctx = __decoratorContext(k3, name, done = {}, array[3], extraInitializers);
      if (k3) {
        ctx.static = s3, ctx.private = p3, access = ctx.access = { has: p3 ? (x3) => __privateIn(target, x3) : (x3) => name in x3 };
        if (k3 ^ 3) access.get = p3 ? (x3) => (k3 ^ 1 ? __privateGet : __privateMethod)(x3, target, k3 ^ 4 ? extra : desc.get) : (x3) => x3[name];
        if (k3 > 2) access.set = p3 ? (x3, y3) => __privateSet(x3, target, y3, k3 ^ 4 ? extra : desc.set) : (x3, y3) => x3[name] = y3;
      }
      it2 = (0, decorators[i2])(k3 ? k3 < 4 ? p3 ? extra : desc[key] : k3 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
      if (k3 ^ 4 || it2 === void 0) __expectFn(it2) && (k3 > 4 ? initializers.unshift(it2) : k3 ? p3 ? extra = it2 : desc[key] = it2 : target = it2);
      else if (typeof it2 !== "object" || it2 === null) __typeError("Object expected");
      else __expectFn(fn = it2.get) && (desc.get = fn), __expectFn(fn = it2.set) && (desc.set = fn), __expectFn(fn = it2.init) && initializers.unshift(fn);
    }
    return k3 || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p3 ? k3 ^ 4 ? extra : desc : target;
  };
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

  // ../../node_modules/reflect-metadata/Reflect.js
  var require_Reflect = __commonJS({
    "../../node_modules/reflect-metadata/Reflect.js"() {
      var Reflect2;
      (function(Reflect3) {
        (function(factory) {
          var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
          var exporter = makeExporter(Reflect3);
          if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter, root);
          if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect3;
          }
          function makeExporter(target, previous) {
            return function(key, value) {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
              if (previous)
                previous(key, value);
            };
          }
          function functionThis() {
            try {
              return Function("return this;")();
            } catch (_3) {
            }
          }
          function indirectEvalThis() {
            try {
              return (void 0, eval)("(function() { return this; })()");
            } catch (_3) {
            }
          }
          function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
          }
        })(function(exporter, root) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function";
          var supportsProto = { __proto__: [] } instanceof Array;
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function() {
              return MakeDictionary(/* @__PURE__ */ Object.create(null));
            } : supportsProto ? function() {
              return MakeDictionary({ __proto__: null });
            } : function() {
              return MakeDictionary({});
            },
            has: downLevel ? function(map, key) {
              return hasOwn.call(map, key);
            } : function(map, key) {
              return key in map;
            },
            get: downLevel ? function(map, key) {
              return hasOwn.call(map, key) ? map[key] : void 0;
            } : function(map, key) {
              return map[key];
            }
          };
          var functionPrototype = Object.getPrototypeOf(Function);
          var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
          var metadataRegistry = GetOrCreateMetadataRegistry();
          var metadataProvider = CreateMetadataProvider(metadataRegistry);
          function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsObject(target))
                throw new TypeError();
              if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                throw new TypeError();
              if (IsNull(attributes))
                attributes = void 0;
              propertyKey = ToPropertyKey(propertyKey);
              return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
              if (!IsArray(decorators))
                throw new TypeError();
              if (!IsConstructor(target))
                throw new TypeError();
              return DecorateConstructor(decorators, target);
            }
          }
          exporter("decorate", decorate);
          function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
              if (!IsObject(target))
                throw new TypeError();
              if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                throw new TypeError();
              OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
          }
          exporter("metadata", metadata);
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey))
              propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(
              target,
              propertyKey,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                  throw new TypeError();
                target = decorated;
              }
            }
            return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
              var decorator = decorators[i2];
              var decorated = decorator(target, propertyKey, descriptor);
              if (!IsUndefined(decorated) && !IsNull(decorated)) {
                if (!IsObject(decorated))
                  throw new TypeError();
                descriptor = decorated;
              }
            }
            return descriptor;
          }
          function OrdinaryHasMetadata(MetadataKey, O3, P2) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
            if (hasOwn2)
              return true;
            var parent = OrdinaryGetPrototypeOf(O3);
            if (!IsNull(parent))
              return OrdinaryHasMetadata(MetadataKey, parent, P2);
            return false;
          }
          function OrdinaryHasOwnMetadata(MetadataKey, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O3, P2));
          }
          function OrdinaryGetMetadata(MetadataKey, O3, P2) {
            var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O3, P2);
            if (hasOwn2)
              return OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
            var parent = OrdinaryGetPrototypeOf(O3);
            if (!IsNull(parent))
              return OrdinaryGetMetadata(MetadataKey, parent, P2);
            return void 0;
          }
          function OrdinaryGetOwnMetadata(MetadataKey, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              false
            );
            if (IsUndefined(provider))
              return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O3, P2);
          }
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*Create*/
              true
            );
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O3, P2);
          }
          function OrdinaryMetadataKeys(O3, P2) {
            var ownKeys = OrdinaryOwnMetadataKeys(O3, P2);
            var parent = OrdinaryGetPrototypeOf(O3);
            if (parent === null)
              return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P2);
            if (parentKeys.length <= 0)
              return ownKeys;
            if (ownKeys.length <= 0)
              return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i2 = 0, ownKeys_1 = ownKeys; _i2 < ownKeys_1.length; _i2++) {
              var key = ownKeys_1[_i2];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            for (var _a4 = 0, parentKeys_1 = parentKeys; _a4 < parentKeys_1.length; _a4++) {
              var key = parentKeys_1[_a4];
              var hasKey = set.has(key);
              if (!hasKey) {
                set.add(key);
                keys.push(key);
              }
            }
            return keys;
          }
          function OrdinaryOwnMetadataKeys(O3, P2) {
            var provider = GetMetadataProvider(
              O3,
              P2,
              /*create*/
              false
            );
            if (!provider) {
              return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O3, P2);
          }
          function Type(x3) {
            if (x3 === null)
              return 1;
            switch (typeof x3) {
              case "undefined":
                return 0;
              case "boolean":
                return 2;
              case "string":
                return 3;
              case "symbol":
                return 4;
              case "number":
                return 5;
              case "object":
                return x3 === null ? 1 : 6;
              default:
                return 6;
            }
          }
          function IsUndefined(x3) {
            return x3 === void 0;
          }
          function IsNull(x3) {
            return x3 === null;
          }
          function IsSymbol(x3) {
            return typeof x3 === "symbol";
          }
          function IsObject(x3) {
            return typeof x3 === "object" ? x3 !== null : typeof x3 === "function";
          }
          function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
              case 0:
                return input;
              case 1:
                return input;
              case 2:
                return input;
              case 3:
                return input;
              case 4:
                return input;
              case 5:
                return input;
            }
            var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== void 0) {
              var result = exoticToPrim.call(input, hint);
              if (IsObject(result))
                throw new TypeError();
              return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          function OrdinaryToPrimitive(O3, hint) {
            if (hint === "string") {
              var toString_1 = O3.toString;
              if (IsCallable(toString_1)) {
                var result = toString_1.call(O3);
                if (!IsObject(result))
                  return result;
              }
              var valueOf = O3.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O3);
                if (!IsObject(result))
                  return result;
              }
            } else {
              var valueOf = O3.valueOf;
              if (IsCallable(valueOf)) {
                var result = valueOf.call(O3);
                if (!IsObject(result))
                  return result;
              }
              var toString_2 = O3.toString;
              if (IsCallable(toString_2)) {
                var result = toString_2.call(O3);
                if (!IsObject(result))
                  return result;
              }
            }
            throw new TypeError();
          }
          function ToBoolean(argument) {
            return !!argument;
          }
          function ToString(argument) {
            return "" + argument;
          }
          function ToPropertyKey(argument) {
            var key = ToPrimitive(
              argument,
              3
              /* String */
            );
            if (IsSymbol(key))
              return key;
            return ToString(key);
          }
          function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
          }
          function IsCallable(argument) {
            return typeof argument === "function";
          }
          function IsConstructor(argument) {
            return typeof argument === "function";
          }
          function IsPropertyKey(argument) {
            switch (Type(argument)) {
              case 3:
                return true;
              case 4:
                return true;
              default:
                return false;
            }
          }
          function SameValueZero(x3, y3) {
            return x3 === y3 || x3 !== x3 && y3 !== y3;
          }
          function GetMethod(V2, P2) {
            var func = V2[P2];
            if (func === void 0 || func === null)
              return void 0;
            if (!IsCallable(func))
              throw new TypeError();
            return func;
          }
          function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
              throw new TypeError();
            var iterator = method.call(obj);
            if (!IsObject(iterator))
              throw new TypeError();
            return iterator;
          }
          function IteratorValue(iterResult) {
            return iterResult.value;
          }
          function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
          }
          function IteratorClose(iterator) {
            var f3 = iterator["return"];
            if (f3)
              f3.call(iterator);
          }
          function OrdinaryGetPrototypeOf(O3) {
            var proto = Object.getPrototypeOf(O3);
            if (typeof O3 !== "function" || O3 === functionPrototype)
              return proto;
            if (proto !== functionPrototype)
              return proto;
            var prototype = O3.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
              return proto;
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
              return proto;
            if (constructor === O3)
              return proto;
            return constructor;
          }
          function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
              fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
              registerProvider,
              getProvider,
              setProvider
            };
            return registry;
            function registerProvider(provider) {
              if (!Object.isExtensible(registry)) {
                throw new Error("Cannot add provider to a frozen registry.");
              }
              switch (true) {
                case fallback === provider:
                  break;
                case IsUndefined(first):
                  first = provider;
                  break;
                case first === provider:
                  break;
                case IsUndefined(second):
                  second = provider;
                  break;
                case second === provider:
                  break;
                default:
                  if (rest === void 0)
                    rest = new _Set();
                  rest.add(provider);
                  break;
              }
            }
            function getProviderNoCache(O3, P2) {
              if (!IsUndefined(first)) {
                if (first.isProviderFor(O3, P2))
                  return first;
                if (!IsUndefined(second)) {
                  if (second.isProviderFor(O3, P2))
                    return first;
                  if (!IsUndefined(rest)) {
                    var iterator = GetIterator(rest);
                    while (true) {
                      var next = IteratorStep(iterator);
                      if (!next) {
                        return void 0;
                      }
                      var provider = IteratorValue(next);
                      if (provider.isProviderFor(O3, P2)) {
                        IteratorClose(iterator);
                        return provider;
                      }
                    }
                  }
                }
              }
              if (!IsUndefined(fallback) && fallback.isProviderFor(O3, P2)) {
                return fallback;
              }
              return void 0;
            }
            function getProvider(O3, P2) {
              var providerMap = targetProviderMap.get(O3);
              var provider;
              if (!IsUndefined(providerMap)) {
                provider = providerMap.get(P2);
              }
              if (!IsUndefined(provider)) {
                return provider;
              }
              provider = getProviderNoCache(O3, P2);
              if (!IsUndefined(provider)) {
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O3, providerMap);
                }
                providerMap.set(P2, provider);
              }
              return provider;
            }
            function hasProvider(provider) {
              if (IsUndefined(provider))
                throw new TypeError();
              return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O3, P2, provider) {
              if (!hasProvider(provider)) {
                throw new Error("Metadata provider not registered.");
              }
              var existingProvider = getProvider(O3, P2);
              if (existingProvider !== provider) {
                if (!IsUndefined(existingProvider)) {
                  return false;
                }
                var providerMap = targetProviderMap.get(O3);
                if (IsUndefined(providerMap)) {
                  providerMap = new _Map();
                  targetProviderMap.set(O3, providerMap);
                }
                providerMap.set(P2, provider);
              }
              return true;
            }
          }
          function GetOrCreateMetadataRegistry() {
            var metadataRegistry2;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              metadataRegistry2 = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry2)) {
              metadataRegistry2 = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
              Object.defineProperty(root.Reflect, registrySymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: metadataRegistry2
              });
            }
            return metadataRegistry2;
          }
          function CreateMetadataProvider(registry) {
            var metadata2 = new _WeakMap();
            var provider = {
              isProviderFor: function(O3, P2) {
                var targetMetadata = metadata2.get(O3);
                if (IsUndefined(targetMetadata))
                  return false;
                return targetMetadata.has(P2);
              },
              OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
              OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
              OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
              OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
              OrdinaryDeleteMetadata
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O3, P2, Create) {
              var targetMetadata = metadata2.get(O3);
              var createdTargetMetadata = false;
              if (IsUndefined(targetMetadata)) {
                if (!Create)
                  return void 0;
                targetMetadata = new _Map();
                metadata2.set(O3, targetMetadata);
                createdTargetMetadata = true;
              }
              var metadataMap = targetMetadata.get(P2);
              if (IsUndefined(metadataMap)) {
                if (!Create)
                  return void 0;
                metadataMap = new _Map();
                targetMetadata.set(P2, metadataMap);
                if (!registry.setProvider(O3, P2, provider)) {
                  targetMetadata.delete(P2);
                  if (createdTargetMetadata) {
                    metadata2.delete(O3);
                  }
                  throw new Error("Wrong provider for target.");
                }
              }
              return metadataMap;
            }
            function OrdinaryHasOwnMetadata2(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              return ToBoolean(metadataMap.has(MetadataKey));
            }
            function OrdinaryGetOwnMetadata2(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return void 0;
              return metadataMap.get(MetadataKey);
            }
            function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                true
              );
              metadataMap.set(MetadataKey, MetadataValue);
            }
            function OrdinaryOwnMetadataKeys2(O3, P2) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k3 = 0;
              while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                  keys.length = k3;
                  return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                  keys[k3] = nextValue;
                } catch (e2) {
                  try {
                    IteratorClose(iterator);
                  } finally {
                    throw e2;
                  }
                }
                k3++;
              }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O3, P2) {
              var metadataMap = GetOrCreateMetadataMap(
                O3,
                P2,
                /*Create*/
                false
              );
              if (IsUndefined(metadataMap))
                return false;
              if (!metadataMap.delete(MetadataKey))
                return false;
              if (metadataMap.size === 0) {
                var targetMetadata = metadata2.get(O3);
                if (!IsUndefined(targetMetadata)) {
                  targetMetadata.delete(P2);
                  if (targetMetadata.size === 0) {
                    metadata2.delete(targetMetadata);
                  }
                }
              }
              return true;
            }
          }
          function CreateFallbackProvider(reflect) {
            var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
              isProviderFor: function(O3, P2) {
                var metadataPropertySet = metadataOwner.get(O3);
                if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P2)) {
                  return true;
                }
                if (getOwnMetadataKeys2(O3, P2).length) {
                  if (IsUndefined(metadataPropertySet)) {
                    metadataPropertySet = new _Set();
                    metadataOwner.set(O3, metadataPropertySet);
                  }
                  metadataPropertySet.add(P2);
                  return true;
                }
                return false;
              },
              OrdinaryDefineOwnMetadata: defineMetadata2,
              OrdinaryHasOwnMetadata: hasOwnMetadata2,
              OrdinaryGetOwnMetadata: getOwnMetadata2,
              OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
              OrdinaryDeleteMetadata: deleteMetadata2
            };
            return provider;
          }
          function GetMetadataProvider(O3, P2, Create) {
            var registeredProvider = metadataRegistry.getProvider(O3, P2);
            if (!IsUndefined(registeredProvider)) {
              return registeredProvider;
            }
            if (Create) {
              if (metadataRegistry.setProvider(O3, P2, metadataProvider)) {
                return metadataProvider;
              }
              throw new Error("Illegal state.");
            }
            return void 0;
          }
          function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (
              /** @class */
              (function() {
                function MapIterator2(keys, values, selector) {
                  this._index = 0;
                  this._keys = keys;
                  this._values = values;
                  this._selector = selector;
                }
                MapIterator2.prototype["@@iterator"] = function() {
                  return this;
                };
                MapIterator2.prototype[iteratorSymbol] = function() {
                  return this;
                };
                MapIterator2.prototype.next = function() {
                  var index = this._index;
                  if (index >= 0 && index < this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                      this._index = -1;
                      this._keys = arraySentinel;
                      this._values = arraySentinel;
                    } else {
                      this._index++;
                    }
                    return { value: result, done: false };
                  }
                  return { value: void 0, done: true };
                };
                MapIterator2.prototype.throw = function(error) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  throw error;
                };
                MapIterator2.prototype.return = function(value) {
                  if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  }
                  return { value, done: true };
                };
                return MapIterator2;
              })()
            );
            var Map2 = (
              /** @class */
              (function() {
                function Map3() {
                  this._keys = [];
                  this._values = [];
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                Object.defineProperty(Map3.prototype, "size", {
                  get: function() {
                    return this._keys.length;
                  },
                  enumerable: true,
                  configurable: true
                });
                Map3.prototype.has = function(key) {
                  return this._find(
                    key,
                    /*insert*/
                    false
                  ) >= 0;
                };
                Map3.prototype.get = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  return index >= 0 ? this._values[index] : void 0;
                };
                Map3.prototype.set = function(key, value) {
                  var index = this._find(
                    key,
                    /*insert*/
                    true
                  );
                  this._values[index] = value;
                  return this;
                };
                Map3.prototype.delete = function(key) {
                  var index = this._find(
                    key,
                    /*insert*/
                    false
                  );
                  if (index >= 0) {
                    var size = this._keys.length;
                    for (var i2 = index + 1; i2 < size; i2++) {
                      this._keys[i2 - 1] = this._keys[i2];
                      this._values[i2 - 1] = this._values[i2];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (SameValueZero(key, this._cacheKey)) {
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                    }
                    return true;
                  }
                  return false;
                };
                Map3.prototype.clear = function() {
                  this._keys.length = 0;
                  this._values.length = 0;
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                };
                Map3.prototype.keys = function() {
                  return new MapIterator(this._keys, this._values, getKey);
                };
                Map3.prototype.values = function() {
                  return new MapIterator(this._keys, this._values, getValue);
                };
                Map3.prototype.entries = function() {
                  return new MapIterator(this._keys, this._values, getEntry);
                };
                Map3.prototype["@@iterator"] = function() {
                  return this.entries();
                };
                Map3.prototype[iteratorSymbol] = function() {
                  return this.entries();
                };
                Map3.prototype._find = function(key, insert) {
                  if (!SameValueZero(this._cacheKey, key)) {
                    this._cacheIndex = -1;
                    for (var i2 = 0; i2 < this._keys.length; i2++) {
                      if (SameValueZero(this._keys[i2], key)) {
                        this._cacheIndex = i2;
                        break;
                      }
                    }
                  }
                  if (this._cacheIndex < 0 && insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(void 0);
                  }
                  return this._cacheIndex;
                };
                return Map3;
              })()
            );
            return Map2;
            function getKey(key, _3) {
              return key;
            }
            function getValue(_3, value) {
              return value;
            }
            function getEntry(key, value) {
              return [key, value];
            }
          }
          function CreateSetPolyfill() {
            var Set2 = (
              /** @class */
              (function() {
                function Set3() {
                  this._map = new _Map();
                }
                Object.defineProperty(Set3.prototype, "size", {
                  get: function() {
                    return this._map.size;
                  },
                  enumerable: true,
                  configurable: true
                });
                Set3.prototype.has = function(value) {
                  return this._map.has(value);
                };
                Set3.prototype.add = function(value) {
                  return this._map.set(value, value), this;
                };
                Set3.prototype.delete = function(value) {
                  return this._map.delete(value);
                };
                Set3.prototype.clear = function() {
                  this._map.clear();
                };
                Set3.prototype.keys = function() {
                  return this._map.keys();
                };
                Set3.prototype.values = function() {
                  return this._map.keys();
                };
                Set3.prototype.entries = function() {
                  return this._map.entries();
                };
                Set3.prototype["@@iterator"] = function() {
                  return this.keys();
                };
                Set3.prototype[iteratorSymbol] = function() {
                  return this.keys();
                };
                return Set3;
              })()
            );
            return Set2;
          }
          function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (
              /** @class */
              (function() {
                function WeakMap2() {
                  this._key = CreateUniqueKey();
                }
                WeakMap2.prototype.has = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.has(table, this._key) : false;
                };
                WeakMap2.prototype.get = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? HashMap.get(table, this._key) : void 0;
                };
                WeakMap2.prototype.set = function(target, value) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    true
                  );
                  table[this._key] = value;
                  return this;
                };
                WeakMap2.prototype.delete = function(target) {
                  var table = GetOrCreateWeakMapTable(
                    target,
                    /*create*/
                    false
                  );
                  return table !== void 0 ? delete table[this._key] : false;
                };
                WeakMap2.prototype.clear = function() {
                  this._key = CreateUniqueKey();
                };
                return WeakMap2;
              })()
            );
            function CreateUniqueKey() {
              var key;
              do
                key = "@@WeakMap@@" + CreateUUID();
              while (HashMap.has(keys, key));
              keys[key] = true;
              return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
              if (!hasOwn.call(target, rootKey)) {
                if (!create)
                  return void 0;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
              }
              return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
              for (var i2 = 0; i2 < size; ++i2)
                buffer[i2] = Math.random() * 255 | 0;
              return buffer;
            }
            function GenRandomBytes(size) {
              if (typeof Uint8Array === "function") {
                var array = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                  crypto.getRandomValues(array);
                } else if (typeof msCrypto !== "undefined") {
                  msCrypto.getRandomValues(array);
                } else {
                  FillRandomBytes(array, size);
                }
                return array;
              }
              return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
              var data = GenRandomBytes(UUID_SIZE);
              data[6] = data[6] & 79 | 64;
              data[8] = data[8] & 191 | 128;
              var result = "";
              for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                  result += "-";
                if (byte < 16)
                  result += "0";
                result += byte.toString(16).toLowerCase();
              }
              return result;
            }
          }
          function MakeDictionary(obj) {
            obj.__ = void 0;
            delete obj.__;
            return obj;
          }
        });
      })(Reflect2 || (Reflect2 = {}));
    }
  });

  // ../../node_modules/sprotty/lib/base/actions/action.js
  var require_action = __commonJS({
    "../../node_modules/sprotty/lib/base/actions/action.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isLabeledAction = exports.LabeledAction = void 0;
      var LabeledAction = class {
        constructor(label, actions, icon) {
          this.label = label;
          this.actions = actions;
          this.icon = icon;
        }
      };
      exports.LabeledAction = LabeledAction;
      function isLabeledAction(element) {
        return element !== void 0 && element.label !== void 0 && element.actions !== void 0;
      }
      exports.isLabeledAction = isLabeledAction;
    }
  });

  // ../../node_modules/@inversifyjs/common/lib/cjs/services/calculations/stringifyServiceIdentifier.js
  var require_stringifyServiceIdentifier = __commonJS({
    "../../node_modules/@inversifyjs/common/lib/cjs/services/calculations/stringifyServiceIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringifyServiceIdentifier = stringifyServiceIdentifier;
      function stringifyServiceIdentifier(serviceIdentifier) {
        switch (typeof serviceIdentifier) {
          case "string":
          case "symbol":
            return serviceIdentifier.toString();
          case "function":
            return serviceIdentifier.name;
          default:
            throw new Error(`Unexpected ${typeof serviceIdentifier} service id type`);
        }
      }
    }
  });

  // ../../node_modules/@inversifyjs/common/lib/cjs/services/models/LazyServiceIdentifier.js
  var require_LazyServiceIdentifier = __commonJS({
    "../../node_modules/@inversifyjs/common/lib/cjs/services/models/LazyServiceIdentifier.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LazyServiceIdentifier = exports.islazyServiceIdentifierSymbol = void 0;
      exports.islazyServiceIdentifierSymbol = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
      var _a4, _buildServiceId;
      _a4 = exports.islazyServiceIdentifierSymbol;
      var LazyServiceIdentifier = class {
        constructor(buildServiceId) {
          __publicField(this, _a4);
          __privateAdd(this, _buildServiceId);
          __privateSet(this, _buildServiceId, buildServiceId);
          this[exports.islazyServiceIdentifierSymbol] = true;
        }
        static is(value) {
          return typeof value === "object" && value !== null && value[exports.islazyServiceIdentifierSymbol] === true;
        }
        unwrap() {
          return __privateGet(this, _buildServiceId).call(this);
        }
      };
      _buildServiceId = new WeakMap();
      exports.LazyServiceIdentifier = LazyServiceIdentifier;
    }
  });

  // ../../node_modules/@inversifyjs/common/lib/cjs/index.js
  var require_cjs = __commonJS({
    "../../node_modules/@inversifyjs/common/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringifyServiceIdentifier = exports.LazyServiceIdentifier = void 0;
      var stringifyServiceIdentifier_1 = require_stringifyServiceIdentifier();
      Object.defineProperty(exports, "stringifyServiceIdentifier", { enumerable: true, get: function() {
        return stringifyServiceIdentifier_1.stringifyServiceIdentifier;
      } });
      var LazyServiceIdentifier_1 = require_LazyServiceIdentifier();
      Object.defineProperty(exports, "LazyServiceIdentifier", { enumerable: true, get: function() {
        return LazyServiceIdentifier_1.LazyServiceIdentifier;
      } });
    }
  });

  // ../../node_modules/inversify/lib/cjs/constants/metadata_keys.js
  var require_metadata_keys = __commonJS({
    "../../node_modules/inversify/lib/cjs/constants/metadata_keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
      exports.NAMED_TAG = "named";
      exports.NAME_TAG = "name";
      exports.UNMANAGED_TAG = "unmanaged";
      exports.OPTIONAL_TAG = "optional";
      exports.INJECT_TAG = "inject";
      exports.MULTI_INJECT_TAG = "multi_inject";
      exports.TAGGED = "inversify:tagged";
      exports.TAGGED_PROP = "inversify:tagged_props";
      exports.PARAM_TYPES = "inversify:paramtypes";
      exports.DESIGN_PARAM_TYPES = "design:paramtypes";
      exports.POST_CONSTRUCT = "post_construct";
      exports.PRE_DESTROY = "pre_destroy";
      function getNonCustomTagKeys() {
        return [
          exports.INJECT_TAG,
          exports.MULTI_INJECT_TAG,
          exports.NAME_TAG,
          exports.UNMANAGED_TAG,
          exports.NAMED_TAG,
          exports.OPTIONAL_TAG
        ];
      }
      exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
    }
  });

  // ../../node_modules/inversify/lib/cjs/constants/literal_types.js
  var require_literal_types = __commonJS({
    "../../node_modules/inversify/lib/cjs/constants/literal_types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = void 0;
      var BindingScopeEnum = {
        Request: "Request",
        Singleton: "Singleton",
        Transient: "Transient"
      };
      exports.BindingScopeEnum = BindingScopeEnum;
      var BindingTypeEnum = {
        ConstantValue: "ConstantValue",
        Constructor: "Constructor",
        DynamicValue: "DynamicValue",
        Factory: "Factory",
        Function: "Function",
        Instance: "Instance",
        Invalid: "Invalid",
        Provider: "Provider"
      };
      exports.BindingTypeEnum = BindingTypeEnum;
      var TargetTypeEnum = {
        ClassProperty: "ClassProperty",
        ConstructorArgument: "ConstructorArgument",
        Variable: "Variable"
      };
      exports.TargetTypeEnum = TargetTypeEnum;
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/id.js
  var require_id = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/id.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.id = id;
      var idCounter = 0;
      function id() {
        return idCounter++;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/bindings/binding.js
  var require_binding = __commonJS({
    "../../node_modules/inversify/lib/cjs/bindings/binding.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Binding = void 0;
      var literal_types_1 = require_literal_types();
      var id_1 = require_id();
      var Binding = class _Binding {
        constructor(serviceIdentifier, scope) {
          __publicField(this, "id");
          __publicField(this, "moduleId");
          // Determines weather the bindings has been already activated
          // The activation action takes place when an instance is resolved
          // If the scope is singleton it only happens once
          __publicField(this, "activated");
          // A runtime identifier because at runtime we don't have interfaces
          __publicField(this, "serviceIdentifier");
          // constructor from binding to or toConstructor
          __publicField(this, "implementationType");
          // Cache used to allow singleton scope and BindingType.ConstantValue bindings
          __publicField(this, "cache");
          // Cache used to allow BindingType.DynamicValue bindings
          __publicField(this, "dynamicValue");
          // The scope mode to be used
          __publicField(this, "scope");
          // The kind of binding
          __publicField(this, "type");
          // A factory method used in BindingType.Factory bindings
          __publicField(this, "factory");
          // An async factory method used in BindingType.Provider bindings
          __publicField(this, "provider");
          // A constraint used to limit the contexts in which this binding is applicable
          __publicField(this, "constraint");
          // On activation handler (invoked just before an instance is added to cache and injected)
          __publicField(this, "onActivation");
          // On deactivation handler (invoked just before an instance is unbinded and removed from container)
          __publicField(this, "onDeactivation");
          this.id = (0, id_1.id)();
          this.activated = false;
          this.serviceIdentifier = serviceIdentifier;
          this.scope = scope;
          this.type = literal_types_1.BindingTypeEnum.Invalid;
          this.constraint = (_request) => true;
          this.implementationType = null;
          this.cache = null;
          this.factory = null;
          this.provider = null;
          this.onActivation = null;
          this.onDeactivation = null;
          this.dynamicValue = null;
        }
        clone() {
          const clone = new _Binding(this.serviceIdentifier, this.scope);
          clone.activated = clone.scope === literal_types_1.BindingScopeEnum.Singleton ? this.activated : false;
          clone.implementationType = this.implementationType;
          clone.dynamicValue = this.dynamicValue;
          clone.scope = this.scope;
          clone.type = this.type;
          clone.factory = this.factory;
          clone.provider = this.provider;
          clone.constraint = this.constraint;
          clone.onActivation = this.onActivation;
          clone.onDeactivation = this.onDeactivation;
          clone.cache = this.cache;
          return clone;
        }
      };
      exports.Binding = Binding;
    }
  });

  // ../../node_modules/inversify/lib/cjs/constants/error_msgs.js
  var require_error_msgs = __commonJS({
    "../../node_modules/inversify/lib/cjs/constants/error_msgs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.STACK_OVERFLOW = exports.CIRCULAR_DEPENDENCY_IN_FACTORY = exports.ON_DEACTIVATION_ERROR = exports.PRE_DESTROY_ERROR = exports.POST_CONSTRUCT_ERROR = exports.ASYNC_UNBIND_REQUIRED = exports.MULTIPLE_POST_CONSTRUCT_METHODS = exports.MULTIPLE_PRE_DESTROY_METHODS = exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = exports.ARGUMENTS_LENGTH_MISMATCH = exports.INVALID_DECORATOR_OPERATION = exports.INVALID_TO_SELF_VALUE = exports.LAZY_IN_SYNC = exports.INVALID_FUNCTION_BINDING = exports.INVALID_MIDDLEWARE_RETURN = exports.NO_MORE_SNAPSHOTS_AVAILABLE = exports.INVALID_BINDING_TYPE = exports.CIRCULAR_DEPENDENCY = exports.UNDEFINED_INJECT_ANNOTATION = exports.TRYING_TO_RESOLVE_BINDINGS = exports.NOT_REGISTERED = exports.CANNOT_UNBIND = exports.AMBIGUOUS_MATCH = exports.KEY_NOT_FOUND = exports.NULL_ARGUMENT = exports.DUPLICATED_METADATA = exports.DUPLICATED_INJECTABLE_DECORATOR = void 0;
      exports.DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
      exports.DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
      exports.NULL_ARGUMENT = "NULL argument";
      exports.KEY_NOT_FOUND = "Key Not Found";
      exports.AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
      exports.CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
      exports.NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
      var TRYING_TO_RESOLVE_BINDINGS = (name) => `Trying to resolve bindings for "${name}"`;
      exports.TRYING_TO_RESOLVE_BINDINGS = TRYING_TO_RESOLVE_BINDINGS;
      var UNDEFINED_INJECT_ANNOTATION = (name) => `@inject called with undefined this could mean that the class ${name} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`;
      exports.UNDEFINED_INJECT_ANNOTATION = UNDEFINED_INJECT_ANNOTATION;
      exports.CIRCULAR_DEPENDENCY = "Circular dependency found:";
      exports.INVALID_BINDING_TYPE = "Invalid binding type:";
      exports.NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
      exports.INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
      exports.INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
      var LAZY_IN_SYNC = (key) => `You are attempting to construct ${keyToString(key)} in a synchronous way but it has asynchronous dependencies.`;
      exports.LAZY_IN_SYNC = LAZY_IN_SYNC;
      exports.INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
      exports.INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
      var ARGUMENTS_LENGTH_MISMATCH = (name) => `The number of constructor arguments in the derived class ${name} must be >= than the number of constructor arguments of its base class.`;
      exports.ARGUMENTS_LENGTH_MISMATCH = ARGUMENTS_LENGTH_MISMATCH;
      exports.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
      exports.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must be a string ("singleton" or "transient").';
      exports.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
      exports.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
      exports.MULTIPLE_PRE_DESTROY_METHODS = "Cannot apply @preDestroy decorator multiple times in the same class";
      exports.MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
      exports.ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
      var POST_CONSTRUCT_ERROR = (clazz, errorMessage) => `@postConstruct error in class ${clazz}: ${errorMessage}`;
      exports.POST_CONSTRUCT_ERROR = POST_CONSTRUCT_ERROR;
      var PRE_DESTROY_ERROR = (clazz, errorMessage) => `@preDestroy error in class ${clazz}: ${errorMessage}`;
      exports.PRE_DESTROY_ERROR = PRE_DESTROY_ERROR;
      var ON_DEACTIVATION_ERROR = (clazz, errorMessage) => `onDeactivation() error in class ${clazz}: ${errorMessage}`;
      exports.ON_DEACTIVATION_ERROR = ON_DEACTIVATION_ERROR;
      var CIRCULAR_DEPENDENCY_IN_FACTORY = (factoryType, serviceIdentifier) => `It looks like there is a circular dependency in one of the '${factoryType}' bindings. Please investigate bindings with service identifier '${serviceIdentifier}'.`;
      exports.CIRCULAR_DEPENDENCY_IN_FACTORY = CIRCULAR_DEPENDENCY_IN_FACTORY;
      exports.STACK_OVERFLOW = "Maximum call stack size exceeded";
      function keyToString(key) {
        if (typeof key === "function") {
          return `[function/class ${key.name || "<anonymous>"}]`;
        }
        if (typeof key === "symbol") {
          return key.toString();
        }
        return `'${key}'`;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/metadata_reader.js
  var require_metadata_reader = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/metadata_reader.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MetadataReader = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var MetadataReader = class {
        getConstructorMetadata(constructorFunc) {
          var _a4;
          const compilerGeneratedMetadata = (_a4 = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, constructorFunc)) != null ? _a4 : [];
          const userGeneratedMetadata = Reflect.getMetadata(METADATA_KEY.TAGGED, constructorFunc);
          return {
            compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata != null ? userGeneratedMetadata : {}
          };
        }
        getPropertiesMetadata(constructorFunc) {
          var _a4;
          const userGeneratedMetadata = (_a4 = Reflect.getMetadata(METADATA_KEY.TAGGED_PROP, constructorFunc)) != null ? _a4 : {};
          return userGeneratedMetadata;
        }
      };
      exports.MetadataReader = MetadataReader;
    }
  });

  // ../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/getReflectMetadata.js
  var require_getReflectMetadata = __commonJS({
    "../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/getReflectMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getReflectMetadata = getReflectMetadata;
      function getReflectMetadata(target, metadataKey) {
        return Reflect.getMetadata(metadataKey, target);
      }
    }
  });

  // ../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/updateReflectMetadata.js
  var require_updateReflectMetadata = __commonJS({
    "../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/reflectMetadata/utils/updateReflectMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.updateReflectMetadata = updateReflectMetadata;
      var getReflectMetadata_1 = require_getReflectMetadata();
      function updateReflectMetadata(target, metadataKey, defaultValue, callback) {
        var _a4;
        const metadata = (_a4 = (0, getReflectMetadata_1.getReflectMetadata)(target, metadataKey)) != null ? _a4 : defaultValue;
        const updatedMetadata = callback(metadata);
        Reflect.defineMetadata(metadataKey, updatedMetadata, target);
      }
    }
  });

  // ../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/index.js
  var require_cjs2 = __commonJS({
    "../../node_modules/@inversifyjs/reflect-metadata-utils/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.updateReflectMetadata = exports.getReflectMetadata = void 0;
      var getReflectMetadata_1 = require_getReflectMetadata();
      Object.defineProperty(exports, "getReflectMetadata", { enumerable: true, get: function() {
        return getReflectMetadata_1.getReflectMetadata;
      } });
      var updateReflectMetadata_1 = require_updateReflectMetadata();
      Object.defineProperty(exports, "updateReflectMetadata", { enumerable: true, get: function() {
        return updateReflectMetadata_1.updateReflectMetadata;
      } });
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/reflectMetadata/data/keys.js
  var require_keys = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/reflectMetadata/data/keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NON_CUSTOM_TAG_KEYS = exports.PRE_DESTROY = exports.POST_CONSTRUCT = exports.DESIGN_PARAM_TYPES = exports.PARAM_TYPES = exports.TAGGED_PROP = exports.TAGGED = exports.MULTI_INJECT_TAG = exports.INJECT_TAG = exports.OPTIONAL_TAG = exports.UNMANAGED_TAG = exports.NAME_TAG = exports.NAMED_TAG = void 0;
      exports.NAMED_TAG = "named";
      exports.NAME_TAG = "name";
      exports.UNMANAGED_TAG = "unmanaged";
      exports.OPTIONAL_TAG = "optional";
      exports.INJECT_TAG = "inject";
      exports.MULTI_INJECT_TAG = "multi_inject";
      exports.TAGGED = "inversify:tagged";
      exports.TAGGED_PROP = "inversify:tagged_props";
      exports.PARAM_TYPES = "inversify:paramtypes";
      exports.DESIGN_PARAM_TYPES = "design:paramtypes";
      exports.POST_CONSTRUCT = "post_construct";
      exports.PRE_DESTROY = "pre_destroy";
      function getNonCustomTagKeys() {
        return [
          exports.INJECT_TAG,
          exports.MULTI_INJECT_TAG,
          exports.NAME_TAG,
          exports.UNMANAGED_TAG,
          exports.NAMED_TAG,
          exports.OPTIONAL_TAG
        ];
      }
      exports.NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreError.js
  var require_InversifyCoreError = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InversifyCoreError = exports.isAppErrorSymbol = void 0;
      exports.isAppErrorSymbol = Symbol.for("@inversifyjs/core/InversifyCoreError");
      var _a4, _b2;
      var InversifyCoreError = class _InversifyCoreError extends (_b2 = Error, _a4 = exports.isAppErrorSymbol, _b2) {
        constructor(kind, message, options) {
          super(message, options);
          __publicField(this, _a4);
          __publicField(this, "kind");
          this[exports.isAppErrorSymbol] = true;
          this.kind = kind;
        }
        static is(value) {
          return typeof value === "object" && value !== null && value[exports.isAppErrorSymbol] === true;
        }
        static isErrorOfKind(value, kind) {
          return _InversifyCoreError.is(value) && value.kind === kind;
        }
      };
      exports.InversifyCoreError = InversifyCoreError;
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreErrorKind.js
  var require_InversifyCoreErrorKind = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/error/models/InversifyCoreErrorKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InversifyCoreErrorKind = void 0;
      var InversifyCoreErrorKind;
      (function(InversifyCoreErrorKind2) {
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["injectionDecoratorConflict"] = 0] = "injectionDecoratorConflict";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["missingInjectionDecorator"] = 1] = "missingInjectionDecorator";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["planning"] = 2] = "planning";
        InversifyCoreErrorKind2[InversifyCoreErrorKind2["unknown"] = 3] = "unknown";
      })(InversifyCoreErrorKind || (exports.InversifyCoreErrorKind = InversifyCoreErrorKind = {}));
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/assertConstructorMetadataArrayFilled.js
  var require_assertConstructorMetadataArrayFilled = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/assertConstructorMetadataArrayFilled.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertConstructorMetadataArrayFilled = assertConstructorMetadataArrayFilled;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      function assertConstructorMetadataArrayFilled(type, value) {
        const undefinedIndexes = [];
        for (let i2 = 0; i2 < value.length; ++i2) {
          const element = value[i2];
          if (element === void 0) {
            undefinedIndexes.push(i2);
          }
        }
        if (undefinedIndexes.length > 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Found unexpected missing metadata on type "${type.name}" at constructor indexes "${undefinedIndexes.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
        }
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/models/ClassElementMetadataKind.js
  var require_ClassElementMetadataKind = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/models/ClassElementMetadataKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClassElementMetadataKind = void 0;
      var ClassElementMetadataKind;
      (function(ClassElementMetadataKind2) {
        ClassElementMetadataKind2[ClassElementMetadataKind2["multipleInjection"] = 0] = "multipleInjection";
        ClassElementMetadataKind2[ClassElementMetadataKind2["singleInjection"] = 1] = "singleInjection";
        ClassElementMetadataKind2[ClassElementMetadataKind2["unmanaged"] = 2] = "unmanaged";
      })(ClassElementMetadataKind || (exports.ClassElementMetadataKind = ClassElementMetadataKind = {}));
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromNewable.js
  var require_getClassElementMetadataFromNewable = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromNewable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassElementMetadataFromNewable = getClassElementMetadataFromNewable;
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getClassElementMetadataFromNewable(type) {
        return {
          kind: ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection,
          name: void 0,
          optional: false,
          tags: /* @__PURE__ */ new Map(),
          targetName: void 0,
          value: type
        };
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromLegacyMetadata.js
  var require_getClassElementMetadataFromLegacyMetadata = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassElementMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassElementMetadataFromLegacyMetadata = getClassElementMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var keys_1 = require_keys();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getClassElementMetadataFromLegacyMetadata(metadataList) {
        const injectMetadata = metadataList.find((metadata) => metadata.key === keys_1.INJECT_TAG);
        const multiInjectMetadata = metadataList.find((metadata) => metadata.key === keys_1.MULTI_INJECT_TAG);
        const unmanagedMetadata = metadataList.find((metadata) => metadata.key === keys_1.UNMANAGED_TAG);
        if (unmanagedMetadata !== void 0) {
          return getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata);
        }
        if (multiInjectMetadata === void 0 && injectMetadata === void 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
        }
        const nameMetadata = metadataList.find((metadata) => metadata.key === keys_1.NAMED_TAG);
        const optionalMetadata = metadataList.find((metadata) => metadata.key === keys_1.OPTIONAL_TAG);
        const targetNameMetadata = metadataList.find((metadata) => metadata.key === keys_1.NAME_TAG);
        const managedClassElementMetadata = {
          kind: injectMetadata === void 0 ? ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection : ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection,
          name: nameMetadata == null ? void 0 : nameMetadata.value,
          optional: optionalMetadata !== void 0,
          tags: new Map(metadataList.filter((metadata) => keys_1.NON_CUSTOM_TAG_KEYS.every((customTagKey) => metadata.key !== customTagKey)).map((metadata) => [
            metadata.key,
            metadata.value
          ])),
          targetName: targetNameMetadata == null ? void 0 : targetNameMetadata.value,
          value: injectMetadata === void 0 ? multiInjectMetadata == null ? void 0 : multiInjectMetadata.value : injectMetadata.value
        };
        return managedClassElementMetadata;
      }
      function getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata) {
        if (multiInjectMetadata !== void 0 || injectMetadata !== void 0) {
          throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
        }
        return {
          kind: ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged
        };
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getConstructorArgumentMetadataFromLegacyMetadata.js
  var require_getConstructorArgumentMetadataFromLegacyMetadata = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getConstructorArgumentMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getConstructorArgumentMetadataFromLegacyMetadata = getConstructorArgumentMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      function getConstructorArgumentMetadataFromLegacyMetadata(type, index, metadataList) {
        try {
          return (0, getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        } catch (error) {
          if (InversifyCoreError_1.InversifyCoreError.isErrorOfKind(error, InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator)) {
            throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${type.name}" at constructor arguments at index "${index.toString()}"`, { cause: error });
          } else {
            throw error;
          }
        }
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArguments.js
  var require_getClassMetadataConstructorArguments = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArguments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataConstructorArguments = getClassMetadataConstructorArguments;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var assertConstructorMetadataArrayFilled_1 = require_assertConstructorMetadataArrayFilled();
      var getClassElementMetadataFromNewable_1 = require_getClassElementMetadataFromNewable();
      var getConstructorArgumentMetadataFromLegacyMetadata_1 = require_getConstructorArgumentMetadataFromLegacyMetadata();
      function getClassMetadataConstructorArguments(type) {
        const typescriptMetadataList = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.DESIGN_PARAM_TYPES);
        const constructorParametersLegacyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.TAGGED);
        const constructorArgumentsMetadata = [];
        if (constructorParametersLegacyMetadata !== void 0) {
          for (const [stringifiedIndex, metadataList] of Object.entries(constructorParametersLegacyMetadata)) {
            const index = parseInt(stringifiedIndex);
            constructorArgumentsMetadata[index] = (0, getConstructorArgumentMetadataFromLegacyMetadata_1.getConstructorArgumentMetadataFromLegacyMetadata)(type, index, metadataList);
          }
        }
        if (typescriptMetadataList !== void 0) {
          for (let i2 = 0; i2 < typescriptMetadataList.length; ++i2) {
            if (constructorArgumentsMetadata[i2] === void 0) {
              const typescriptMetadata = typescriptMetadataList[i2];
              constructorArgumentsMetadata[i2] = (0, getClassElementMetadataFromNewable_1.getClassElementMetadataFromNewable)(typescriptMetadata);
            }
          }
        }
        (0, assertConstructorMetadataArrayFilled_1.assertConstructorMetadataArrayFilled)(type, constructorArgumentsMetadata);
        return constructorArgumentsMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getPropertyMetadataFromLegacyMetadata.js
  var require_getPropertyMetadataFromLegacyMetadata = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getPropertyMetadataFromLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPropertyMetadataFromLegacyMetadata = getPropertyMetadataFromLegacyMetadata;
      var InversifyCoreError_1 = require_InversifyCoreError();
      var InversifyCoreErrorKind_1 = require_InversifyCoreErrorKind();
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      function getPropertyMetadataFromLegacyMetadata(type, key, metadataList) {
        try {
          return (0, getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        } catch (error) {
          if (InversifyCoreError_1.InversifyCoreError.isErrorOfKind(error, InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator)) {
            throw new InversifyCoreError_1.InversifyCoreError(InversifyCoreErrorKind_1.InversifyCoreErrorKind.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${type.name}" at property "${key.toString()}"`, { cause: error });
          } else {
            throw error;
          }
        }
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataProperties.js
  var require_getClassMetadataProperties = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataProperties.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataProperties = getClassMetadataProperties;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getPropertyMetadataFromLegacyMetadata_1 = require_getPropertyMetadataFromLegacyMetadata();
      function getClassMetadataProperties(type) {
        const propertiesLegacyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.TAGGED_PROP);
        const propertiesMetadata = /* @__PURE__ */ new Map();
        if (propertiesLegacyMetadata !== void 0) {
          for (const property of Reflect.ownKeys(propertiesLegacyMetadata)) {
            const legacyMetadata = propertiesLegacyMetadata[property];
            propertiesMetadata.set(property, (0, getPropertyMetadataFromLegacyMetadata_1.getPropertyMetadataFromLegacyMetadata)(type, property, legacyMetadata));
          }
        }
        return propertiesMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadata.js
  var require_getClassMetadata = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadata = getClassMetadata;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getClassMetadataConstructorArguments_1 = require_getClassMetadataConstructorArguments();
      var getClassMetadataProperties_1 = require_getClassMetadataProperties();
      function getClassMetadata(type) {
        const postConstructMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.POST_CONSTRUCT);
        const preDestroyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.PRE_DESTROY);
        const classMetadata = {
          constructorArguments: (0, getClassMetadataConstructorArguments_1.getClassMetadataConstructorArguments)(type),
          lifecycle: {
            postConstructMethodName: postConstructMetadata == null ? void 0 : postConstructMetadata.value,
            preDestroyMethodName: preDestroyMetadata == null ? void 0 : preDestroyMetadata.value
          },
          properties: (0, getClassMetadataProperties_1.getClassMetadataProperties)(type)
        };
        return classMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArgumentsFromMetadataReader.js
  var require_getClassMetadataConstructorArgumentsFromMetadataReader = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataConstructorArgumentsFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataConstructorArgumentsFromMetadataReader = getClassMetadataConstructorArgumentsFromMetadataReader;
      var assertConstructorMetadataArrayFilled_1 = require_assertConstructorMetadataArrayFilled();
      var getClassElementMetadataFromNewable_1 = require_getClassElementMetadataFromNewable();
      var getConstructorArgumentMetadataFromLegacyMetadata_1 = require_getConstructorArgumentMetadataFromLegacyMetadata();
      function getClassMetadataConstructorArgumentsFromMetadataReader(type, metadataReader) {
        const legacyConstructorMetadata = metadataReader.getConstructorMetadata(type);
        const constructorArgumentsMetadata = [];
        for (const [stringifiedIndex, metadataList] of Object.entries(legacyConstructorMetadata.userGeneratedMetadata)) {
          const index = parseInt(stringifiedIndex);
          constructorArgumentsMetadata[index] = (0, getConstructorArgumentMetadataFromLegacyMetadata_1.getConstructorArgumentMetadataFromLegacyMetadata)(type, index, metadataList);
        }
        if (legacyConstructorMetadata.compilerGeneratedMetadata !== void 0) {
          for (let i2 = 0; i2 < legacyConstructorMetadata.compilerGeneratedMetadata.length; ++i2) {
            if (constructorArgumentsMetadata[i2] === void 0) {
              const typescriptMetadata = legacyConstructorMetadata.compilerGeneratedMetadata[i2];
              constructorArgumentsMetadata[i2] = (0, getClassElementMetadataFromNewable_1.getClassElementMetadataFromNewable)(typescriptMetadata);
            }
          }
        }
        (0, assertConstructorMetadataArrayFilled_1.assertConstructorMetadataArrayFilled)(type, constructorArgumentsMetadata);
        return constructorArgumentsMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataPropertiesFromMetadataReader.js
  var require_getClassMetadataPropertiesFromMetadataReader = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataPropertiesFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataPropertiesFromMetadataReader = getClassMetadataPropertiesFromMetadataReader;
      var getPropertyMetadataFromLegacyMetadata_1 = require_getPropertyMetadataFromLegacyMetadata();
      function getClassMetadataPropertiesFromMetadataReader(type, metadataReader) {
        const propertiesLegacyMetadata = metadataReader.getPropertiesMetadata(type);
        const propertiesMetadata = /* @__PURE__ */ new Map();
        for (const property of Reflect.ownKeys(propertiesLegacyMetadata)) {
          const legacyMetadata = propertiesLegacyMetadata[property];
          propertiesMetadata.set(property, (0, getPropertyMetadataFromLegacyMetadata_1.getPropertyMetadataFromLegacyMetadata)(type, property, legacyMetadata));
        }
        return propertiesMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataFromMetadataReader.js
  var require_getClassMetadataFromMetadataReader = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getClassMetadataFromMetadataReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getClassMetadataFromMetadataReader = getClassMetadataFromMetadataReader;
      var reflect_metadata_utils_1 = require_cjs2();
      var keys_1 = require_keys();
      var getClassMetadataConstructorArgumentsFromMetadataReader_1 = require_getClassMetadataConstructorArgumentsFromMetadataReader();
      var getClassMetadataPropertiesFromMetadataReader_1 = require_getClassMetadataPropertiesFromMetadataReader();
      function getClassMetadataFromMetadataReader(type, metadataReader) {
        const postConstructMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.POST_CONSTRUCT);
        const preDestroyMetadata = (0, reflect_metadata_utils_1.getReflectMetadata)(type, keys_1.PRE_DESTROY);
        const classMetadata = {
          constructorArguments: (0, getClassMetadataConstructorArgumentsFromMetadataReader_1.getClassMetadataConstructorArgumentsFromMetadataReader)(type, metadataReader),
          lifecycle: {
            postConstructMethodName: postConstructMetadata == null ? void 0 : postConstructMetadata.value,
            preDestroyMethodName: preDestroyMetadata == null ? void 0 : preDestroyMetadata.value
          },
          properties: (0, getClassMetadataPropertiesFromMetadataReader_1.getClassMetadataPropertiesFromMetadataReader)(type, metadataReader)
        };
        return classMetadata;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/prototype/calculations/getBaseType.js
  var require_getBaseType = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/prototype/calculations/getBaseType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBaseType = getBaseType;
      function getBaseType(type) {
        const prototype = Object.getPrototypeOf(type.prototype);
        const baseType = prototype == null ? void 0 : prototype.constructor;
        return baseType;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getLegacyMetadata.js
  var require_getLegacyMetadata = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/metadata/calculations/getLegacyMetadata.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getLegacyMetadata = getLegacyMetadata;
      var keys_1 = require_keys();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      function getLegacyMetadata(classElementMetadata) {
        switch (classElementMetadata.kind) {
          case ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged:
            return getUnmanagedLegacyMetadata();
          default:
            return getManagedLegacyMetadata(classElementMetadata);
        }
      }
      function getManagedLegacyMetadata(classElementMetadata) {
        const legacyMetadataList = [
          getManagedKindLegacyMetadata(classElementMetadata)
        ];
        if (classElementMetadata.name !== void 0) {
          legacyMetadataList.push({
            key: keys_1.NAMED_TAG,
            value: classElementMetadata.name
          });
        }
        if (classElementMetadata.optional) {
          legacyMetadataList.push({
            key: keys_1.OPTIONAL_TAG,
            value: true
          });
        }
        for (const [tagKey, tagValue] of classElementMetadata.tags) {
          legacyMetadataList.push({
            key: tagKey,
            value: tagValue
          });
        }
        if (classElementMetadata.targetName !== void 0) {
          legacyMetadataList.push({
            key: keys_1.NAME_TAG,
            value: classElementMetadata.targetName
          });
        }
        return legacyMetadataList;
      }
      function getManagedKindLegacyMetadata(classElementMetadata) {
        let kindLegacyMetadata;
        switch (classElementMetadata.kind) {
          case ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection:
            kindLegacyMetadata = {
              key: keys_1.MULTI_INJECT_TAG,
              value: classElementMetadata.value
            };
            break;
          case ClassElementMetadataKind_1.ClassElementMetadataKind.singleInjection:
            kindLegacyMetadata = {
              key: keys_1.INJECT_TAG,
              value: classElementMetadata.value
            };
            break;
        }
        return kindLegacyMetadata;
      }
      function getUnmanagedLegacyMetadata() {
        return [
          {
            key: keys_1.UNMANAGED_TAG,
            value: true
          }
        ];
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/string/models/LegacyQueryableStringImpl.js
  var require_LegacyQueryableStringImpl = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/string/models/LegacyQueryableStringImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyQueryableStringImpl = void 0;
      var _str;
      var LegacyQueryableStringImpl = class {
        constructor(str) {
          __privateAdd(this, _str);
          __privateSet(this, _str, str);
        }
        startsWith(searchString) {
          return __privateGet(this, _str).startsWith(searchString);
        }
        endsWith(searchString) {
          return __privateGet(this, _str).endsWith(searchString);
        }
        contains(searchString) {
          return __privateGet(this, _str).includes(searchString);
        }
        equals(compareString) {
          return __privateGet(this, _str) === compareString;
        }
        value() {
          return __privateGet(this, _str);
        }
      };
      _str = new WeakMap();
      exports.LegacyQueryableStringImpl = LegacyQueryableStringImpl;
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/symbol/calculations/getDescription.js
  var require_getDescription = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/symbol/calculations/getDescription.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDescription = getDescription;
      var SYMBOL_INDEX_START = 7;
      var SYMBOL_INDEX_END = -1;
      function getDescription(symbol) {
        return symbol.toString().slice(SYMBOL_INDEX_START, SYMBOL_INDEX_END);
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetId.js
  var require_getTargetId = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetId.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargetId = getTargetId;
      var reflect_metadata_utils_1 = require_cjs2();
      var ID_METADATA = "@inversifyjs/core/targetId";
      function getTargetId() {
        var _a4;
        const targetId = (_a4 = (0, reflect_metadata_utils_1.getReflectMetadata)(Object, ID_METADATA)) != null ? _a4 : 0;
        if (targetId === Number.MAX_SAFE_INTEGER) {
          (0, reflect_metadata_utils_1.updateReflectMetadata)(Object, ID_METADATA, targetId, () => Number.MIN_SAFE_INTEGER);
        } else {
          (0, reflect_metadata_utils_1.updateReflectMetadata)(Object, ID_METADATA, targetId, (id) => id + 1);
        }
        return targetId;
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/models/LegacyTargetImpl.js
  var require_LegacyTargetImpl = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/models/LegacyTargetImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyTargetImpl = void 0;
      var common_1 = require_cjs();
      var getLegacyMetadata_1 = require_getLegacyMetadata();
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      var keys_1 = require_keys();
      var LegacyQueryableStringImpl_1 = require_LegacyQueryableStringImpl();
      var getDescription_1 = require_getDescription();
      var getTargetId_1 = require_getTargetId();
      var _metadata, _id, _identifier, _lazyLegacyMetadata, _name, _type;
      var LegacyTargetImpl = class {
        constructor(identifier, metadata, type) {
          __privateAdd(this, _metadata);
          __privateAdd(this, _id);
          __privateAdd(this, _identifier);
          __privateAdd(this, _lazyLegacyMetadata);
          __privateAdd(this, _name);
          __privateAdd(this, _type);
          __privateSet(this, _id, (0, getTargetId_1.getTargetId)());
          __privateSet(this, _identifier, identifier);
          __privateSet(this, _lazyLegacyMetadata, void 0);
          __privateSet(this, _metadata, metadata);
          __privateSet(this, _name, new LegacyQueryableStringImpl_1.LegacyQueryableStringImpl(typeof identifier === "string" ? identifier : (0, getDescription_1.getDescription)(identifier)));
          __privateSet(this, _type, type);
        }
        get id() {
          return __privateGet(this, _id);
        }
        /**
         * If this is a class property target, this is the name of the property to be injected
         */
        get identifier() {
          return __privateGet(this, _identifier);
        }
        get metadata() {
          if (__privateGet(this, _lazyLegacyMetadata) === void 0) {
            __privateSet(this, _lazyLegacyMetadata, (0, getLegacyMetadata_1.getLegacyMetadata)(__privateGet(this, _metadata)));
          }
          return __privateGet(this, _lazyLegacyMetadata);
        }
        get name() {
          return __privateGet(this, _name);
        }
        get type() {
          return __privateGet(this, _type);
        }
        get serviceIdentifier() {
          if (common_1.LazyServiceIdentifier.is(__privateGet(this, _metadata).value)) {
            return __privateGet(this, _metadata).value.unwrap();
          } else {
            return __privateGet(this, _metadata).value;
          }
        }
        getCustomTags() {
          return [...__privateGet(this, _metadata).tags.entries()].map(([key, value]) => ({
            key,
            value
          }));
        }
        getNamedTag() {
          return __privateGet(this, _metadata).name === void 0 ? null : {
            key: keys_1.NAMED_TAG,
            value: __privateGet(this, _metadata).name
          };
        }
        hasTag(key) {
          return this.metadata.some((metadata) => metadata.key === key);
        }
        isArray() {
          return __privateGet(this, _metadata).kind === ClassElementMetadataKind_1.ClassElementMetadataKind.multipleInjection;
        }
        isNamed() {
          return __privateGet(this, _metadata).name !== void 0;
        }
        isOptional() {
          return __privateGet(this, _metadata).optional;
        }
        isTagged() {
          return __privateGet(this, _metadata).tags.size > 0;
        }
        matchesArray(name) {
          return this.isArray() && __privateGet(this, _metadata).value === name;
        }
        matchesNamedTag(name) {
          return __privateGet(this, _metadata).name === name;
        }
        matchesTag(key) {
          return (value) => this.metadata.some((metadata) => metadata.key === key && metadata.value === value);
        }
      };
      _metadata = new WeakMap();
      _id = new WeakMap();
      _identifier = new WeakMap();
      _lazyLegacyMetadata = new WeakMap();
      _name = new WeakMap();
      _type = new WeakMap();
      exports.LegacyTargetImpl = LegacyTargetImpl;
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetsFromMetadataProviders.js
  var require_getTargetsFromMetadataProviders = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargetsFromMetadataProviders.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargetsFromMetadataProviders = getTargetsFromMetadataProviders;
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      var getBaseType_1 = require_getBaseType();
      var LegacyTargetImpl_1 = require_LegacyTargetImpl();
      function getTargetsFromMetadataProviders(getClassMetadata, getClassMetadataProperties) {
        return function getTagets(type) {
          var _a4, _b2;
          const classMetadata = getClassMetadata(type);
          let baseType = (0, getBaseType_1.getBaseType)(type);
          while (baseType !== void 0 && baseType !== Object) {
            const classMetadataProperties = getClassMetadataProperties(baseType);
            for (const [propertyKey, propertyValue] of classMetadataProperties) {
              if (!classMetadata.properties.has(propertyKey)) {
                classMetadata.properties.set(propertyKey, propertyValue);
              }
            }
            baseType = (0, getBaseType_1.getBaseType)(baseType);
          }
          const targets = [];
          for (const constructorArgument of classMetadata.constructorArguments) {
            if (constructorArgument.kind !== ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged) {
              const targetName = (_a4 = constructorArgument.targetName) != null ? _a4 : "";
              targets.push(new LegacyTargetImpl_1.LegacyTargetImpl(targetName, constructorArgument, "ConstructorArgument"));
            }
          }
          for (const [property, metadata] of classMetadata.properties) {
            if (metadata.kind !== ClassElementMetadataKind_1.ClassElementMetadataKind.unmanaged) {
              const targetName = (_b2 = metadata.targetName) != null ? _b2 : property;
              targets.push(new LegacyTargetImpl_1.LegacyTargetImpl(targetName, metadata, "ClassProperty"));
            }
          }
          return targets;
        };
      }
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargets.js
  var require_getTargets = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/legacyTarget/calculations/getTargets.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTargets = void 0;
      var getClassMetadata_1 = require_getClassMetadata();
      var getClassMetadataFromMetadataReader_1 = require_getClassMetadataFromMetadataReader();
      var getClassMetadataProperties_1 = require_getClassMetadataProperties();
      var getClassMetadataPropertiesFromMetadataReader_1 = require_getClassMetadataPropertiesFromMetadataReader();
      var getTargetsFromMetadataProviders_1 = require_getTargetsFromMetadataProviders();
      var getTargets = (metadataReader) => {
        const getClassMetadataFn = metadataReader === void 0 ? getClassMetadata_1.getClassMetadata : (type) => (0, getClassMetadataFromMetadataReader_1.getClassMetadataFromMetadataReader)(type, metadataReader);
        const getClassMetadataPropertiesFn = metadataReader === void 0 ? getClassMetadataProperties_1.getClassMetadataProperties : (type) => (0, getClassMetadataPropertiesFromMetadataReader_1.getClassMetadataPropertiesFromMetadataReader)(type, metadataReader);
        return (0, getTargetsFromMetadataProviders_1.getTargetsFromMetadataProviders)(getClassMetadataFn, getClassMetadataPropertiesFn);
      };
      exports.getTargets = getTargets;
    }
  });

  // ../../node_modules/@inversifyjs/core/lib/cjs/index.js
  var require_cjs3 = __commonJS({
    "../../node_modules/@inversifyjs/core/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LegacyTargetImpl = exports.getTargets = exports.getClassMetadataFromMetadataReader = exports.getClassMetadata = exports.getClassElementMetadataFromLegacyMetadata = exports.ClassElementMetadataKind = void 0;
      var getTargets_1 = require_getTargets();
      Object.defineProperty(exports, "getTargets", { enumerable: true, get: function() {
        return getTargets_1.getTargets;
      } });
      var LegacyTargetImpl_1 = require_LegacyTargetImpl();
      Object.defineProperty(exports, "LegacyTargetImpl", { enumerable: true, get: function() {
        return LegacyTargetImpl_1.LegacyTargetImpl;
      } });
      var getClassElementMetadataFromLegacyMetadata_1 = require_getClassElementMetadataFromLegacyMetadata();
      Object.defineProperty(exports, "getClassElementMetadataFromLegacyMetadata", { enumerable: true, get: function() {
        return getClassElementMetadataFromLegacyMetadata_1.getClassElementMetadataFromLegacyMetadata;
      } });
      var getClassMetadata_1 = require_getClassMetadata();
      Object.defineProperty(exports, "getClassMetadata", { enumerable: true, get: function() {
        return getClassMetadata_1.getClassMetadata;
      } });
      var getClassMetadataFromMetadataReader_1 = require_getClassMetadataFromMetadataReader();
      Object.defineProperty(exports, "getClassMetadataFromMetadataReader", { enumerable: true, get: function() {
        return getClassMetadataFromMetadataReader_1.getClassMetadataFromMetadataReader;
      } });
      var ClassElementMetadataKind_1 = require_ClassElementMetadataKind();
      Object.defineProperty(exports, "ClassElementMetadataKind", { enumerable: true, get: function() {
        return ClassElementMetadataKind_1.ClassElementMetadataKind;
      } });
    }
  });

  // ../../node_modules/inversify/lib/cjs/bindings/binding_count.js
  var require_binding_count = __commonJS({
    "../../node_modules/inversify/lib/cjs/bindings/binding_count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingCount = void 0;
      var BindingCount;
      (function(BindingCount2) {
        BindingCount2[BindingCount2["MultipleBindingsAvailable"] = 2] = "MultipleBindingsAvailable";
        BindingCount2[BindingCount2["NoBindingsAvailable"] = 0] = "NoBindingsAvailable";
        BindingCount2[BindingCount2["OnlyOneBindingAvailable"] = 1] = "OnlyOneBindingAvailable";
      })(BindingCount || (exports.BindingCount = BindingCount = {}));
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/exceptions.js
  var require_exceptions = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/exceptions.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tryAndThrowErrorIfStackOverflow = void 0;
      exports.isStackOverflowException = isStackOverflowException;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function isStackOverflowException(error) {
        return error instanceof RangeError || error.message === ERROR_MSGS.STACK_OVERFLOW;
      }
      var tryAndThrowErrorIfStackOverflow = (fn, errorCallback) => {
        try {
          return fn();
        } catch (error) {
          if (isStackOverflowException(error)) {
            throw errorCallback();
          }
          throw error;
        }
      };
      exports.tryAndThrowErrorIfStackOverflow = tryAndThrowErrorIfStackOverflow;
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/serialization.js
  var require_serialization = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/serialization.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctionName = getFunctionName;
      exports.getServiceIdentifierAsString = getServiceIdentifierAsString;
      exports.listRegisteredBindingsForServiceIdentifier = listRegisteredBindingsForServiceIdentifier;
      exports.listMetadataForTarget = listMetadataForTarget;
      exports.circularDependencyToException = circularDependencyToException;
      exports.getSymbolDescription = getSymbolDescription;
      var ERROR_MSGS = __importStar(require_error_msgs());
      function getServiceIdentifierAsString(serviceIdentifier) {
        if (typeof serviceIdentifier === "function") {
          return serviceIdentifier.name;
        } else if (typeof serviceIdentifier === "symbol") {
          return serviceIdentifier.toString();
        } else {
          return serviceIdentifier;
        }
      }
      function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
        let registeredBindingsList = "";
        const registeredBindings = getBindings(container, serviceIdentifier);
        if (registeredBindings.length !== 0) {
          registeredBindingsList = "\nRegistered bindings:";
          registeredBindings.forEach((binding) => {
            let name = "Object";
            if (binding.implementationType !== null) {
              name = getFunctionName(binding.implementationType);
            }
            registeredBindingsList = `${registeredBindingsList}
 ${name}`;
            if (binding.constraint.metaData) {
              registeredBindingsList = `${registeredBindingsList} - ${binding.constraint.metaData}`;
            }
          });
        }
        return registeredBindingsList;
      }
      function alreadyDependencyChain(request, serviceIdentifier) {
        if (request.parentRequest === null) {
          return false;
        } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
          return true;
        } else {
          return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
        }
      }
      function dependencyChainToString(request) {
        function _createStringArr(req, result = []) {
          const serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
          result.push(serviceIdentifier);
          if (req.parentRequest !== null) {
            return _createStringArr(req.parentRequest, result);
          }
          return result;
        }
        const stringArr = _createStringArr(request);
        return stringArr.reverse().join(" --> ");
      }
      function circularDependencyToException(request) {
        request.childRequests.forEach((childRequest) => {
          if (alreadyDependencyChain(request, childRequest.serviceIdentifier)) {
            const services = dependencyChainToString(childRequest);
            throw new Error(`${ERROR_MSGS.CIRCULAR_DEPENDENCY} ${services}`);
          } else {
            circularDependencyToException(childRequest);
          }
        });
      }
      function listMetadataForTarget(serviceIdentifierString, target) {
        if (target.isTagged() || target.isNamed()) {
          let m3 = "";
          const namedTag = target.getNamedTag();
          const otherTags = target.getCustomTags();
          if (namedTag !== null) {
            m3 += stringifyMetadata(namedTag) + "\n";
          }
          if (otherTags !== null) {
            otherTags.forEach((tag) => {
              m3 += stringifyMetadata(tag) + "\n";
            });
          }
          return ` ${serviceIdentifierString}
 ${serviceIdentifierString} - ${m3}`;
        } else {
          return ` ${serviceIdentifierString}`;
        }
      }
      function getFunctionName(func) {
        if (func.name != null && func.name !== "") {
          return func.name;
        } else {
          const name = func.toString();
          const match = name.match(/^function\s*([^\s(]+)/);
          return match === null ? `Anonymous function: ${name}` : match[1];
        }
      }
      function getSymbolDescription(symbol) {
        return symbol.toString().slice(7, -1);
      }
      function stringifyMetadata(metadata) {
        return `{"key":"${metadata.key.toString()}","value":"${metadata.value.toString()}"}`;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/context.js
  var require_context = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/context.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Context = void 0;
      var id_1 = require_id();
      var Context = class {
        constructor(container) {
          __publicField(this, "id");
          __publicField(this, "container");
          __publicField(this, "plan");
          __publicField(this, "currentRequest");
          this.id = (0, id_1.id)();
          this.container = container;
        }
        addPlan(plan) {
          this.plan = plan;
        }
        setCurrentRequest(currentRequest) {
          this.currentRequest = currentRequest;
        }
      };
      exports.Context = Context;
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/metadata.js
  var require_metadata = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/metadata.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Metadata = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var Metadata = class {
        constructor(key, value) {
          __publicField(this, "key");
          __publicField(this, "value");
          this.key = key;
          this.value = value;
        }
        toString() {
          if (this.key === METADATA_KEY.NAMED_TAG) {
            return `named: ${String(this.value).toString()} `;
          } else {
            return `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
          }
        }
      };
      exports.Metadata = Metadata;
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/plan.js
  var require_plan = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/plan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Plan = void 0;
      var Plan = class {
        constructor(parentContext, rootRequest) {
          __publicField(this, "parentContext");
          __publicField(this, "rootRequest");
          this.parentContext = parentContext;
          this.rootRequest = rootRequest;
        }
      };
      exports.Plan = Plan;
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/get_base_type.js
  var require_get_base_type = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/get_base_type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBaseType = getBaseType;
      function getBaseType(type) {
        const prototype = Object.getPrototypeOf(type.prototype);
        const baseType = prototype == null ? void 0 : prototype.constructor;
        return baseType;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/reflection_utils.js
  var require_reflection_utils = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/reflection_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctionName = void 0;
      exports.getDependencies = getDependencies;
      exports.getBaseClassDependencyCount = getBaseClassDependencyCount;
      var core_1 = require_cjs3();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var get_base_type_1 = require_get_base_type();
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getFunctionName", { enumerable: true, get: function() {
        return serialization_1.getFunctionName;
      } });
      function getDependencies(metadataReader, func) {
        return (0, core_1.getTargets)(metadataReader)(func);
      }
      function getBaseClassDependencyCount(metadataReader, func) {
        const baseConstructor = (0, get_base_type_1.getBaseType)(func);
        if (baseConstructor === void 0 || baseConstructor === Object) {
          return 0;
        }
        const targets = (0, core_1.getTargets)(metadataReader)(baseConstructor);
        const metadata = targets.map((t3) => t3.metadata.filter((m3) => m3.key === METADATA_KEY.UNMANAGED_TAG));
        const unmanagedCount = [].concat.apply([], metadata).length;
        const dependencyCount = targets.length - unmanagedCount;
        if (dependencyCount > 0) {
          return dependencyCount;
        } else {
          return getBaseClassDependencyCount(metadataReader, baseConstructor);
        }
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/request.js
  var require_request = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/request.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Request = void 0;
      var id_1 = require_id();
      var Request = class _Request {
        constructor(serviceIdentifier, parentContext, parentRequest, bindings, target) {
          __publicField(this, "id");
          __publicField(this, "serviceIdentifier");
          __publicField(this, "parentContext");
          __publicField(this, "parentRequest");
          __publicField(this, "bindings");
          __publicField(this, "childRequests");
          __publicField(this, "target");
          __publicField(this, "requestScope");
          this.id = (0, id_1.id)();
          this.serviceIdentifier = serviceIdentifier;
          this.parentContext = parentContext;
          this.parentRequest = parentRequest;
          this.target = target;
          this.childRequests = [];
          this.bindings = Array.isArray(bindings) ? bindings : [bindings];
          this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
        }
        addChildRequest(serviceIdentifier, bindings, target) {
          const child = new _Request(serviceIdentifier, this.parentContext, this, bindings, target);
          this.childRequests.push(child);
          return child;
        }
      };
      exports.Request = Request;
    }
  });

  // ../../node_modules/inversify/lib/cjs/planning/planner.js
  var require_planner = __commonJS({
    "../../node_modules/inversify/lib/cjs/planning/planner.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBindingDictionary = getBindingDictionary;
      exports.plan = plan;
      exports.createMockRequest = createMockRequest;
      var core_1 = require_cjs3();
      var binding_count_1 = require_binding_count();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var exceptions_1 = require_exceptions();
      var serialization_1 = require_serialization();
      var context_1 = require_context();
      var metadata_1 = require_metadata();
      var plan_1 = require_plan();
      var reflection_utils_1 = require_reflection_utils();
      var request_1 = require_request();
      function getBindingDictionary(cntnr) {
        return cntnr._bindingDictionary;
      }
      function _createTarget(targetType, serviceIdentifier, metadata) {
        const metadataList = _getTargetMetadata(serviceIdentifier, metadata);
        const classElementMetadata = (0, core_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        if (classElementMetadata.kind === core_1.ClassElementMetadataKind.unmanaged) {
          throw new Error("Unexpected metadata when creating target");
        }
        const target = new core_1.LegacyTargetImpl("", classElementMetadata, targetType);
        return target;
      }
      function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
        let bindings = getBindings(context.container, target.serviceIdentifier);
        let activeBindings = [];
        if (bindings.length === binding_count_1.BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable === true && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
          context.container.bind(target.serviceIdentifier).toSelf();
          bindings = getBindings(context.container, target.serviceIdentifier);
        }
        if (!avoidConstraints) {
          activeBindings = bindings.filter((binding) => {
            const request = new request_1.Request(binding.serviceIdentifier, context, parentRequest, binding, target);
            return binding.constraint(request);
          });
        } else {
          activeBindings = bindings;
        }
        _validateActiveBindingCount(target.serviceIdentifier, activeBindings, parentRequest, target, context.container);
        return activeBindings;
      }
      function _getTargetMetadata(serviceIdentifier, metadata) {
        const metadataKey = metadata.isMultiInject ? METADATA_KEY.MULTI_INJECT_TAG : METADATA_KEY.INJECT_TAG;
        const metadataList = [
          new metadata_1.Metadata(metadataKey, serviceIdentifier)
        ];
        if (metadata.customTag !== void 0) {
          metadataList.push(new metadata_1.Metadata(metadata.customTag.key, metadata.customTag.value));
        }
        if (metadata.isOptional === true) {
          metadataList.push(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
        }
        return metadataList;
      }
      function _validateActiveBindingCount(serviceIdentifier, bindings, parentRequest, target, container) {
        switch (bindings.length) {
          case binding_count_1.BindingCount.NoBindingsAvailable:
            if (target.isOptional()) {
              return bindings;
            } else {
              const serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              let msg = ERROR_MSGS.NOT_REGISTERED;
              msg += (0, serialization_1.listMetadataForTarget)(serviceIdentifierString, target);
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              if (parentRequest !== null) {
                msg += `
${ERROR_MSGS.TRYING_TO_RESOLVE_BINDINGS((0, serialization_1.getServiceIdentifierAsString)(parentRequest.serviceIdentifier))}`;
              }
              throw new Error(msg);
            }
          case binding_count_1.BindingCount.OnlyOneBindingAvailable:
            return bindings;
          case binding_count_1.BindingCount.MultipleBindingsAvailable:
          default:
            if (!target.isArray()) {
              const serviceIdentifierString = (0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier);
              let msg = `${ERROR_MSGS.AMBIGUOUS_MATCH} ${serviceIdentifierString}`;
              msg += (0, serialization_1.listRegisteredBindingsForServiceIdentifier)(container, serviceIdentifierString, getBindings);
              throw new Error(msg);
            } else {
              return bindings;
            }
        }
      }
      function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
        let activeBindings;
        let childRequest;
        if (parentRequest === null) {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
          childRequest = new request_1.Request(serviceIdentifier, context, null, activeBindings, target);
          const thePlan = new plan_1.Plan(context, childRequest);
          context.addPlan(thePlan);
        } else {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
          childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
        }
        activeBindings.forEach((binding) => {
          let subChildRequest = null;
          if (target.isArray()) {
            subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
          } else {
            if (binding.cache !== null) {
              return;
            }
            subChildRequest = childRequest;
          }
          if (binding.type === literal_types_1.BindingTypeEnum.Instance && binding.implementationType !== null) {
            const dependencies = (0, reflection_utils_1.getDependencies)(metadataReader, binding.implementationType);
            if (context.container.options.skipBaseClassChecks !== true) {
              const baseClassDependencyCount = (0, reflection_utils_1.getBaseClassDependencyCount)(metadataReader, binding.implementationType);
              if (dependencies.length < baseClassDependencyCount) {
                const error = ERROR_MSGS.ARGUMENTS_LENGTH_MISMATCH((0, reflection_utils_1.getFunctionName)(binding.implementationType));
                throw new Error(error);
              }
            }
            dependencies.forEach((dependency) => {
              _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
            });
          }
        });
      }
      function getBindings(container, serviceIdentifier) {
        let bindings = [];
        const bindingDictionary = getBindingDictionary(container);
        if (bindingDictionary.hasKey(serviceIdentifier)) {
          bindings = bindingDictionary.get(serviceIdentifier);
        } else if (container.parent !== null) {
          bindings = getBindings(container.parent, serviceIdentifier);
        }
        return bindings;
      }
      function plan(metadataReader, container, targetType, serviceIdentifier, metadata, avoidConstraints = false) {
        const context = new context_1.Context(container);
        const target = _createTarget(targetType, serviceIdentifier, metadata);
        try {
          _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
          return context;
        } catch (error) {
          if ((0, exceptions_1.isStackOverflowException)(error)) {
            (0, serialization_1.circularDependencyToException)(context.plan.rootRequest);
          }
          throw error;
        }
      }
      function createMockRequest(container, serviceIdentifier, metadata) {
        const metadataList = _getTargetMetadata(serviceIdentifier, metadata);
        const classElementMetadata = (0, core_1.getClassElementMetadataFromLegacyMetadata)(metadataList);
        if (classElementMetadata.kind === core_1.ClassElementMetadataKind.unmanaged) {
          throw new Error("Unexpected metadata when creating target");
        }
        const target = new core_1.LegacyTargetImpl("", classElementMetadata, "Variable");
        const context = new context_1.Context(container);
        const request = new request_1.Request(serviceIdentifier, context, null, [], target);
        return request;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/async.js
  var require_async = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPromise = isPromise;
      exports.isPromiseOrContainsPromise = isPromiseOrContainsPromise;
      function isPromise(object) {
        const isObjectOrFunction = typeof object === "object" && object !== null || typeof object === "function";
        return isObjectOrFunction && typeof object.then === "function";
      }
      function isPromiseOrContainsPromise(object) {
        if (isPromise(object)) {
          return true;
        }
        return Array.isArray(object) && object.some(isPromise);
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/scope/scope.js
  var require_scope = __commonJS({
    "../../node_modules/inversify/lib/cjs/scope/scope.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.saveToScope = exports.tryGetFromScope = void 0;
      var literal_types_1 = require_literal_types();
      var async_1 = require_async();
      var tryGetFromScope = (requestScope, binding) => {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton && binding.activated) {
          return binding.cache;
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request && requestScope.has(binding.id)) {
          return requestScope.get(binding.id);
        }
        return null;
      };
      exports.tryGetFromScope = tryGetFromScope;
      var saveToScope = (requestScope, binding, result) => {
        if (binding.scope === literal_types_1.BindingScopeEnum.Singleton) {
          _saveToSingletonScope(binding, result);
        }
        if (binding.scope === literal_types_1.BindingScopeEnum.Request) {
          _saveToRequestScope(requestScope, binding, result);
        }
      };
      exports.saveToScope = saveToScope;
      var _saveToRequestScope = (requestScope, binding, result) => {
        if (!requestScope.has(binding.id)) {
          requestScope.set(binding.id, result);
        }
      };
      var _saveToSingletonScope = (binding, result) => {
        binding.cache = result;
        binding.activated = true;
        if ((0, async_1.isPromise)(result)) {
          void _saveAsyncResultToSingletonScope(binding, result);
        }
      };
      var _saveAsyncResultToSingletonScope = async (binding, asyncResult) => {
        try {
          const result = await asyncResult;
          binding.cache = result;
        } catch (ex) {
          binding.cache = null;
          binding.activated = false;
          throw ex;
        }
      };
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/factory_type.js
  var require_factory_type = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/factory_type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FactoryType = void 0;
      var FactoryType;
      (function(FactoryType2) {
        FactoryType2["DynamicValue"] = "toDynamicValue";
        FactoryType2["Factory"] = "toFactory";
        FactoryType2["Provider"] = "toProvider";
      })(FactoryType || (exports.FactoryType = FactoryType = {}));
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/binding_utils.js
  var require_binding_utils = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/binding_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFactoryDetails = exports.ensureFullyBound = exports.multiBindToService = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var serialization_1 = require_serialization();
      var factory_type_1 = require_factory_type();
      var multiBindToService = (container) => (service) => (...types) => {
        types.forEach((t3) => {
          container.bind(t3).toService(service);
        });
      };
      exports.multiBindToService = multiBindToService;
      var ensureFullyBound = (binding) => {
        let boundValue = null;
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            boundValue = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
          case literal_types_1.BindingTypeEnum.Instance:
            boundValue = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.DynamicValue:
            boundValue = binding.dynamicValue;
            break;
          case literal_types_1.BindingTypeEnum.Provider:
            boundValue = binding.provider;
            break;
          case literal_types_1.BindingTypeEnum.Factory:
            boundValue = binding.factory;
            break;
        }
        if (boundValue === null) {
          const serviceIdentifierAsString = (0, serialization_1.getServiceIdentifierAsString)(binding.serviceIdentifier);
          throw new Error(`${ERROR_MSGS.INVALID_BINDING_TYPE} ${serviceIdentifierAsString}`);
        }
      };
      exports.ensureFullyBound = ensureFullyBound;
      var getFactoryDetails = (binding) => {
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.Factory:
            return { factory: binding.factory, factoryType: factory_type_1.FactoryType.Factory };
          case literal_types_1.BindingTypeEnum.Provider:
            return { factory: binding.provider, factoryType: factory_type_1.FactoryType.Provider };
          case literal_types_1.BindingTypeEnum.DynamicValue:
            return {
              factory: binding.dynamicValue,
              factoryType: factory_type_1.FactoryType.DynamicValue
            };
          default:
            throw new Error(`Unexpected factory type ${binding.type}`);
        }
      };
      exports.getFactoryDetails = getFactoryDetails;
    }
  });

  // ../../node_modules/inversify/lib/cjs/resolution/instantiation.js
  var require_instantiation = __commonJS({
    "../../node_modules/inversify/lib/cjs/resolution/instantiation.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveInstance = resolveInstance;
      var error_msgs_1 = require_error_msgs();
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var async_1 = require_async();
      function _resolveRequests(childRequests, resolveRequest) {
        return childRequests.reduce((resolvedRequests, childRequest) => {
          const injection = resolveRequest(childRequest);
          const targetType = childRequest.target.type;
          if (targetType === literal_types_1.TargetTypeEnum.ConstructorArgument) {
            resolvedRequests.constructorInjections.push(injection);
          } else {
            resolvedRequests.propertyRequests.push(childRequest);
            resolvedRequests.propertyInjections.push(injection);
          }
          if (!resolvedRequests.isAsync) {
            resolvedRequests.isAsync = (0, async_1.isPromiseOrContainsPromise)(injection);
          }
          return resolvedRequests;
        }, {
          constructorInjections: [],
          isAsync: false,
          propertyInjections: [],
          propertyRequests: []
        });
      }
      function _createInstance(constr, childRequests, resolveRequest) {
        let result;
        if (childRequests.length > 0) {
          const resolved = _resolveRequests(childRequests, resolveRequest);
          const createInstanceWithInjectionsArg = __spreadProps(__spreadValues({}, resolved), {
            constr
          });
          if (resolved.isAsync) {
            result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
          } else {
            result = createInstanceWithInjections(createInstanceWithInjectionsArg);
          }
        } else {
          result = new constr();
        }
        return result;
      }
      function createInstanceWithInjections(args) {
        const instance = new args.constr(...args.constructorInjections);
        args.propertyRequests.forEach((r3, index) => {
          const property = r3.target.identifier;
          const injection = args.propertyInjections[index];
          if (!r3.target.isOptional() || injection !== void 0) {
            instance[property] = injection;
          }
        });
        return instance;
      }
      async function createInstanceWithInjectionsAsync(args) {
        const constructorInjections = await possiblyWaitInjections(args.constructorInjections);
        const propertyInjections = await possiblyWaitInjections(args.propertyInjections);
        return createInstanceWithInjections(__spreadProps(__spreadValues({}, args), {
          constructorInjections,
          propertyInjections
        }));
      }
      async function possiblyWaitInjections(possiblePromiseinjections) {
        const injections = [];
        for (const injection of possiblePromiseinjections) {
          if (Array.isArray(injection)) {
            injections.push(Promise.all(injection));
          } else {
            injections.push(injection);
          }
        }
        return Promise.all(injections);
      }
      function _getInstanceAfterPostConstruct(constr, result) {
        const postConstructResult = _postConstruct(constr, result);
        if ((0, async_1.isPromise)(postConstructResult)) {
          return postConstructResult.then(() => result);
        } else {
          return result;
        }
      }
      function _postConstruct(constr, instance) {
        var _a4;
        if (Reflect.hasMetadata(METADATA_KEY.POST_CONSTRUCT, constr)) {
          const data = Reflect.getMetadata(METADATA_KEY.POST_CONSTRUCT, constr);
          try {
            return (_a4 = instance[data.value]) == null ? void 0 : _a4.call(instance);
          } catch (e2) {
            if (e2 instanceof Error) {
              throw new Error((0, error_msgs_1.POST_CONSTRUCT_ERROR)(constr.name, e2.message));
            }
          }
        }
      }
      function _validateInstanceResolution(binding, constr) {
        if (binding.scope !== literal_types_1.BindingScopeEnum.Singleton) {
          _throwIfHandlingDeactivation(binding, constr);
        }
      }
      function _throwIfHandlingDeactivation(binding, constr) {
        const scopeErrorMessage = `Class cannot be instantiated in ${binding.scope === literal_types_1.BindingScopeEnum.Request ? "request" : "transient"} scope.`;
        if (typeof binding.onDeactivation === "function") {
          throw new Error((0, error_msgs_1.ON_DEACTIVATION_ERROR)(constr.name, scopeErrorMessage));
        }
        if (Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constr)) {
          throw new Error((0, error_msgs_1.PRE_DESTROY_ERROR)(constr.name, scopeErrorMessage));
        }
      }
      function resolveInstance(binding, constr, childRequests, resolveRequest) {
        _validateInstanceResolution(binding, constr);
        const result = _createInstance(constr, childRequests, resolveRequest);
        if ((0, async_1.isPromise)(result)) {
          return result.then((resolvedResult) => _getInstanceAfterPostConstruct(constr, resolvedResult));
        } else {
          return _getInstanceAfterPostConstruct(constr, result);
        }
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/resolution/resolver.js
  var require_resolver = __commonJS({
    "../../node_modules/inversify/lib/cjs/resolution/resolver.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolve = resolve;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var planner_1 = require_planner();
      var scope_1 = require_scope();
      var async_1 = require_async();
      var binding_utils_1 = require_binding_utils();
      var exceptions_1 = require_exceptions();
      var instantiation_1 = require_instantiation();
      var _resolveRequest = (requestScope) => (request) => {
        request.parentContext.setCurrentRequest(request);
        const bindings = request.bindings;
        const childRequests = request.childRequests;
        const targetIsAnArray = request.target && request.target.isArray();
        const targetParentIsNotAnArray = !request.parentRequest || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions
        !request.parentRequest.target || // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions
        !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
          return childRequests.map((childRequest) => {
            const resolveRequest = _resolveRequest(requestScope);
            return resolveRequest(childRequest);
          });
        } else {
          if (request.target.isOptional() && bindings.length === 0) {
            return void 0;
          }
          const binding = bindings[0];
          return _resolveBinding(requestScope, request, binding);
        }
      };
      var _resolveFactoryFromBinding = (binding, context) => {
        const factoryDetails = (0, binding_utils_1.getFactoryDetails)(binding);
        return (0, exceptions_1.tryAndThrowErrorIfStackOverflow)(() => factoryDetails.factory.bind(binding)(context), () => new Error(ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString())));
      };
      var _getResolvedFromBinding = (requestScope, request, binding) => {
        let result;
        const childRequests = request.childRequests;
        (0, binding_utils_1.ensureFullyBound)(binding);
        switch (binding.type) {
          case literal_types_1.BindingTypeEnum.ConstantValue:
          case literal_types_1.BindingTypeEnum.Function:
            result = binding.cache;
            break;
          case literal_types_1.BindingTypeEnum.Constructor:
            result = binding.implementationType;
            break;
          case literal_types_1.BindingTypeEnum.Instance:
            result = (0, instantiation_1.resolveInstance)(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
            break;
          default:
            result = _resolveFactoryFromBinding(binding, request.parentContext);
        }
        return result;
      };
      var _resolveInScope = (requestScope, binding, resolveFromBinding) => {
        let result = (0, scope_1.tryGetFromScope)(requestScope, binding);
        if (result !== null) {
          return result;
        }
        result = resolveFromBinding();
        (0, scope_1.saveToScope)(requestScope, binding, result);
        return result;
      };
      var _resolveBinding = (requestScope, request, binding) => {
        return _resolveInScope(requestScope, binding, () => {
          let result = _getResolvedFromBinding(requestScope, request, binding);
          if ((0, async_1.isPromise)(result)) {
            result = result.then((resolved) => _onActivation(request, binding, resolved));
          } else {
            result = _onActivation(request, binding, result);
          }
          return result;
        });
      };
      function _onActivation(request, binding, resolved) {
        let result = _bindingActivation(request.parentContext, binding, resolved);
        const containersIterator = _getContainersIterator(request.parentContext.container);
        let container;
        let containersIteratorResult = containersIterator.next();
        do {
          container = containersIteratorResult.value;
          const context = request.parentContext;
          const serviceIdentifier = request.serviceIdentifier;
          const activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
          if ((0, async_1.isPromise)(result)) {
            result = _activateContainerAsync(activationsIterator, context, result);
          } else {
            result = _activateContainer(activationsIterator, context, result);
          }
          containersIteratorResult = containersIterator.next();
        } while (containersIteratorResult.done !== true && !(0, planner_1.getBindingDictionary)(container).hasKey(request.serviceIdentifier));
        return result;
      }
      var _bindingActivation = (context, binding, previousResult) => {
        let result;
        if (typeof binding.onActivation === "function") {
          result = binding.onActivation(context, previousResult);
        } else {
          result = previousResult;
        }
        return result;
      };
      var _activateContainer = (activationsIterator, context, result) => {
        let activation = activationsIterator.next();
        while (activation.done !== true) {
          result = activation.value(context, result);
          if ((0, async_1.isPromise)(result)) {
            return _activateContainerAsync(activationsIterator, context, result);
          }
          activation = activationsIterator.next();
        }
        return result;
      };
      var _activateContainerAsync = async (activationsIterator, context, resultPromise) => {
        let result = await resultPromise;
        let activation = activationsIterator.next();
        while (activation.done !== true) {
          result = await activation.value(context, result);
          activation = activationsIterator.next();
        }
        return result;
      };
      var _getContainerActivationsForService = (container, serviceIdentifier) => {
        const activations = container._activations;
        return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
      };
      var _getContainersIterator = (container) => {
        const containersStack = [container];
        let parent = container.parent;
        while (parent !== null) {
          containersStack.push(parent);
          parent = parent.parent;
        }
        const getNextContainer = () => {
          const nextContainer = containersStack.pop();
          if (nextContainer !== void 0) {
            return { done: false, value: nextContainer };
          } else {
            return { done: true, value: void 0 };
          }
        };
        const containersIterator = {
          next: getNextContainer
        };
        return containersIterator;
      };
      function resolve(context) {
        const resolveRequestFunction = _resolveRequest(context.plan.rootRequest.requestScope);
        return resolveRequestFunction(context.plan.rootRequest);
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/constraint_helpers.js
  var require_constraint_helpers = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/constraint_helpers.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var traverseAncerstors = (request, constraint) => {
        const parent = request.parentRequest;
        if (parent !== null) {
          return constraint(parent) ? true : traverseAncerstors(parent, constraint);
        } else {
          return false;
        }
      };
      exports.traverseAncerstors = traverseAncerstors;
      var taggedConstraint = (key) => (value) => {
        const constraint = (request) => request !== null && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        request.target !== null && request.target.matchesTag(key)(value);
        constraint.metaData = new metadata_1.Metadata(key, value);
        return constraint;
      };
      exports.taggedConstraint = taggedConstraint;
      var namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);
      exports.namedConstraint = namedConstraint;
      var typeConstraint = (type) => (request) => {
        let binding = null;
        if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
            return binding.serviceIdentifier === type;
          } else {
            const constructor = request.bindings[0].implementationType;
            return type === constructor;
          }
        }
        return false;
      };
      exports.typeConstraint = typeConstraint;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_when_syntax.js
  var require_binding_when_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_when_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var constraint_helpers_1 = require_constraint_helpers();
      var BindingWhenSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        when(constraint) {
          this._binding.constraint = constraint;
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetNamed(name) {
          this._binding.constraint = (0, constraint_helpers_1.namedConstraint)(name);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetIsDefault() {
          this._binding.constraint = (request) => {
            if (request === null) {
              return false;
            }
            const targetIsDefault = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              request.target !== null && !request.target.isNamed() && !request.target.isTagged()
            );
            return targetIsDefault;
          };
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenTargetTagged(tag, value) {
          this._binding.constraint = (0, constraint_helpers_1.taggedConstraint)(tag)(value);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenInjectedInto(parent) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.typeConstraint)(parent)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenParentNamed(name) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.namedConstraint)(name)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenParentTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.taggedConstraint)(tag)(value)(request.parentRequest);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorIs(ancestor) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorIs(ancestor) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.typeConstraint)(ancestor));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorNamed(name) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorNamed(name) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.namedConstraint)(name));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorTagged(tag, value) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, (0, constraint_helpers_1.taggedConstraint)(tag)(value));
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenAnyAncestorMatches(constraint) {
          this._binding.constraint = (request) => request !== null && (0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        whenNoAncestorMatches(constraint) {
          this._binding.constraint = (request) => request !== null && !(0, constraint_helpers_1.traverseAncerstors)(request, constraint);
          return new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
      };
      exports.BindingWhenSyntax = BindingWhenSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_on_syntax.js
  var require_binding_on_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingOnSyntax = void 0;
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        onActivation(handler) {
          this._binding.onActivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        }
        onDeactivation(handler) {
          this._binding.onDeactivation = handler;
          return new binding_when_syntax_1.BindingWhenSyntax(this._binding);
        }
      };
      exports.BindingOnSyntax = BindingOnSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_when_on_syntax.js
  var require_binding_when_on_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingWhenOnSyntax = void 0;
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingWhenOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
        }
        when(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        }
        whenTargetNamed(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        }
        whenInjectedInto(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        }
        whenParentNamed(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        }
        whenParentTagged(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        }
        whenAnyAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        }
        whenNoAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        }
        whenAnyAncestorNamed(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        }
        whenAnyAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        }
        whenNoAncestorNamed(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        }
        whenNoAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        }
        whenAnyAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        }
        whenNoAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        }
        onActivation(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        }
        onDeactivation(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        }
      };
      exports.BindingWhenOnSyntax = BindingWhenOnSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_in_syntax.js
  var require_binding_in_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_in_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInSyntax = void 0;
      var literal_types_1 = require_literal_types();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingInSyntax = class {
        constructor(binding) {
          __publicField(this, "_binding");
          this._binding = binding;
        }
        inRequestScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Request;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        inSingletonScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        inTransientScope() {
          this._binding.scope = literal_types_1.BindingScopeEnum.Transient;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
      };
      exports.BindingInSyntax = BindingInSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_in_when_on_syntax.js
  var require_binding_in_when_on_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_in_when_on_syntax.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingInWhenOnSyntax = void 0;
      var binding_in_syntax_1 = require_binding_in_syntax();
      var binding_on_syntax_1 = require_binding_on_syntax();
      var binding_when_syntax_1 = require_binding_when_syntax();
      var BindingInWhenOnSyntax = class {
        constructor(binding) {
          __publicField(this, "_bindingInSyntax");
          __publicField(this, "_bindingWhenSyntax");
          __publicField(this, "_bindingOnSyntax");
          __publicField(this, "_binding");
          this._binding = binding;
          this._bindingWhenSyntax = new binding_when_syntax_1.BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new binding_on_syntax_1.BindingOnSyntax(this._binding);
          this._bindingInSyntax = new binding_in_syntax_1.BindingInSyntax(binding);
        }
        inRequestScope() {
          return this._bindingInSyntax.inRequestScope();
        }
        inSingletonScope() {
          return this._bindingInSyntax.inSingletonScope();
        }
        inTransientScope() {
          return this._bindingInSyntax.inTransientScope();
        }
        when(constraint) {
          return this._bindingWhenSyntax.when(constraint);
        }
        whenTargetNamed(name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
        }
        whenTargetIsDefault() {
          return this._bindingWhenSyntax.whenTargetIsDefault();
        }
        whenTargetTagged(tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
        }
        whenInjectedInto(parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
        }
        whenParentNamed(name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
        }
        whenParentTagged(tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
        }
        whenAnyAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
        }
        whenNoAncestorIs(ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
        }
        whenAnyAncestorNamed(name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
        }
        whenAnyAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
        }
        whenNoAncestorNamed(name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
        }
        whenNoAncestorTagged(tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
        }
        whenAnyAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
        }
        whenNoAncestorMatches(constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
        }
        onActivation(handler) {
          return this._bindingOnSyntax.onActivation(handler);
        }
        onDeactivation(handler) {
          return this._bindingOnSyntax.onDeactivation(handler);
        }
      };
      exports.BindingInWhenOnSyntax = BindingInWhenOnSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/syntax/binding_to_syntax.js
  var require_binding_to_syntax = __commonJS({
    "../../node_modules/inversify/lib/cjs/syntax/binding_to_syntax.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BindingToSyntax = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var binding_in_when_on_syntax_1 = require_binding_in_when_on_syntax();
      var binding_when_on_syntax_1 = require_binding_when_on_syntax();
      var BindingToSyntax = class {
        constructor(binding) {
          // TODO: Implement an internal type `_BindingToSyntax<T>` wherein this member
          // can be public. Let `BindingToSyntax<T>` be the presentational type that
          // depends on it, and does not expose this member as public.
          __publicField(this, "_binding");
          this._binding = binding;
        }
        to(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Instance;
          this._binding.implementationType = constructor;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        }
        toSelf() {
          if (typeof this._binding.serviceIdentifier !== "function") {
            throw new Error(ERROR_MSGS.INVALID_TO_SELF_VALUE);
          }
          const self2 = this._binding.serviceIdentifier;
          return this.to(self2);
        }
        toConstantValue(value) {
          this._binding.type = literal_types_1.BindingTypeEnum.ConstantValue;
          this._binding.cache = value;
          this._binding.dynamicValue = null;
          this._binding.implementationType = null;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toDynamicValue(func) {
          this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
          this._binding.cache = null;
          this._binding.dynamicValue = func;
          this._binding.implementationType = null;
          return new binding_in_when_on_syntax_1.BindingInWhenOnSyntax(this._binding);
        }
        toConstructor(constructor) {
          this._binding.type = literal_types_1.BindingTypeEnum.Constructor;
          this._binding.implementationType = constructor;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toFactory(factory) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = factory;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toFunction(func) {
          if (typeof func !== "function") {
            throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);
          }
          const bindingWhenOnSyntax = this.toConstantValue(func);
          this._binding.type = literal_types_1.BindingTypeEnum.Function;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return bindingWhenOnSyntax;
        }
        toAutoFactory(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = (context) => {
            const autofactory = () => context.container.get(serviceIdentifier);
            return autofactory;
          };
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toAutoNamedFactory(serviceIdentifier) {
          this._binding.type = literal_types_1.BindingTypeEnum.Factory;
          this._binding.factory = (context) => {
            return (named) => context.container.getNamed(serviceIdentifier, named);
          };
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toProvider(provider) {
          this._binding.type = literal_types_1.BindingTypeEnum.Provider;
          this._binding.provider = provider;
          this._binding.scope = literal_types_1.BindingScopeEnum.Singleton;
          return new binding_when_on_syntax_1.BindingWhenOnSyntax(this._binding);
        }
        toService(service) {
          this._binding.type = literal_types_1.BindingTypeEnum.DynamicValue;
          Object.defineProperty(this._binding, "cache", {
            configurable: true,
            enumerable: true,
            get() {
              return null;
            },
            set(_value) {
            }
          });
          this._binding.dynamicValue = (context) => {
            try {
              return context.container.get(service);
            } catch (_error) {
              return context.container.getAsync(service);
            }
          };
          this._binding.implementationType = null;
        }
      };
      exports.BindingToSyntax = BindingToSyntax;
    }
  });

  // ../../node_modules/inversify/lib/cjs/container/container_snapshot.js
  var require_container_snapshot = __commonJS({
    "../../node_modules/inversify/lib/cjs/container/container_snapshot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContainerSnapshot = void 0;
      var ContainerSnapshot = class _ContainerSnapshot {
        constructor() {
          __publicField(this, "bindings");
          __publicField(this, "activations");
          __publicField(this, "deactivations");
          __publicField(this, "middleware");
          __publicField(this, "moduleActivationStore");
        }
        static of(bindings, middleware, activations, deactivations, moduleActivationStore) {
          const snapshot = new _ContainerSnapshot();
          snapshot.bindings = bindings;
          snapshot.middleware = middleware;
          snapshot.deactivations = deactivations;
          snapshot.activations = activations;
          snapshot.moduleActivationStore = moduleActivationStore;
          return snapshot;
        }
      };
      exports.ContainerSnapshot = ContainerSnapshot;
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/clonable.js
  var require_clonable = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/clonable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isClonable = isClonable;
      function isClonable(obj) {
        return typeof obj === "object" && obj !== null && "clone" in obj && typeof obj.clone === "function";
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/container/lookup.js
  var require_lookup = __commonJS({
    "../../node_modules/inversify/lib/cjs/container/lookup.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lookup = void 0;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var clonable_1 = require_clonable();
      var Lookup = class _Lookup {
        constructor() {
          // dictionary used store multiple values for each key <key>
          __publicField(this, "_map");
          this._map = /* @__PURE__ */ new Map();
        }
        getMap() {
          return this._map;
        }
        // adds a new entry to _map
        add(serviceIdentifier, value) {
          this._checkNonNulish(serviceIdentifier);
          if (value === null || value === void 0) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
          const entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            entry.push(value);
          } else {
            this._map.set(serviceIdentifier, [value]);
          }
        }
        // gets the value of a entry by its key (serviceIdentifier)
        get(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          const entry = this._map.get(serviceIdentifier);
          if (entry !== void 0) {
            return entry;
          } else {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        }
        // removes a entry from _map by its key (serviceIdentifier)
        remove(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          if (!this._map.delete(serviceIdentifier)) {
            throw new Error(ERROR_MSGS.KEY_NOT_FOUND);
          }
        }
        removeIntersection(lookup) {
          this.traverse((serviceIdentifier, value) => {
            const lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
            if (lookupActivations !== void 0) {
              const filteredValues = value.filter((lookupValue) => !lookupActivations.some((moduleActivation) => lookupValue === moduleActivation));
              this._setValue(serviceIdentifier, filteredValues);
            }
          });
        }
        removeByCondition(condition) {
          const removals = [];
          this._map.forEach((entries, key) => {
            const updatedEntries = [];
            for (const entry of entries) {
              const remove = condition(entry);
              if (remove) {
                removals.push(entry);
              } else {
                updatedEntries.push(entry);
              }
            }
            this._setValue(key, updatedEntries);
          });
          return removals;
        }
        // returns true if _map contains a key (serviceIdentifier)
        hasKey(serviceIdentifier) {
          this._checkNonNulish(serviceIdentifier);
          return this._map.has(serviceIdentifier);
        }
        // returns a new Lookup instance; note: this is not a deep clone, only Lookup related data structure (dictionary) is
        // cloned, content remains the same
        clone() {
          const copy = new _Lookup();
          this._map.forEach((value, key) => {
            value.forEach((b3) => {
              copy.add(key, (0, clonable_1.isClonable)(b3) ? b3.clone() : b3);
            });
          });
          return copy;
        }
        traverse(func) {
          this._map.forEach((value, key) => {
            func(key, value);
          });
        }
        _checkNonNulish(value) {
          if (value == null) {
            throw new Error(ERROR_MSGS.NULL_ARGUMENT);
          }
        }
        _setValue(serviceIdentifier, value) {
          if (value.length > 0) {
            this._map.set(serviceIdentifier, value);
          } else {
            this._map.delete(serviceIdentifier);
          }
        }
      };
      exports.Lookup = Lookup;
    }
  });

  // ../../node_modules/inversify/lib/cjs/container/module_activation_store.js
  var require_module_activation_store = __commonJS({
    "../../node_modules/inversify/lib/cjs/container/module_activation_store.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModuleActivationStore = void 0;
      var lookup_1 = require_lookup();
      var ModuleActivationStore = class _ModuleActivationStore {
        constructor() {
          __publicField(this, "_map", /* @__PURE__ */ new Map());
        }
        remove(moduleId) {
          const handlers = this._map.get(moduleId);
          if (handlers === void 0) {
            return this._getEmptyHandlersStore();
          }
          this._map.delete(moduleId);
          return handlers;
        }
        addDeactivation(moduleId, serviceIdentifier, onDeactivation) {
          this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
        }
        addActivation(moduleId, serviceIdentifier, onActivation) {
          this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
        }
        clone() {
          const clone = new _ModuleActivationStore();
          this._map.forEach((handlersStore, moduleId) => {
            clone._map.set(moduleId, {
              onActivations: handlersStore.onActivations.clone(),
              onDeactivations: handlersStore.onDeactivations.clone()
            });
          });
          return clone;
        }
        _getModuleActivationHandlers(moduleId) {
          let moduleActivationHandlers = this._map.get(moduleId);
          if (moduleActivationHandlers === void 0) {
            moduleActivationHandlers = this._getEmptyHandlersStore();
            this._map.set(moduleId, moduleActivationHandlers);
          }
          return moduleActivationHandlers;
        }
        _getEmptyHandlersStore() {
          const handlersStore = {
            onActivations: new lookup_1.Lookup(),
            onDeactivations: new lookup_1.Lookup()
          };
          return handlersStore;
        }
      };
      exports.ModuleActivationStore = ModuleActivationStore;
    }
  });

  // ../../node_modules/inversify/lib/cjs/container/container.js
  var require_container = __commonJS({
    "../../node_modules/inversify/lib/cjs/container/container.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Container = void 0;
      var binding_1 = require_binding();
      var ERROR_MSGS = __importStar(require_error_msgs());
      var literal_types_1 = require_literal_types();
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_reader_1 = require_metadata_reader();
      var planner_1 = require_planner();
      var resolver_1 = require_resolver();
      var binding_to_syntax_1 = require_binding_to_syntax();
      var async_1 = require_async();
      var id_1 = require_id();
      var serialization_1 = require_serialization();
      var container_snapshot_1 = require_container_snapshot();
      var lookup_1 = require_lookup();
      var module_activation_store_1 = require_module_activation_store();
      var Container = class _Container {
        constructor(containerOptions) {
          __publicField(this, "id");
          __publicField(this, "parent");
          __publicField(this, "options");
          __publicField(this, "_middleware");
          __publicField(this, "_bindingDictionary");
          __publicField(this, "_activations");
          __publicField(this, "_deactivations");
          __publicField(this, "_snapshots");
          __publicField(this, "_metadataReader");
          __publicField(this, "_moduleActivationStore");
          const options = containerOptions || {};
          if (typeof options !== "object") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
          }
          if (options.defaultScope === void 0) {
            options.defaultScope = literal_types_1.BindingScopeEnum.Transient;
          } else if (options.defaultScope !== literal_types_1.BindingScopeEnum.Singleton && options.defaultScope !== literal_types_1.BindingScopeEnum.Transient && options.defaultScope !== literal_types_1.BindingScopeEnum.Request) {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
          }
          if (options.autoBindInjectable === void 0) {
            options.autoBindInjectable = false;
          } else if (typeof options.autoBindInjectable !== "boolean") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
          }
          if (options.skipBaseClassChecks === void 0) {
            options.skipBaseClassChecks = false;
          } else if (typeof options.skipBaseClassChecks !== "boolean") {
            throw new Error(ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
          }
          this.options = {
            autoBindInjectable: options.autoBindInjectable,
            defaultScope: options.defaultScope,
            skipBaseClassChecks: options.skipBaseClassChecks
          };
          this.id = (0, id_1.id)();
          this._bindingDictionary = new lookup_1.Lookup();
          this._snapshots = [];
          this._middleware = null;
          this._activations = new lookup_1.Lookup();
          this._deactivations = new lookup_1.Lookup();
          this.parent = null;
          this._metadataReader = new metadata_reader_1.MetadataReader();
          this._moduleActivationStore = new module_activation_store_1.ModuleActivationStore();
        }
        static merge(container1, container2, ...containers) {
          const container = new _Container();
          const targetContainers = [
            container1,
            container2,
            ...containers
          ].map((targetContainer) => (0, planner_1.getBindingDictionary)(targetContainer));
          const bindingDictionary = (0, planner_1.getBindingDictionary)(container);
          function copyDictionary(origin, destination) {
            origin.traverse((_key, value) => {
              value.forEach((binding) => {
                destination.add(binding.serviceIdentifier, binding.clone());
              });
            });
          }
          targetContainers.forEach((targetBindingDictionary) => {
            copyDictionary(targetBindingDictionary, bindingDictionary);
          });
          return container;
        }
        load(...modules) {
          const getHelpers = this._getContainerModuleHelpersFactory();
          for (const currentModule of modules) {
            const containerModuleHelpers = getHelpers(currentModule.id);
            currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
          }
        }
        async loadAsync(...modules) {
          const getHelpers = this._getContainerModuleHelpersFactory();
          for (const currentModule of modules) {
            const containerModuleHelpers = getHelpers(currentModule.id);
            await currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
          }
        }
        unload(...modules) {
          modules.forEach((module2) => {
            const deactivations = this._removeModuleBindings(module2.id);
            this._deactivateSingletons(deactivations);
            this._removeModuleHandlers(module2.id);
          });
        }
        async unloadAsync(...modules) {
          for (const module2 of modules) {
            const deactivations = this._removeModuleBindings(module2.id);
            await this._deactivateSingletonsAsync(deactivations);
            this._removeModuleHandlers(module2.id);
          }
        }
        // Registers a type binding
        bind(serviceIdentifier) {
          return this._bind(this._buildBinding(serviceIdentifier));
        }
        rebind(serviceIdentifier) {
          this.unbind(serviceIdentifier);
          return this.bind(serviceIdentifier);
        }
        async rebindAsync(serviceIdentifier) {
          await this.unbindAsync(serviceIdentifier);
          return this.bind(serviceIdentifier);
        }
        // Removes a type binding from the registry by its key
        unbind(serviceIdentifier) {
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            this._deactivateSingletons(bindings);
          }
          this._removeServiceFromDictionary(serviceIdentifier);
        }
        async unbindAsync(serviceIdentifier) {
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            await this._deactivateSingletonsAsync(bindings);
          }
          this._removeServiceFromDictionary(serviceIdentifier);
        }
        // Removes all the type bindings from the registry
        unbindAll() {
          this._bindingDictionary.traverse((_key, value) => {
            this._deactivateSingletons(value);
          });
          this._bindingDictionary = new lookup_1.Lookup();
        }
        async unbindAllAsync() {
          const promises = [];
          this._bindingDictionary.traverse((_key, value) => {
            promises.push(this._deactivateSingletonsAsync(value));
          });
          await Promise.all(promises);
          this._bindingDictionary = new lookup_1.Lookup();
        }
        onActivation(serviceIdentifier, onActivation) {
          this._activations.add(serviceIdentifier, onActivation);
        }
        onDeactivation(serviceIdentifier, onDeactivation) {
          this._deactivations.add(serviceIdentifier, onDeactivation);
        }
        // Allows to check if there are bindings available for serviceIdentifier
        isBound(serviceIdentifier) {
          let bound = this._bindingDictionary.hasKey(serviceIdentifier);
          if (!bound && this.parent) {
            bound = this.parent.isBound(serviceIdentifier);
          }
          return bound;
        }
        // check binding dependency only in current container
        isCurrentBound(serviceIdentifier) {
          return this._bindingDictionary.hasKey(serviceIdentifier);
        }
        isBoundNamed(serviceIdentifier, named) {
          return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        // Check if a binding with a complex constraint is available without throwing a error. Ancestors are also verified.
        isBoundTagged(serviceIdentifier, key, value) {
          let bound = false;
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
            const bindings = this._bindingDictionary.get(serviceIdentifier);
            const request = (0, planner_1.createMockRequest)(this, serviceIdentifier, {
              customTag: {
                key,
                value
              },
              isMultiInject: false
            });
            bound = bindings.some((b3) => b3.constraint(request));
          }
          if (!bound && this.parent) {
            bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
          }
          return bound;
        }
        snapshot() {
          this._snapshots.push(container_snapshot_1.ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
        }
        restore() {
          const snapshot = this._snapshots.pop();
          if (snapshot === void 0) {
            throw new Error(ERROR_MSGS.NO_MORE_SNAPSHOTS_AVAILABLE);
          }
          this._bindingDictionary = snapshot.bindings;
          this._activations = snapshot.activations;
          this._deactivations = snapshot.deactivations;
          this._middleware = snapshot.middleware;
          this._moduleActivationStore = snapshot.moduleActivationStore;
        }
        createChild(containerOptions) {
          const child = new _Container(containerOptions || this.options);
          child.parent = this;
          return child;
        }
        applyMiddleware(...middlewares) {
          const initial = this._middleware ? this._middleware : this._planAndResolve();
          this._middleware = middlewares.reduce((prev, curr) => curr(prev), initial);
        }
        applyCustomMetadataReader(metadataReader) {
          this._metadataReader = metadataReader;
        }
        // Resolves a dependency by its runtime identifier
        // The runtime identifier must be associated with only one binding
        // use getAll when the runtime identifier is associated with multiple bindings
        get(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAsync(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false);
          return this._get(getArgs);
        }
        getTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async getTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, false, key, value);
          return this._get(getArgs);
        }
        getNamed(serviceIdentifier, named) {
          return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async getNamedAsync(serviceIdentifier, named) {
          return this.getTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        // Resolves a dependency by its runtime identifier
        // The runtime identifier can be associated with one or multiple bindings
        getAll(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, false);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAllAsync(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, false);
          return this._getAll(getArgs);
        }
        getAllTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, false, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async getAllTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, false, key, value);
          return this._getAll(getArgs);
        }
        getAllNamed(serviceIdentifier, named) {
          return this.getAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async getAllNamedAsync(serviceIdentifier, named) {
          return this.getAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        resolve(constructorFunction) {
          const isBound = this.isBound(constructorFunction);
          if (!isBound) {
            this.bind(constructorFunction).toSelf();
          }
          const resolved = this.get(constructorFunction);
          if (!isBound) {
            this.unbind(constructorFunction);
          }
          return resolved;
        }
        tryGet(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAsync(serviceIdentifier) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true);
          return this._get(getArgs);
        }
        tryGetTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, false, true, key, value);
          return this._get(getArgs);
        }
        tryGetNamed(serviceIdentifier, named) {
          return this.tryGetTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async tryGetNamedAsync(serviceIdentifier, named) {
          return this.tryGetTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        tryGetAll(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, true);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAllAsync(serviceIdentifier, options) {
          const getArgs = this._getAllArgs(serviceIdentifier, options, true);
          return this._getAll(getArgs);
        }
        tryGetAllTagged(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, true, key, value);
          return this._getButThrowIfAsync(getArgs);
        }
        async tryGetAllTaggedAsync(serviceIdentifier, key, value) {
          const getArgs = this._getNotAllArgs(serviceIdentifier, true, true, key, value);
          return this._getAll(getArgs);
        }
        tryGetAllNamed(serviceIdentifier, named) {
          return this.tryGetAllTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        async tryGetAllNamedAsync(serviceIdentifier, named) {
          return this.tryGetAllTaggedAsync(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);
        }
        _preDestroy(constructor, instance) {
          var _a4;
          if (constructor !== void 0 && Reflect.hasMetadata(METADATA_KEY.PRE_DESTROY, constructor)) {
            const data = Reflect.getMetadata(METADATA_KEY.PRE_DESTROY, constructor);
            return (_a4 = instance[data.value]) == null ? void 0 : _a4.call(instance);
          }
        }
        _removeModuleHandlers(moduleId) {
          const moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
          this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
          this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
        }
        _removeModuleBindings(moduleId) {
          return this._bindingDictionary.removeByCondition((binding) => binding.moduleId === moduleId);
        }
        _deactivate(binding, instance) {
          const constructor = instance == void 0 ? void 0 : (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            Object.getPrototypeOf(instance).constructor
          );
          try {
            if (this._deactivations.hasKey(binding.serviceIdentifier)) {
              const result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
              if ((0, async_1.isPromise)(result)) {
                return this._handleDeactivationError(result.then(async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor)), binding.serviceIdentifier);
              }
            }
            const propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
            if ((0, async_1.isPromise)(propagateDeactivationResult)) {
              return this._handleDeactivationError(propagateDeactivationResult, binding.serviceIdentifier);
            }
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR((0, serialization_1.getServiceIdentifierAsString)(binding.serviceIdentifier), ex.message));
            }
          }
        }
        async _handleDeactivationError(asyncResult, serviceIdentifier) {
          try {
            await asyncResult;
          } catch (ex) {
            if (ex instanceof Error) {
              throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR((0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier), ex.message));
            }
          }
        }
        _deactivateContainer(instance, deactivationsIterator) {
          let deactivation = deactivationsIterator.next();
          while (typeof deactivation.value === "function") {
            const result = deactivation.value(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(async () => this._deactivateContainerAsync(instance, deactivationsIterator));
            }
            deactivation = deactivationsIterator.next();
          }
        }
        async _deactivateContainerAsync(instance, deactivationsIterator) {
          let deactivation = deactivationsIterator.next();
          while (typeof deactivation.value === "function") {
            await deactivation.value(instance);
            deactivation = deactivationsIterator.next();
          }
        }
        _getContainerModuleHelpersFactory() {
          const getBindFunction = (moduleId) => (serviceIdentifier) => {
            const binding = this._buildBinding(serviceIdentifier);
            binding.moduleId = moduleId;
            return this._bind(binding);
          };
          const getUnbindFunction = () => (serviceIdentifier) => {
            this.unbind(serviceIdentifier);
          };
          const getUnbindAsyncFunction = () => async (serviceIdentifier) => {
            return this.unbindAsync(serviceIdentifier);
          };
          const getIsboundFunction = () => (serviceIdentifier) => {
            return this.isBound(serviceIdentifier);
          };
          const getRebindFunction = (moduleId) => {
            const bind = getBindFunction(moduleId);
            return (serviceIdentifier) => {
              this.unbind(serviceIdentifier);
              return bind(serviceIdentifier);
            };
          };
          const getOnActivationFunction = (moduleId) => (serviceIdentifier, onActivation) => {
            this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
            this.onActivation(serviceIdentifier, onActivation);
          };
          const getOnDeactivationFunction = (moduleId) => (serviceIdentifier, onDeactivation) => {
            this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
            this.onDeactivation(serviceIdentifier, onDeactivation);
          };
          return (mId) => ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            onActivationFunction: getOnActivationFunction(mId),
            onDeactivationFunction: getOnDeactivationFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindAsyncFunction: getUnbindAsyncFunction(),
            unbindFunction: getUnbindFunction()
          });
        }
        _bind(binding) {
          this._bindingDictionary.add(binding.serviceIdentifier, binding);
          return new binding_to_syntax_1.BindingToSyntax(binding);
        }
        _buildBinding(serviceIdentifier) {
          const scope = this.options.defaultScope || literal_types_1.BindingScopeEnum.Transient;
          return new binding_1.Binding(serviceIdentifier, scope);
        }
        async _getAll(getArgs) {
          return Promise.all(this._get(getArgs));
        }
        // Prepares arguments required for resolution and
        // delegates resolution to _middleware if available
        // otherwise it delegates resolution to _planAndResolve
        _get(getArgs) {
          const planAndResolveArgs = __spreadProps(__spreadValues({}, getArgs), {
            contextInterceptor: (context) => context,
            targetType: literal_types_1.TargetTypeEnum.Variable
          });
          if (this._middleware) {
            const middlewareResult = this._middleware(planAndResolveArgs);
            if (middlewareResult === void 0 || middlewareResult === null) {
              throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);
            }
            return middlewareResult;
          }
          return this._planAndResolve()(planAndResolveArgs);
        }
        _getButThrowIfAsync(getArgs) {
          const result = this._get(getArgs);
          if ((0, async_1.isPromiseOrContainsPromise)(result)) {
            throw new Error(ERROR_MSGS.LAZY_IN_SYNC(getArgs.serviceIdentifier));
          }
          return result;
        }
        _getAllArgs(serviceIdentifier, options, isOptional) {
          var _a4;
          const getAllArgs = {
            avoidConstraints: !((_a4 = options == null ? void 0 : options.enforceBindingConstraints) != null ? _a4 : false),
            isMultiInject: true,
            isOptional,
            serviceIdentifier
          };
          return getAllArgs;
        }
        _getNotAllArgs(serviceIdentifier, isMultiInject, isOptional, key, value) {
          const getNotAllArgs = {
            avoidConstraints: false,
            isMultiInject,
            isOptional,
            key,
            serviceIdentifier,
            value
          };
          return getNotAllArgs;
        }
        _getPlanMetadataFromNextArgs(args) {
          const planMetadata = {
            isMultiInject: args.isMultiInject
          };
          if (args.key !== void 0) {
            planMetadata.customTag = {
              key: args.key,
              value: args.value
            };
          }
          if (args.isOptional === true) {
            planMetadata.isOptional = true;
          }
          return planMetadata;
        }
        // Planner creates a plan and Resolver resolves a plan
        // one of the jobs of the Container is to links the Planner
        // with the Resolver and that is what this function is about
        _planAndResolve() {
          return (args) => {
            let context = (0, planner_1.plan)(this._metadataReader, this, args.targetType, args.serviceIdentifier, this._getPlanMetadataFromNextArgs(args), args.avoidConstraints);
            context = args.contextInterceptor(context);
            const result = (0, resolver_1.resolve)(context);
            return result;
          };
        }
        _deactivateIfSingleton(binding) {
          if (!binding.activated) {
            return;
          }
          if ((0, async_1.isPromise)(binding.cache)) {
            return binding.cache.then((resolved) => this._deactivate(binding, resolved));
          }
          return this._deactivate(binding, binding.cache);
        }
        _deactivateSingletons(bindings) {
          for (const binding of bindings) {
            const result = this._deactivateIfSingleton(binding);
            if ((0, async_1.isPromise)(result)) {
              throw new Error(ERROR_MSGS.ASYNC_UNBIND_REQUIRED);
            }
          }
        }
        async _deactivateSingletonsAsync(bindings) {
          await Promise.all(bindings.map(async (b3) => this._deactivateIfSingleton(b3)));
        }
        _propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor) {
          if (this.parent) {
            return this._deactivate.bind(this.parent)(binding, instance);
          } else {
            return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
          }
        }
        async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor) {
          if (this.parent) {
            await this._deactivate.bind(this.parent)(binding, instance);
          } else {
            await this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor);
          }
        }
        _removeServiceFromDictionary(serviceIdentifier) {
          try {
            this._bindingDictionary.remove(serviceIdentifier);
          } catch (_e3) {
            throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${(0, serialization_1.getServiceIdentifierAsString)(serviceIdentifier)}`);
          }
        }
        _bindingDeactivationAndPreDestroy(binding, instance, constructor) {
          if (typeof binding.onDeactivation === "function") {
            const result = binding.onDeactivation(instance);
            if ((0, async_1.isPromise)(result)) {
              return result.then(() => this._preDestroy(constructor, instance));
            }
          }
          return this._preDestroy(constructor, instance);
        }
        async _bindingDeactivationAndPreDestroyAsync(binding, instance, constructor) {
          if (typeof binding.onDeactivation === "function") {
            await binding.onDeactivation(instance);
          }
          await this._preDestroy(constructor, instance);
        }
      };
      exports.Container = Container;
    }
  });

  // ../../node_modules/inversify/lib/cjs/container/container_module.js
  var require_container_module = __commonJS({
    "../../node_modules/inversify/lib/cjs/container/container_module.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncContainerModule = exports.ContainerModule = void 0;
      var id_1 = require_id();
      var ContainerModule = class {
        constructor(registry) {
          __publicField(this, "id");
          __publicField(this, "registry");
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
      };
      exports.ContainerModule = ContainerModule;
      var AsyncContainerModule = class {
        constructor(registry) {
          __publicField(this, "id");
          __publicField(this, "registry");
          this.id = (0, id_1.id)();
          this.registry = registry;
        }
      };
      exports.AsyncContainerModule = AsyncContainerModule;
    }
  });

  // ../../node_modules/inversify/lib/cjs/utils/js.js
  var require_js = __commonJS({
    "../../node_modules/inversify/lib/cjs/utils/js.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFirstArrayDuplicate = getFirstArrayDuplicate;
      function getFirstArrayDuplicate(array) {
        const seenValues = /* @__PURE__ */ new Set();
        for (const entry of array) {
          if (seenValues.has(entry)) {
            return entry;
          } else {
            seenValues.add(entry);
          }
        }
        return void 0;
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/decorator_utils.js
  var require_decorator_utils = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/decorator_utils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decorate = decorate;
      exports.tagParameter = tagParameter;
      exports.tagProperty = tagProperty;
      exports.createTaggedDecorator = createTaggedDecorator;
      var ERROR_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var js_1 = require_js();
      function targetIsConstructorFunction(target) {
        return target.prototype !== void 0;
      }
      function _throwIfMethodParameter(parameterName) {
        if (parameterName !== void 0) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
      }
      function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
        _throwIfMethodParameter(parameterName);
        _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);
      }
      function tagProperty(annotationTarget, propertyName, metadata) {
        if (targetIsConstructorFunction(annotationTarget)) {
          throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);
        }
        _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
      }
      function _ensureNoMetadataKeyDuplicates(metadata) {
        let metadatas = [];
        if (Array.isArray(metadata)) {
          metadatas = metadata;
          const duplicate = (0, js_1.getFirstArrayDuplicate)(metadatas.map((md) => md.key));
          if (duplicate !== void 0) {
            throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${duplicate.toString()}`);
          }
        } else {
          metadatas = [metadata];
        }
        return metadatas;
      }
      function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
        const metadatas = _ensureNoMetadataKeyDuplicates(metadata);
        let paramsOrPropertiesMetadata = {};
        if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
          paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
        }
        let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
        if (paramOrPropertyMetadata === void 0) {
          paramOrPropertyMetadata = [];
        } else {
          for (const m3 of paramOrPropertyMetadata) {
            if (metadatas.some((md) => md.key === m3.key)) {
              throw new Error(`${ERROR_MSGS.DUPLICATED_METADATA} ${m3.key.toString()}`);
            }
          }
        }
        paramOrPropertyMetadata.push(...metadatas);
        paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
        Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
      }
      function createTaggedDecorator(metadata) {
        return (target, targetKey, indexOrPropertyDescriptor) => {
          if (typeof indexOrPropertyDescriptor === "number") {
            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
          } else {
            tagProperty(target, targetKey, metadata);
          }
        };
      }
      function _decorate(decorators, target) {
        Reflect.decorate(decorators, target);
      }
      function _param(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function decorate(decorator, target, parameterIndexOrProperty) {
        if (typeof parameterIndexOrProperty === "number") {
          _decorate([_param(parameterIndexOrProperty, decorator)], target);
        } else if (typeof parameterIndexOrProperty === "string") {
          Reflect.decorate([decorator], target, parameterIndexOrProperty);
        } else {
          _decorate([decorator], target);
        }
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/injectable.js
  var require_injectable = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/injectable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectable = injectable;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      function injectable() {
        return function(target) {
          if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {
            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);
          }
          const types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];
          Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);
          return target;
        };
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/tagged.js
  var require_tagged = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/tagged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tagged = tagged;
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function tagged(metadataKey, metadataValue) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, metadataValue));
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/named.js
  var require_named = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/named.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.named = named;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function named(name) {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.NAMED_TAG, name));
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/inject_base.js
  var require_inject_base = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/inject_base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.injectBase = injectBase;
      var error_msgs_1 = require_error_msgs();
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function injectBase(metadataKey) {
        return (serviceIdentifier) => {
          return (target, targetKey, indexOrPropertyDescriptor) => {
            if (serviceIdentifier === void 0) {
              const className = typeof target === "function" ? target.name : target.constructor.name;
              throw new Error((0, error_msgs_1.UNDEFINED_INJECT_ANNOTATION)(className));
            }
            (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
          };
        };
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/inject.js
  var require_inject = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.inject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var inject = (0, inject_base_1.injectBase)(METADATA_KEY.INJECT_TAG);
      exports.inject = inject;
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/optional.js
  var require_optional = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/optional.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.optional = optional;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function optional() {
        return (0, decorator_utils_1.createTaggedDecorator)(new metadata_1.Metadata(METADATA_KEY.OPTIONAL_TAG, true));
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/unmanaged.js
  var require_unmanaged = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/unmanaged.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unmanaged = unmanaged;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function unmanaged() {
        return function(target, targetKey, index) {
          const metadata = new metadata_1.Metadata(METADATA_KEY.UNMANAGED_TAG, true);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/multi_inject.js
  var require_multi_inject = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/multi_inject.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiInject = void 0;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var inject_base_1 = require_inject_base();
      var multiInject = (0, inject_base_1.injectBase)(METADATA_KEY.MULTI_INJECT_TAG);
      exports.multiInject = multiInject;
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/target_name.js
  var require_target_name = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/target_name.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.targetName = targetName;
      var METADATA_KEY = __importStar(require_metadata_keys());
      var metadata_1 = require_metadata();
      var decorator_utils_1 = require_decorator_utils();
      function targetName(name) {
        return function(target, targetKey, index) {
          const metadata = new metadata_1.Metadata(METADATA_KEY.NAME_TAG, name);
          (0, decorator_utils_1.tagParameter)(target, targetKey, index, metadata);
        };
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/property_event_decorator.js
  var require_property_event_decorator = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/property_event_decorator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.propertyEventDecorator = propertyEventDecorator;
      var metadata_1 = require_metadata();
      function propertyEventDecorator(eventKey, errorMessage) {
        return () => {
          return (target, propertyKey) => {
            const metadata = new metadata_1.Metadata(eventKey, propertyKey);
            if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
              throw new Error(errorMessage);
            }
            Reflect.defineMetadata(eventKey, metadata, target.constructor);
          };
        };
      }
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/post_construct.js
  var require_post_construct = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/post_construct.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postConstruct = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var postConstruct = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.POST_CONSTRUCT, ERRORS_MSGS.MULTIPLE_POST_CONSTRUCT_METHODS);
      exports.postConstruct = postConstruct;
    }
  });

  // ../../node_modules/inversify/lib/cjs/annotation/pre_destroy.js
  var require_pre_destroy = __commonJS({
    "../../node_modules/inversify/lib/cjs/annotation/pre_destroy.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.preDestroy = void 0;
      var ERRORS_MSGS = __importStar(require_error_msgs());
      var METADATA_KEY = __importStar(require_metadata_keys());
      var property_event_decorator_1 = require_property_event_decorator();
      var preDestroy = (0, property_event_decorator_1.propertyEventDecorator)(METADATA_KEY.PRE_DESTROY, ERRORS_MSGS.MULTIPLE_PRE_DESTROY_METHODS);
      exports.preDestroy = preDestroy;
    }
  });

  // ../../node_modules/inversify/lib/cjs/index.js
  var require_cjs4 = __commonJS({
    "../../node_modules/inversify/lib/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      }) : function(o3, v3) {
        o3["default"] = v3;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o3) {
          ownKeys = Object.getOwnPropertyNames || function(o4) {
            var ar = [];
            for (var k3 in o4) if (Object.prototype.hasOwnProperty.call(o4, k3)) ar[ar.length] = k3;
            return ar;
          };
          return ownKeys(o3);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k3 = ownKeys(mod), i2 = 0; i2 < k3.length; i2++) if (k3[i2] !== "default") __createBinding(result, mod, k3[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiBindToService = exports.getServiceIdentifierAsString = exports.typeConstraint = exports.namedConstraint = exports.taggedConstraint = exports.traverseAncerstors = exports.decorate = exports.id = exports.MetadataReader = exports.preDestroy = exports.postConstruct = exports.targetName = exports.multiInject = exports.unmanaged = exports.optional = exports.inject = exports.named = exports.tagged = exports.injectable = exports.createTaggedDecorator = exports.ContainerModule = exports.AsyncContainerModule = exports.TargetTypeEnum = exports.BindingTypeEnum = exports.BindingScopeEnum = exports.Container = exports.METADATA_KEY = exports.LazyServiceIdentifer = exports.LazyServiceIdentifier = void 0;
      require_Reflect();
      var common_1 = require_cjs();
      var keys = __importStar(require_metadata_keys());
      var common_2 = require_cjs();
      Object.defineProperty(exports, "LazyServiceIdentifier", { enumerable: true, get: function() {
        return common_2.LazyServiceIdentifier;
      } });
      exports.LazyServiceIdentifer = common_1.LazyServiceIdentifier;
      exports.METADATA_KEY = keys;
      var container_1 = require_container();
      Object.defineProperty(exports, "Container", { enumerable: true, get: function() {
        return container_1.Container;
      } });
      var literal_types_1 = require_literal_types();
      Object.defineProperty(exports, "BindingScopeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingScopeEnum;
      } });
      Object.defineProperty(exports, "BindingTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.BindingTypeEnum;
      } });
      Object.defineProperty(exports, "TargetTypeEnum", { enumerable: true, get: function() {
        return literal_types_1.TargetTypeEnum;
      } });
      var container_module_1 = require_container_module();
      Object.defineProperty(exports, "AsyncContainerModule", { enumerable: true, get: function() {
        return container_module_1.AsyncContainerModule;
      } });
      Object.defineProperty(exports, "ContainerModule", { enumerable: true, get: function() {
        return container_module_1.ContainerModule;
      } });
      var decorator_utils_1 = require_decorator_utils();
      Object.defineProperty(exports, "createTaggedDecorator", { enumerable: true, get: function() {
        return decorator_utils_1.createTaggedDecorator;
      } });
      var injectable_1 = require_injectable();
      Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
        return injectable_1.injectable;
      } });
      var tagged_1 = require_tagged();
      Object.defineProperty(exports, "tagged", { enumerable: true, get: function() {
        return tagged_1.tagged;
      } });
      var named_1 = require_named();
      Object.defineProperty(exports, "named", { enumerable: true, get: function() {
        return named_1.named;
      } });
      var inject_1 = require_inject();
      Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
        return inject_1.inject;
      } });
      var optional_1 = require_optional();
      Object.defineProperty(exports, "optional", { enumerable: true, get: function() {
        return optional_1.optional;
      } });
      var unmanaged_1 = require_unmanaged();
      Object.defineProperty(exports, "unmanaged", { enumerable: true, get: function() {
        return unmanaged_1.unmanaged;
      } });
      var multi_inject_1 = require_multi_inject();
      Object.defineProperty(exports, "multiInject", { enumerable: true, get: function() {
        return multi_inject_1.multiInject;
      } });
      var target_name_1 = require_target_name();
      Object.defineProperty(exports, "targetName", { enumerable: true, get: function() {
        return target_name_1.targetName;
      } });
      var post_construct_1 = require_post_construct();
      Object.defineProperty(exports, "postConstruct", { enumerable: true, get: function() {
        return post_construct_1.postConstruct;
      } });
      var pre_destroy_1 = require_pre_destroy();
      Object.defineProperty(exports, "preDestroy", { enumerable: true, get: function() {
        return pre_destroy_1.preDestroy;
      } });
      var metadata_reader_1 = require_metadata_reader();
      Object.defineProperty(exports, "MetadataReader", { enumerable: true, get: function() {
        return metadata_reader_1.MetadataReader;
      } });
      var id_1 = require_id();
      Object.defineProperty(exports, "id", { enumerable: true, get: function() {
        return id_1.id;
      } });
      var decorator_utils_2 = require_decorator_utils();
      Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
        return decorator_utils_2.decorate;
      } });
      var constraint_helpers_1 = require_constraint_helpers();
      Object.defineProperty(exports, "traverseAncerstors", { enumerable: true, get: function() {
        return constraint_helpers_1.traverseAncerstors;
      } });
      Object.defineProperty(exports, "taggedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.taggedConstraint;
      } });
      Object.defineProperty(exports, "namedConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.namedConstraint;
      } });
      Object.defineProperty(exports, "typeConstraint", { enumerable: true, get: function() {
        return constraint_helpers_1.typeConstraint;
      } });
      var serialization_1 = require_serialization();
      Object.defineProperty(exports, "getServiceIdentifierAsString", { enumerable: true, get: function() {
        return serialization_1.getServiceIdentifierAsString;
      } });
      var binding_utils_1 = require_binding_utils();
      Object.defineProperty(exports, "multiBindToService", { enumerable: true, get: function() {
        return binding_utils_1.multiBindToService;
      } });
    }
  });

  // ../../node_modules/sprotty-protocol/lib/utils/object.js
  var require_object = __commonJS({
    "../../node_modules/sprotty-protocol/lib/utils/object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeAssign = exports.hasOwnProperty = exports.isObject = void 0;
      function isObject(data) {
        return typeof data === "object" && data !== null;
      }
      exports.isObject = isObject;
      function hasOwnProperty(arg, key, type) {
        if (!isObject(arg)) {
          return false;
        }
        if (Array.isArray(key)) {
          for (const k3 of key) {
            if (!Object.prototype.hasOwnProperty.call(arg, k3)) {
              return false;
            }
            if (typeof type === "string" && typeof arg[k3] !== type) {
              return false;
            } else if (typeof type === "function" && !type(arg[k3])) {
              return false;
            }
          }
        } else {
          if (!Object.prototype.hasOwnProperty.call(arg, key)) {
            return false;
          }
          if (typeof type === "string") {
            return typeof arg[key] === type;
          }
          if (typeof type === "function") {
            return type(arg[key]);
          }
        }
        return true;
      }
      exports.hasOwnProperty = hasOwnProperty;
      function safeAssign(target, partial) {
        return Object.assign(target, partial);
      }
      exports.safeAssign = safeAssign;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/actions.js
  var require_actions = __commonJS({
    "../../node_modules/sprotty-protocol/lib/actions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectAction = exports.ApplyLabelEditAction = exports.DeleteElementAction = exports.CreateElementAction = exports.ExportSvgAction = exports.RequestExportSvgAction = exports.HoverFeedbackAction = exports.MoveAction = exports.RedoAction = exports.UndoAction = exports.BringToFrontAction = exports.ViewportResult = exports.GetViewportAction = exports.SetViewportAction = exports.FitToScreenAction = exports.CenterAction = exports.LayoutAction = exports.OpenAction = exports.CollapseExpandAllAction = exports.CollapseExpandAction = exports.SelectionResult = exports.GetSelectionAction = exports.SelectAllAction = exports.SelectAction = exports.LoggingAction = exports.ComputedBoundsAction = exports.RequestBoundsAction = exports.SetBoundsAction = exports.SetPopupModelAction = exports.RequestPopupModelAction = exports.UpdateModelAction = exports.SetModelAction = exports.RequestModelAction = exports.RejectAction = exports.isResponseAction = exports.setRequestContext = exports.generateRequestId = exports.isRequestAction = exports.isAction = exports.isActionMessage = void 0;
      var object_1 = require_object();
      function isActionMessage(object) {
        return (0, object_1.hasOwnProperty)(object, "action");
      }
      exports.isActionMessage = isActionMessage;
      function isAction(object) {
        return (0, object_1.hasOwnProperty)(object, "kind", "string");
      }
      exports.isAction = isAction;
      function isRequestAction(object) {
        return (0, object_1.hasOwnProperty)(object, "requestId", "string");
      }
      exports.isRequestAction = isRequestAction;
      var requestContext = "";
      var nextRequestId = 1;
      function generateRequestId() {
        return `${requestContext}_${nextRequestId++}`;
      }
      exports.generateRequestId = generateRequestId;
      function setRequestContext(context) {
        requestContext = context;
      }
      exports.setRequestContext = setRequestContext;
      function isResponseAction(object) {
        return (0, object_1.hasOwnProperty)(object, "responseId", "string") && object.responseId !== "";
      }
      exports.isResponseAction = isResponseAction;
      var RejectAction;
      (function(RejectAction2) {
        RejectAction2.KIND = "rejectRequest";
        function create(options) {
          return {
            kind: RejectAction2.KIND,
            message: options.message,
            detail: options.detail,
            responseId: options.requestId
          };
        }
        RejectAction2.create = create;
      })(RejectAction || (exports.RejectAction = RejectAction = {}));
      var RequestModelAction;
      (function(RequestModelAction2) {
        RequestModelAction2.KIND = "requestModel";
        function create(options) {
          return {
            kind: RequestModelAction2.KIND,
            options,
            requestId: generateRequestId()
          };
        }
        RequestModelAction2.create = create;
      })(RequestModelAction || (exports.RequestModelAction = RequestModelAction = {}));
      var SetModelAction;
      (function(SetModelAction2) {
        SetModelAction2.KIND = "setModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetModelAction2.create = create;
      })(SetModelAction || (exports.SetModelAction = SetModelAction = {}));
      var UpdateModelAction;
      (function(UpdateModelAction2) {
        UpdateModelAction2.KIND = "updateModel";
        function create(input, options = {}) {
          if (Array.isArray(input)) {
            return {
              kind: UpdateModelAction2.KIND,
              matches: input,
              animate: options.animate,
              cause: options.cause
            };
          } else {
            return {
              kind: UpdateModelAction2.KIND,
              newRoot: input,
              animate: options.animate,
              cause: options.cause
            };
          }
        }
        UpdateModelAction2.create = create;
      })(UpdateModelAction || (exports.UpdateModelAction = UpdateModelAction = {}));
      var RequestPopupModelAction;
      (function(RequestPopupModelAction2) {
        RequestPopupModelAction2.KIND = "requestPopupModel";
        function create(options) {
          return {
            kind: RequestPopupModelAction2.KIND,
            elementId: options.elementId,
            bounds: options.bounds,
            requestId: generateRequestId()
          };
        }
        RequestPopupModelAction2.create = create;
      })(RequestPopupModelAction || (exports.RequestPopupModelAction = RequestPopupModelAction = {}));
      var SetPopupModelAction;
      (function(SetPopupModelAction2) {
        SetPopupModelAction2.KIND = "setPopupModel";
        function create(newRoot, requestId = "") {
          return {
            kind: SetPopupModelAction2.KIND,
            newRoot,
            responseId: requestId
          };
        }
        SetPopupModelAction2.create = create;
      })(SetPopupModelAction || (exports.SetPopupModelAction = SetPopupModelAction = {}));
      var SetBoundsAction;
      (function(SetBoundsAction2) {
        SetBoundsAction2.KIND = "setBounds";
        function create(bounds) {
          return {
            kind: SetBoundsAction2.KIND,
            bounds
          };
        }
        SetBoundsAction2.create = create;
      })(SetBoundsAction || (exports.SetBoundsAction = SetBoundsAction = {}));
      var RequestBoundsAction;
      (function(RequestBoundsAction2) {
        RequestBoundsAction2.KIND = "requestBounds";
        function create(newRoot) {
          return {
            kind: RequestBoundsAction2.KIND,
            newRoot,
            requestId: generateRequestId()
          };
        }
        RequestBoundsAction2.create = create;
      })(RequestBoundsAction || (exports.RequestBoundsAction = RequestBoundsAction = {}));
      var ComputedBoundsAction;
      (function(ComputedBoundsAction2) {
        ComputedBoundsAction2.KIND = "computedBounds";
        function create(bounds, options = {}) {
          var _a4;
          return {
            kind: ComputedBoundsAction2.KIND,
            bounds,
            revision: options.revision,
            alignments: options.alignments,
            responseId: (_a4 = options.requestId) !== null && _a4 !== void 0 ? _a4 : ""
          };
        }
        ComputedBoundsAction2.create = create;
      })(ComputedBoundsAction || (exports.ComputedBoundsAction = ComputedBoundsAction = {}));
      var LoggingAction;
      (function(LoggingAction2) {
        LoggingAction2.KIND = "logging";
        function create(options) {
          return Object.assign({ kind: LoggingAction2.KIND }, options);
        }
        LoggingAction2.create = create;
      })(LoggingAction || (exports.LoggingAction = LoggingAction = {}));
      var SelectAction;
      (function(SelectAction2) {
        SelectAction2.KIND = "elementSelected";
        function create(options) {
          var _a4, _b2;
          return {
            kind: SelectAction2.KIND,
            selectedElementsIDs: (_a4 = options.selectedElementsIDs) !== null && _a4 !== void 0 ? _a4 : [],
            deselectedElementsIDs: (_b2 = options.deselectedElementsIDs) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        SelectAction2.create = create;
      })(SelectAction || (exports.SelectAction = SelectAction = {}));
      var SelectAllAction;
      (function(SelectAllAction2) {
        SelectAllAction2.KIND = "allSelected";
        function create(options = {}) {
          var _a4;
          return {
            kind: SelectAllAction2.KIND,
            select: (_a4 = options.select) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        SelectAllAction2.create = create;
      })(SelectAllAction || (exports.SelectAllAction = SelectAllAction = {}));
      var GetSelectionAction;
      (function(GetSelectionAction2) {
        GetSelectionAction2.KIND = "getSelection";
        function create() {
          return {
            kind: GetSelectionAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetSelectionAction2.create = create;
      })(GetSelectionAction || (exports.GetSelectionAction = GetSelectionAction = {}));
      var SelectionResult;
      (function(SelectionResult2) {
        SelectionResult2.KIND = "selectionResult";
        function create(selectedElementsIDs, requestId) {
          return {
            kind: SelectionResult2.KIND,
            selectedElementsIDs,
            responseId: requestId
          };
        }
        SelectionResult2.create = create;
      })(SelectionResult || (exports.SelectionResult = SelectionResult = {}));
      var CollapseExpandAction;
      (function(CollapseExpandAction2) {
        CollapseExpandAction2.KIND = "collapseExpand";
        function create(options) {
          var _a4, _b2;
          return {
            kind: CollapseExpandAction2.KIND,
            expandIds: (_a4 = options.expandIds) !== null && _a4 !== void 0 ? _a4 : [],
            collapseIds: (_b2 = options.collapseIds) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        CollapseExpandAction2.create = create;
      })(CollapseExpandAction || (exports.CollapseExpandAction = CollapseExpandAction = {}));
      var CollapseExpandAllAction;
      (function(CollapseExpandAllAction2) {
        CollapseExpandAllAction2.KIND = "collapseExpandAll";
        function create(options = {}) {
          var _a4;
          return {
            kind: CollapseExpandAllAction2.KIND,
            expand: (_a4 = options.expand) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        CollapseExpandAllAction2.create = create;
      })(CollapseExpandAllAction || (exports.CollapseExpandAllAction = CollapseExpandAllAction = {}));
      var OpenAction;
      (function(OpenAction2) {
        OpenAction2.KIND = "open";
        function create(elementId) {
          return {
            kind: OpenAction2.KIND,
            elementId
          };
        }
        OpenAction2.create = create;
      })(OpenAction || (exports.OpenAction = OpenAction = {}));
      var LayoutAction;
      (function(LayoutAction2) {
        LayoutAction2.KIND = "layout";
        function create(options = {}) {
          return {
            kind: LayoutAction2.KIND,
            layoutType: options.layoutType,
            elementIds: options.elementIds
          };
        }
        LayoutAction2.create = create;
      })(LayoutAction || (exports.LayoutAction = LayoutAction = {}));
      var CenterAction;
      (function(CenterAction2) {
        CenterAction2.KIND = "center";
        function create(elementIds, options = {}) {
          var _a4, _b2;
          return {
            kind: CenterAction2.KIND,
            elementIds,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true,
            retainZoom: (_b2 = options.retainZoom) !== null && _b2 !== void 0 ? _b2 : false,
            zoomScale: options.zoomScale
          };
        }
        CenterAction2.create = create;
      })(CenterAction || (exports.CenterAction = CenterAction = {}));
      var FitToScreenAction;
      (function(FitToScreenAction2) {
        FitToScreenAction2.KIND = "fit";
        function create(elementIds, options = {}) {
          var _a4;
          return {
            kind: FitToScreenAction2.KIND,
            elementIds,
            padding: options.padding,
            maxZoom: options.maxZoom,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        FitToScreenAction2.create = create;
      })(FitToScreenAction || (exports.FitToScreenAction = FitToScreenAction = {}));
      var SetViewportAction;
      (function(SetViewportAction2) {
        SetViewportAction2.KIND = "viewport";
        function create(elementId, newViewport, options = {}) {
          var _a4;
          return {
            kind: SetViewportAction2.KIND,
            elementId,
            newViewport,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true
          };
        }
        SetViewportAction2.create = create;
      })(SetViewportAction || (exports.SetViewportAction = SetViewportAction = {}));
      var GetViewportAction;
      (function(GetViewportAction2) {
        GetViewportAction2.KIND = "getViewport";
        function create() {
          return {
            kind: GetViewportAction2.KIND,
            requestId: generateRequestId()
          };
        }
        GetViewportAction2.create = create;
      })(GetViewportAction || (exports.GetViewportAction = GetViewportAction = {}));
      var ViewportResult;
      (function(ViewportResult2) {
        ViewportResult2.KIND = "viewportResult";
        function create(viewport, canvasBounds, requestId) {
          return {
            kind: ViewportResult2.KIND,
            viewport,
            canvasBounds,
            responseId: requestId
          };
        }
        ViewportResult2.create = create;
      })(ViewportResult || (exports.ViewportResult = ViewportResult = {}));
      var BringToFrontAction;
      (function(BringToFrontAction2) {
        BringToFrontAction2.KIND = "bringToFront";
        function create(elementIDs) {
          return {
            kind: BringToFrontAction2.KIND,
            elementIDs
          };
        }
        BringToFrontAction2.create = create;
      })(BringToFrontAction || (exports.BringToFrontAction = BringToFrontAction = {}));
      var UndoAction;
      (function(UndoAction2) {
        UndoAction2.KIND = "undo";
        function create() {
          return {
            kind: UndoAction2.KIND
          };
        }
        UndoAction2.create = create;
      })(UndoAction || (exports.UndoAction = UndoAction = {}));
      var RedoAction;
      (function(RedoAction2) {
        RedoAction2.KIND = "redo";
        function create() {
          return {
            kind: RedoAction2.KIND
          };
        }
        RedoAction2.create = create;
      })(RedoAction || (exports.RedoAction = RedoAction = {}));
      var MoveAction;
      (function(MoveAction2) {
        MoveAction2.KIND = "move";
        function create(moves, options = {}) {
          var _a4, _b2, _c;
          return {
            kind: MoveAction2.KIND,
            moves,
            animate: (_a4 = options.animate) !== null && _a4 !== void 0 ? _a4 : true,
            finished: (_b2 = options.finished) !== null && _b2 !== void 0 ? _b2 : false,
            stoppable: (_c = options.stoppable) !== null && _c !== void 0 ? _c : false
          };
        }
        MoveAction2.create = create;
      })(MoveAction || (exports.MoveAction = MoveAction = {}));
      var HoverFeedbackAction;
      (function(HoverFeedbackAction2) {
        HoverFeedbackAction2.KIND = "hoverFeedback";
        function create(options) {
          return {
            kind: HoverFeedbackAction2.KIND,
            mouseoverElement: options.mouseoverElement,
            mouseIsOver: options.mouseIsOver
          };
        }
        HoverFeedbackAction2.create = create;
      })(HoverFeedbackAction || (exports.HoverFeedbackAction = HoverFeedbackAction = {}));
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function create(options) {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: generateRequestId(),
            options
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function create(svg, requestId, options) {
          return {
            kind: ExportSvgAction2.KIND,
            svg,
            responseId: requestId,
            options
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
      var CreateElementAction;
      (function(CreateElementAction2) {
        CreateElementAction2.KIND = "createElement";
        function create(elementSchema, options) {
          return {
            kind: CreateElementAction2.KIND,
            elementSchema,
            containerId: options.containerId
          };
        }
        CreateElementAction2.create = create;
      })(CreateElementAction || (exports.CreateElementAction = CreateElementAction = {}));
      var DeleteElementAction;
      (function(DeleteElementAction2) {
        DeleteElementAction2.KIND = "delete";
        function create(elementIds) {
          return {
            kind: DeleteElementAction2.KIND,
            elementIds
          };
        }
        DeleteElementAction2.create = create;
      })(DeleteElementAction || (exports.DeleteElementAction = DeleteElementAction = {}));
      var ApplyLabelEditAction;
      (function(ApplyLabelEditAction2) {
        ApplyLabelEditAction2.KIND = "applyLabelEdit";
        function create(labelId, text) {
          return {
            kind: ApplyLabelEditAction2.KIND,
            labelId,
            text
          };
        }
        ApplyLabelEditAction2.create = create;
      })(ApplyLabelEditAction || (exports.ApplyLabelEditAction = ApplyLabelEditAction = {}));
      var ReconnectAction;
      (function(ReconnectAction2) {
        ReconnectAction2.KIND = "reconnect";
        function create(options) {
          return {
            kind: ReconnectAction2.KIND,
            routableId: options.routableId,
            newSourceId: options.newSourceId,
            newTargetId: options.newTargetId
          };
        }
        ReconnectAction2.create = create;
      })(ReconnectAction || (exports.ReconnectAction = ReconnectAction = {}));
    }
  });

  // ../../node_modules/sprotty-protocol/lib/utils/async.js
  var require_async2 = __commonJS({
    "../../node_modules/sprotty-protocol/lib/utils/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deferred = void 0;
      var Deferred = class {
        constructor() {
          this._state = "unresolved";
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
          this.promise.then((res) => this._state = "resolved", (rej) => this._state = "rejected");
        }
        set state(state) {
          if (this._state === "unresolved") {
            this._state = state;
          }
        }
        get state() {
          return this._state;
        }
      };
      exports.Deferred = Deferred;
    }
  });

  // ../../node_modules/sprotty/lib/base/types.js
  var require_types = __commonJS({
    "../../node_modules/sprotty/lib/base/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TYPES = void 0;
      exports.TYPES = {
        Action: Symbol("Action"),
        IActionDispatcher: Symbol("IActionDispatcher"),
        IActionDispatcherProvider: Symbol("IActionDispatcherProvider"),
        IActionHandlerInitializer: Symbol("IActionHandlerInitializer"),
        ActionHandlerRegistration: Symbol("ActionHandlerRegistration"),
        ActionHandlerRegistryProvider: Symbol("ActionHandlerRegistryProvider"),
        IAnchorComputer: Symbol("IAnchor"),
        AnimationFrameSyncer: Symbol("AnimationFrameSyncer"),
        IButtonHandlerRegistration: Symbol("IButtonHandlerRegistration"),
        ICommandPaletteActionProvider: Symbol("ICommandPaletteActionProvider"),
        ICommandPaletteActionProviderRegistry: Symbol("ICommandPaletteActionProviderRegistry"),
        CommandRegistration: Symbol("CommandRegistration"),
        ICommandStack: Symbol("ICommandStack"),
        CommandStackOptions: Symbol("CommandStackOptions"),
        ICommandStackProvider: Symbol("ICommandStackProvider"),
        IContextMenuItemProvider: Symbol.for("IContextMenuProvider"),
        IContextMenuProviderRegistry: Symbol.for("IContextMenuProviderRegistry"),
        IContextMenuService: Symbol.for("IContextMenuService"),
        IContextMenuServiceProvider: Symbol.for("IContextMenuServiceProvider"),
        DOMHelper: Symbol("DOMHelper"),
        IDiagramLocker: Symbol("IDiagramLocker"),
        IEdgeRouter: Symbol("IEdgeRouter"),
        IEdgeRoutePostprocessor: Symbol("IEdgeRoutePostprocessor"),
        IEditLabelValidationDecorator: Symbol("IEditLabelValidationDecorator"),
        IEditLabelValidator: Symbol("IEditLabelValidator"),
        HiddenModelViewer: Symbol("HiddenModelViewer"),
        HiddenVNodePostprocessor: Symbol("HiddenVNodeDecorator"),
        HoverState: Symbol("HoverState"),
        KeyListener: Symbol("KeyListener"),
        LayoutRegistration: Symbol("LayoutRegistration"),
        LayoutRegistry: Symbol("LayoutRegistry"),
        Layouter: Symbol("Layouter"),
        LogLevel: Symbol("LogLevel"),
        ILogger: Symbol("ILogger"),
        IModelFactory: Symbol("IModelFactory"),
        IModelLayoutEngine: Symbol("IModelLayoutEngine"),
        ModelRendererFactory: Symbol("ModelRendererFactory"),
        ModelSource: Symbol("ModelSource"),
        ModelSourceProvider: Symbol("ModelSourceProvider"),
        ModelViewer: Symbol("ModelViewer"),
        MouseListener: Symbol("MouseListener"),
        PatcherProvider: Symbol("PatcherProvider"),
        IPopupModelProvider: Symbol("IPopupModelProvider"),
        PopupModelViewer: Symbol("PopupModelViewer"),
        PopupMouseListener: Symbol("PopupMouseListener"),
        PopupVNodePostprocessor: Symbol("PopupVNodeDecorator"),
        SModelElementRegistration: Symbol("SModelElementRegistration"),
        SModelRegistry: Symbol("SModelRegistry"),
        ISnapper: Symbol("ISnapper"),
        SvgExporter: Symbol("SvgExporter"),
        ISvgExportPostprocessor: Symbol("ISvgExportPostprocessor"),
        IUIExtension: Symbol("IUIExtension"),
        UIExtensionRegistry: Symbol("UIExtensionRegistry"),
        IVNodePostprocessor: Symbol("IVNodePostprocessor"),
        ViewRegistration: Symbol("ViewRegistration"),
        ViewRegistry: Symbol("ViewRegistry"),
        IViewer: Symbol("IViewer"),
        ViewerOptions: Symbol("ViewerOptions"),
        IViewerProvider: Symbol("IViewerProvider")
      };
    }
  });

  // ../../node_modules/sprotty/lib/utils/registry.js
  var require_registry = __commonJS({
    "../../node_modules/sprotty/lib/utils/registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiInstanceRegistry = exports.InstanceRegistry = exports.FactoryRegistry = exports.ProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var ProviderRegistry = class ProviderRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, cstr) {
          if (key === void 0)
            throw new Error("Key is undefined");
          if (this.hasKey(key))
            throw new Error("Key is already registered: " + key);
          this.elements.set(key, cstr);
        }
        deregister(key) {
          if (key === void 0)
            throw new Error("Key is undefined");
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingCstr = this.elements.get(key);
          if (existingCstr)
            return new existingCstr(arg);
          else
            return this.missing(key, arg);
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.ProviderRegistry = ProviderRegistry;
      exports.ProviderRegistry = ProviderRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], ProviderRegistry);
      var FactoryRegistry = class FactoryRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
          }
          this.elements.set(key, factory);
        }
        override(key, factory) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          } else if (!this.hasKey(key)) {
            throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
          }
          this.elements.set(key, factory);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key, arg) {
          const existingFactory = this.elements.get(key);
          if (existingFactory) {
            return existingFactory(arg);
          } else {
            return this.missing(key, arg);
          }
        }
        missing(key, arg) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.FactoryRegistry = FactoryRegistry;
      exports.FactoryRegistry = FactoryRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], FactoryRegistry);
      var InstanceRegistry = class InstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          if (this.hasKey(key)) {
            throw new Error(`Key is already registered: ${key}. Use \`overrideModelElement\` instead.`);
          }
          this.elements.set(key, instance);
        }
        override(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          } else if (!this.hasKey(key)) {
            throw new Error(`Key is not registered: ${key}. Use \`configureModelElement\` instead.`);
          }
          this.elements.set(key, instance);
        }
        deregister(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        hasKey(key) {
          return this.elements.has(key);
        }
        get(key) {
          const existingInstance = this.elements.get(key);
          if (existingInstance) {
            return existingInstance;
          } else {
            return this.missing(key);
          }
        }
        missing(key) {
          throw new Error("Unknown registry key: " + key);
        }
      };
      exports.InstanceRegistry = InstanceRegistry;
      exports.InstanceRegistry = InstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], InstanceRegistry);
      var MultiInstanceRegistry = class MultiInstanceRegistry {
        constructor() {
          this.elements = /* @__PURE__ */ new Map();
        }
        register(key, instance) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          const instances = this.elements.get(key);
          if (instances !== void 0) {
            instances.push(instance);
          } else {
            this.elements.set(key, [instance]);
          }
        }
        deregisterAll(key) {
          if (key === void 0) {
            throw new Error("Key is undefined");
          }
          this.elements.delete(key);
        }
        get(key) {
          const existingInstances = this.elements.get(key);
          if (existingInstances !== void 0) {
            return existingInstances;
          } else {
            return [];
          }
        }
      };
      exports.MultiInstanceRegistry = MultiInstanceRegistry;
      exports.MultiInstanceRegistry = MultiInstanceRegistry = __decorate([
        (0, inversify_1.injectable)()
      ], MultiInstanceRegistry);
    }
  });

  // ../../node_modules/sprotty-protocol/lib/utils/geometry.js
  var require_geometry = __commonJS({
    "../../node_modules/sprotty-protocol/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.almostEquals = exports.toRadians = exports.toDegrees = exports.Bounds = exports.isBounds = exports.Dimension = exports.centerOfLine = exports.angleBetweenPoints = exports.angleOfPoint = exports.Point = void 0;
      var object_1 = require_object();
      var Point;
      (function(Point2) {
        Point2.ORIGIN = Object.freeze({
          x: 0,
          y: 0
        });
        function add(p1, p22) {
          return {
            x: p1.x + p22.x,
            y: p1.y + p22.y
          };
        }
        Point2.add = add;
        function subtract(p1, p22) {
          return {
            x: p1.x - p22.x,
            y: p1.y - p22.y
          };
        }
        Point2.subtract = subtract;
        function equals(point1, point2) {
          return point1.x === point2.x && point1.y === point2.y;
        }
        Point2.equals = equals;
        function shiftTowards(point, refPoint, distance) {
          const diff = subtract(refPoint, point);
          const normalized = normalize(diff);
          const shift = { x: normalized.x * distance, y: normalized.y * distance };
          return add(point, shift);
        }
        Point2.shiftTowards = shiftTowards;
        function normalize(point) {
          const mag = magnitude(point);
          if (mag === 0 || mag === 1) {
            return Point2.ORIGIN;
          }
          return {
            x: point.x / mag,
            y: point.y / mag
          };
        }
        Point2.normalize = normalize;
        function magnitude(point) {
          return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }
        Point2.magnitude = magnitude;
        function linear(p0, p1, lambda) {
          return {
            x: (1 - lambda) * p0.x + lambda * p1.x,
            y: (1 - lambda) * p0.y + lambda * p1.y
          };
        }
        Point2.linear = linear;
        function euclideanDistance(a3, b3) {
          const dx = b3.x - a3.x;
          const dy = b3.y - a3.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        Point2.euclideanDistance = euclideanDistance;
        function manhattanDistance(a3, b3) {
          return Math.abs(b3.x - a3.x) + Math.abs(b3.y - a3.y);
        }
        Point2.manhattanDistance = manhattanDistance;
        function maxDistance(a3, b3) {
          return Math.max(Math.abs(b3.x - a3.x), Math.abs(b3.y - a3.y));
        }
        Point2.maxDistance = maxDistance;
        function dotProduct(a3, b3) {
          return a3.x * b3.x + a3.y * b3.y;
        }
        Point2.dotProduct = dotProduct;
      })(Point || (exports.Point = Point = {}));
      function angleOfPoint(p3) {
        return Math.atan2(p3.y, p3.x);
      }
      exports.angleOfPoint = angleOfPoint;
      function angleBetweenPoints(a3, b3) {
        const lengthProduct = Math.sqrt((a3.x * a3.x + a3.y * a3.y) * (b3.x * b3.x + b3.y * b3.y));
        if (isNaN(lengthProduct) || lengthProduct === 0)
          return NaN;
        const dotProduct = a3.x * b3.x + a3.y * b3.y;
        return Math.acos(dotProduct / lengthProduct);
      }
      exports.angleBetweenPoints = angleBetweenPoints;
      function centerOfLine(s3, e2) {
        const b3 = {
          x: s3.x > e2.x ? e2.x : s3.x,
          y: s3.y > e2.y ? e2.y : s3.y,
          width: Math.abs(e2.x - s3.x),
          height: Math.abs(e2.y - s3.y)
        };
        return Bounds.center(b3);
      }
      exports.centerOfLine = centerOfLine;
      var Dimension;
      (function(Dimension2) {
        Dimension2.EMPTY = Object.freeze({
          width: -1,
          height: -1
        });
        function isValid(d3) {
          return d3.width >= 0 && d3.height >= 0;
        }
        Dimension2.isValid = isValid;
      })(Dimension || (exports.Dimension = Dimension = {}));
      function isBounds(element) {
        return (0, object_1.hasOwnProperty)(element, ["x", "y", "width", "height"]);
      }
      exports.isBounds = isBounds;
      var Bounds;
      (function(Bounds2) {
        Bounds2.EMPTY = Object.freeze({
          x: 0,
          y: 0,
          width: -1,
          height: -1
        });
        function combine(b0, b1) {
          if (!Dimension.isValid(b0))
            return Dimension.isValid(b1) ? b1 : Bounds2.EMPTY;
          if (!Dimension.isValid(b1))
            return b0;
          const minX = Math.min(b0.x, b1.x);
          const minY = Math.min(b0.y, b1.y);
          const maxX = Math.max(b0.x + (b0.width >= 0 ? b0.width : 0), b1.x + (b1.width >= 0 ? b1.width : 0));
          const maxY = Math.max(b0.y + (b0.height >= 0 ? b0.height : 0), b1.y + (b1.height >= 0 ? b1.height : 0));
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        Bounds2.combine = combine;
        function translate(b3, p3) {
          return {
            x: b3.x + p3.x,
            y: b3.y + p3.y,
            width: b3.width,
            height: b3.height
          };
        }
        Bounds2.translate = translate;
        function center(b3) {
          return {
            x: b3.x + (b3.width >= 0 ? 0.5 * b3.width : 0),
            y: b3.y + (b3.height >= 0 ? 0.5 * b3.height : 0)
          };
        }
        Bounds2.center = center;
        function includes(b3, p3) {
          return p3.x >= b3.x && p3.x <= b3.x + b3.width && p3.y >= b3.y && p3.y <= b3.y + b3.height;
        }
        Bounds2.includes = includes;
      })(Bounds || (exports.Bounds = Bounds = {}));
      function toDegrees(a3) {
        return a3 * 180 / Math.PI;
      }
      exports.toDegrees = toDegrees;
      function toRadians(a3) {
        return a3 * Math.PI / 180;
      }
      exports.toRadians = toRadians;
      function almostEquals(a3, b3) {
        return Math.abs(a3 - b3) < 1e-3;
      }
      exports.almostEquals = almostEquals;
    }
  });

  // ../../node_modules/sprotty/lib/utils/iterable.js
  var require_iterable = __commonJS({
    "../../node_modules/sprotty/lib/utils/iterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapIterable = exports.filterIterable = exports.DONE_RESULT = exports.toArray = exports.FluentIterableImpl = void 0;
      var FluentIterableImpl = class {
        constructor(startFn, nextFn) {
          this.startFn = startFn;
          this.nextFn = nextFn;
        }
        [Symbol.iterator]() {
          const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
          };
          return iterator;
        }
        filter(callback) {
          return filterIterable(this, callback);
        }
        map(callback) {
          return mapIterable(this, callback);
        }
        forEach(callback) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value !== void 0)
              callback(result.value, index);
            index++;
          } while (!result.done);
        }
        indexOf(element) {
          const iterator = this[Symbol.iterator]();
          let index = 0;
          let result;
          do {
            result = iterator.next();
            if (result.value === element)
              return index;
            index++;
          } while (!result.done);
          return -1;
        }
      };
      exports.FluentIterableImpl = FluentIterableImpl;
      function toArray(input) {
        if (input.constructor === Array) {
          return input;
        }
        const result = [];
        input.forEach((element) => result.push(element));
        return result;
      }
      exports.toArray = toArray;
      exports.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
      function filterIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          let result;
          do {
            result = iterator.next();
          } while (!result.done && !callback(result.value));
          return result;
        });
      }
      exports.filterIterable = filterIterable;
      function mapIterable(input, callback) {
        return new FluentIterableImpl(() => createIterator(input), (iterator) => {
          const { done, value } = iterator.next();
          if (done)
            return exports.DONE_RESULT;
          else
            return { done: false, value: callback(value) };
        });
      }
      exports.mapIterable = mapIterable;
      function createIterator(collection) {
        const method = collection[Symbol.iterator];
        if (typeof method === "function") {
          return method.call(collection);
        }
        const length = collection.length;
        if (typeof length === "number" && length >= 0) {
          return new ArrayIterator(collection);
        }
        return { next: () => exports.DONE_RESULT };
      }
      var ArrayIterator = class {
        constructor(array) {
          this.array = array;
          this.index = 0;
        }
        next() {
          if (this.index < this.array.length)
            return { done: false, value: this.array[this.index++] };
          else
            return exports.DONE_RESULT;
        }
        [Symbol.iterator]() {
          return this;
        }
      };
    }
  });

  // ../../node_modules/sprotty/lib/base/model/smodel.js
  var require_smodel = __commonJS({
    "../../node_modules/sprotty/lib/base/model/smodel.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelIndexImpl = exports.createRandomId = exports.SModelRootImpl = exports.SChildElementImpl = exports.SParentElementImpl = exports.isParent = exports.SModelElementImpl = void 0;
      var geometry_1 = require_geometry();
      var iterable_1 = require_iterable();
      var SModelElementImpl = class {
        get root() {
          let current = this;
          while (current) {
            if (current instanceof SModelRootImpl)
              return current;
            else if (current instanceof SChildElementImpl2)
              current = current.parent;
            else
              current = void 0;
          }
          throw new Error("Element has no root");
        }
        get index() {
          return this.root.index;
        }
        /**
         * A feature is a symbol identifying some functionality that can be enabled or disabled for
         * a model element. The set of supported features is determined by the `features` property.
         */
        hasFeature(feature) {
          return this.features !== void 0 && this.features.has(feature);
        }
      };
      exports.SModelElementImpl = SModelElementImpl;
      function isParent(element) {
        const children = element.children;
        return children !== void 0 && children.constructor === Array;
      }
      exports.isParent = isParent;
      var SParentElementImpl = class extends SModelElementImpl {
        constructor() {
          super(...arguments);
          this.children = [];
        }
        add(child, index) {
          const children = this.children;
          if (index === void 0) {
            children.push(child);
          } else {
            if (index < 0 || index > this.children.length) {
              throw new Error(`Child index ${index} out of bounds (0..${children.length})`);
            }
            children.splice(index, 0, child);
          }
          child.parent = this;
          this.index.add(child);
        }
        remove(child) {
          const children = this.children;
          const i2 = children.indexOf(child);
          if (i2 < 0) {
            throw new Error(`No such child ${child.id}`);
          }
          children.splice(i2, 1);
          this.index.remove(child);
        }
        removeAll(filter) {
          const children = this.children;
          if (filter !== void 0) {
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              if (filter(children[i2])) {
                const child = children.splice(i2, 1)[0];
                this.index.remove(child);
              }
            }
          } else {
            children.forEach((child) => {
              this.index.remove(child);
            });
            children.splice(0, children.length);
          }
        }
        move(child, newIndex) {
          const children = this.children;
          const i2 = children.indexOf(child);
          if (i2 === -1) {
            throw new Error(`No such child ${child.id}`);
          } else {
            if (newIndex < 0 || newIndex > children.length - 1) {
              throw new Error(`Child index ${newIndex} out of bounds (0..${children.length})`);
            }
            children.splice(i2, 1);
            children.splice(newIndex, 0, child);
          }
        }
        /**
         * Transform the given bounds from the local coordinate system of this element to the coordinate
         * system of its parent. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        localToParent(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
        /**
         * Transform the given bounds from the coordinate system of this element's parent to its local
         * coordinate system. This function should consider any transformation that is applied to the
         * view of this element and its contents.
         * The base implementation assumes that this element does not define a local coordinate system,
         * so it leaves the bounds unchanged.
         */
        parentToLocal(point) {
          return (0, geometry_1.isBounds)(point) ? point : { x: point.x, y: point.y, width: -1, height: -1 };
        }
      };
      exports.SParentElementImpl = SParentElementImpl;
      var SChildElementImpl2 = class extends SParentElementImpl {
      };
      exports.SChildElementImpl = SChildElementImpl2;
      var SModelRootImpl = class extends SParentElementImpl {
        constructor(index = new ModelIndexImpl()) {
          super();
          this.canvasBounds = geometry_1.Bounds.EMPTY;
          Object.defineProperty(this, "index", {
            value: index,
            writable: false
          });
        }
      };
      exports.SModelRootImpl = SModelRootImpl;
      var ID_CHARS = "0123456789abcdefghijklmnopqrstuvwxyz";
      function createRandomId(length = 8) {
        let id = "";
        for (let i2 = 0; i2 < length; i2++) {
          id += ID_CHARS.charAt(Math.floor(Math.random() * ID_CHARS.length));
        }
        return id;
      }
      exports.createRandomId = createRandomId;
      var ModelIndexImpl = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            do {
              element.id = createRandomId();
            } while (this.contains(element));
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.add(child);
            }
          }
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (element instanceof SParentElementImpl) {
            for (const child of element.children) {
              this.remove(child);
            }
          }
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getAttachedElements(element) {
          return [];
        }
        all() {
          return (0, iterable_1.mapIterable)(this.id2element, ([key, value]) => value);
        }
      };
      exports.ModelIndexImpl = ModelIndexImpl;
    }
  });

  // ../../node_modules/sprotty/lib/base/model/smodel-factory.js
  var require_smodel_factory = __commonJS({
    "../../node_modules/sprotty/lib/base/model/smodel-factory.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createFeatureSet = exports.EMPTY_ROOT = exports.SModelFactory = exports.SModelRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var smodel_1 = require_smodel();
      var SModelRegistry = class SModelRegistry extends registry_1.FactoryRegistry {
        constructor(registrations) {
          super();
          registrations.forEach((registration) => {
            let defaultFeatures = this.getDefaultFeatures(registration.constr);
            if (!defaultFeatures && registration.features && registration.features.enable)
              defaultFeatures = [];
            if (defaultFeatures) {
              const featureSet = createFeatureSet(defaultFeatures, registration.features);
              if (registration.isOverride) {
                this.override(registration.type, () => {
                  const element = new registration.constr();
                  element.features = featureSet;
                  return element;
                });
              } else {
                this.register(registration.type, () => {
                  const element = new registration.constr();
                  element.features = featureSet;
                  return element;
                });
              }
            } else {
              if (registration.isOverride) {
                this.override(registration.type, () => new registration.constr());
              } else {
                this.register(registration.type, () => new registration.constr());
              }
            }
          });
        }
        getDefaultFeatures(constr) {
          let obj = constr;
          do {
            const defaultFeatures = obj.DEFAULT_FEATURES;
            if (defaultFeatures)
              return defaultFeatures;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return void 0;
        }
      };
      exports.SModelRegistry = SModelRegistry;
      exports.SModelRegistry = SModelRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.SModelElementRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], SModelRegistry);
      var SModelFactory = class SModelFactory {
        createElement(schema, parent) {
          let child;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SChildElementImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SChildElement.`);
            child = regElement;
          } else {
            child = new smodel_1.SChildElementImpl();
          }
          return this.initializeChild(child, schema, parent);
        }
        createRoot(schema) {
          let root;
          if (this.registry.hasKey(schema.type)) {
            const regElement = this.registry.get(schema.type, void 0);
            if (!(regElement instanceof smodel_1.SModelRootImpl))
              throw new Error(`Element with type ${schema.type} was expected to be an SModelRoot.`);
            root = regElement;
          } else {
            root = new smodel_1.SModelRootImpl();
          }
          return this.initializeRoot(root, schema);
        }
        createSchema(element) {
          const schema = {};
          for (const key in element) {
            if (!this.isReserved(element, key)) {
              const value = element[key];
              if (typeof value !== "function")
                schema[key] = value;
            }
          }
          if (element instanceof smodel_1.SParentElementImpl)
            schema["children"] = element.children.map((child) => this.createSchema(child));
          return schema;
        }
        initializeElement(element, schema) {
          for (const key in schema) {
            if (!this.isReserved(element, key)) {
              const value = schema[key];
              if (typeof value !== "function")
                element[key] = value;
            }
          }
          return element;
        }
        isReserved(element, propertyName) {
          if (["children", "parent", "index"].indexOf(propertyName) >= 0)
            return true;
          let obj = element;
          do {
            const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
            if (descriptor !== void 0)
              return descriptor.get !== void 0;
            obj = Object.getPrototypeOf(obj);
          } while (obj);
          return false;
        }
        initializeParent(parent, schema) {
          this.initializeElement(parent, schema);
          if ((0, smodel_1.isParent)(schema)) {
            parent.children = schema.children.map((childSchema) => this.createElement(childSchema, parent));
          }
          return parent;
        }
        initializeChild(child, schema, parent) {
          this.initializeParent(child, schema);
          if (parent !== void 0) {
            child.parent = parent;
          }
          return child;
        }
        initializeRoot(root, schema) {
          this.initializeParent(root, schema);
          root.index.add(root);
          return root;
        }
      };
      exports.SModelFactory = SModelFactory;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SModelRegistry),
        __metadata("design:type", SModelRegistry)
      ], SModelFactory.prototype, "registry", void 0);
      exports.SModelFactory = SModelFactory = __decorate([
        (0, inversify_1.injectable)()
      ], SModelFactory);
      exports.EMPTY_ROOT = Object.freeze({
        type: "NONE",
        id: "EMPTY"
      });
      function createFeatureSet(defaults, custom) {
        const featureSet = new Set(defaults);
        if (custom && custom.enable) {
          for (const f3 of custom.enable) {
            featureSet.add(f3);
          }
        }
        if (custom && custom.disable) {
          for (const f3 of custom.disable) {
            featureSet.delete(f3);
          }
        }
        return featureSet;
      }
      exports.createFeatureSet = createFeatureSet;
    }
  });

  // ../../node_modules/sprotty/lib/base/animations/animation-frame-syncer.js
  var require_animation_frame_syncer = __commonJS({
    "../../node_modules/sprotty/lib/base/animations/animation-frame-syncer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameSyncer = void 0;
      var inversify_1 = require_cjs4();
      var AnimationFrameSyncer = class AnimationFrameSyncer {
        constructor() {
          this.tasks = [];
          this.endTasks = [];
          this.triggered = false;
        }
        isAvailable() {
          return typeof requestAnimationFrame === "function";
        }
        onNextFrame(task) {
          this.tasks.push(task);
          this.trigger();
        }
        onEndOfNextFrame(task) {
          this.endTasks.push(task);
          this.trigger();
        }
        trigger() {
          if (!this.triggered) {
            this.triggered = true;
            if (this.isAvailable())
              requestAnimationFrame((time) => this.run(time));
            else
              setTimeout((time) => this.run(time));
          }
        }
        run(time) {
          const tasks = this.tasks;
          const endTasks = this.endTasks;
          this.triggered = false;
          this.tasks = [];
          this.endTasks = [];
          tasks.forEach((task) => task.call(void 0, time));
          endTasks.forEach((task) => task.call(void 0, time));
        }
      };
      exports.AnimationFrameSyncer = AnimationFrameSyncer;
      exports.AnimationFrameSyncer = AnimationFrameSyncer = __decorate([
        (0, inversify_1.injectable)()
      ], AnimationFrameSyncer);
    }
  });

  // ../../node_modules/sprotty/lib/base/actions/action-dispatcher.js
  var require_action_dispatcher = __commonJS({
    "../../node_modules/sprotty/lib/base/actions/action-dispatcher.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ActionDispatcher = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      (0, actions_1.setRequestContext)("client");
      var ActionDispatcher = class ActionDispatcher {
        constructor() {
          this.postponedActions = [];
          this.requests = /* @__PURE__ */ new Map();
        }
        initialize() {
          if (!this.initialized) {
            this.initialized = this.actionHandlerRegistryProvider().then((registry) => {
              this.actionHandlerRegistry = registry;
              this.handleAction(actions_1.SetModelAction.create(smodel_factory_1.EMPTY_ROOT)).catch(() => {
              });
            });
          }
          return this.initialized;
        }
        /**
         * Dispatch an action by querying all handlers that are registered for its kind.
         * The returned promise is resolved when all handler results (commands or actions)
         * have been processed.
         */
        dispatch(action) {
          return this.initialize().then(() => {
            if (this.blockUntil !== void 0) {
              return this.handleBlocked(action, this.blockUntil);
            } else if (this.diagramLocker.isAllowed(action)) {
              return this.handleAction(action);
            }
            return void 0;
          });
        }
        /**
         * Calls `dispatch` on every action in the given array. The returned promise
         * is resolved when the promises of all `dispatch` calls have been resolved.
         */
        dispatchAll(actions) {
          return Promise.all(actions.map((action) => this.dispatch(action)));
        }
        /**
         * Dispatch a request. The returned promise is resolved when a response with matching
         * identifier is dispatched. That response is _not_ passed to the registered action
         * handlers. Instead, it is the responsibility of the caller of this method to handle
         * the response properly. For example, it can be sent to the registered handlers by
         * passing it again to the `dispatch` method.
         */
        request(action) {
          if (!action.requestId) {
            return Promise.reject(new Error("Request without requestId"));
          }
          const deferred = new async_1.Deferred();
          this.requests.set(action.requestId, deferred);
          this.dispatch(action).catch(() => {
          });
          return deferred.promise;
        }
        handleAction(action) {
          if (action.kind === actions_1.UndoAction.KIND) {
            return this.commandStack.undo().then(() => {
            });
          }
          if (action.kind === actions_1.RedoAction.KIND) {
            return this.commandStack.redo().then(() => {
            });
          }
          if ((0, actions_1.isResponseAction)(action)) {
            const deferred = this.requests.get(action.responseId);
            if (deferred !== void 0) {
              this.requests.delete(action.responseId);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                deferred.reject(new Error(rejectAction.message));
                this.logger.warn(this, `Request with id ${action.responseId} failed.`, rejectAction.message, rejectAction.detail);
              } else {
                deferred.resolve(action);
              }
              return Promise.resolve();
            }
            this.logger.log(this, "No matching request for response", action);
          }
          const handlers = this.actionHandlerRegistry.get(action.kind);
          if (handlers.length === 0) {
            this.logger.warn(this, "Missing handler for action", action);
            const error = new Error(`Missing handler for action '${action.kind}'`);
            if ((0, actions_1.isRequestAction)(action)) {
              const deferred = this.requests.get(action.requestId);
              if (deferred !== void 0) {
                this.requests.delete(action.requestId);
                deferred.reject(error);
              }
            }
            return Promise.reject(error);
          }
          this.logger.log(this, "Handle", action);
          const promises = [];
          for (const handler of handlers) {
            const result = handler.handle(action);
            if ((0, actions_1.isAction)(result)) {
              promises.push(this.dispatch(result));
            } else if (result !== void 0) {
              promises.push(this.commandStack.execute(result));
              this.blockUntil = result.blockUntil;
            }
          }
          return Promise.all(promises);
        }
        handleBlocked(action, predicate) {
          if (predicate(action)) {
            this.blockUntil = void 0;
            const result = this.handleAction(action);
            const actions = this.postponedActions;
            this.postponedActions = [];
            for (const a3 of actions) {
              this.dispatch(a3.action).then(a3.resolve, a3.reject);
            }
            return result;
          } else {
            this.logger.log(this, "Action is postponed due to block condition", action);
            return new Promise((resolve, reject) => {
              this.postponedActions.push({ action, resolve, reject });
            });
          }
        }
      };
      exports.ActionDispatcher = ActionDispatcher;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
      ], ActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandStack),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "commandStack", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ActionDispatcher.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IDiagramLocker),
        __metadata("design:type", Object)
      ], ActionDispatcher.prototype, "diagramLocker", void 0);
      exports.ActionDispatcher = ActionDispatcher = __decorate([
        (0, inversify_1.injectable)()
      ], ActionDispatcher);
    }
  });

  // ../../node_modules/sprotty/lib/utils/inversify.js
  var require_inversify = __commonJS({
    "../../node_modules/sprotty/lib/utils/inversify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isInjectable = void 0;
      function isInjectable(constr) {
        return Reflect.getMetadata("inversify:paramtypes", constr) !== void 0;
      }
      exports.isInjectable = isInjectable;
    }
  });

  // ../../node_modules/sprotty/lib/base/actions/action-handler.js
  var require_action_handler = __commonJS({
    "../../node_modules/sprotty/lib/base/actions/action-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onAction = exports.configureActionHandler = exports.ActionHandlerRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify();
      var ActionHandlerRegistry = class ActionHandlerRegistry extends registry_1.MultiInstanceRegistry {
        constructor(registrations, initializers) {
          super();
          registrations.forEach((registration) => this.register(registration.actionKind, registration.factory()));
          initializers.forEach((initializer) => this.initializeActionHandler(initializer));
        }
        initializeActionHandler(initializer) {
          initializer.initialize(this);
        }
      };
      exports.ActionHandlerRegistry = ActionHandlerRegistry;
      exports.ActionHandlerRegistry = ActionHandlerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ActionHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __param(1, (0, inversify_1.multiInject)(types_1.TYPES.IActionHandlerInitializer)),
        __param(1, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array, Array])
      ], ActionHandlerRegistry);
      function configureActionHandler(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Action handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ActionHandlerRegistration).toDynamicValue((ctx) => ({
          actionKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureActionHandler = configureActionHandler;
      function onAction(context, kind, handle) {
        context.bind(types_1.TYPES.ActionHandlerRegistration).toConstantValue({
          actionKind: kind,
          factory: () => ({ handle })
        });
      }
      exports.onAction = onAction;
    }
  });

  // ../../node_modules/sprotty/lib/base/actions/diagram-locker.js
  var require_diagram_locker = __commonJS({
    "../../node_modules/sprotty/lib/base/actions/diagram-locker.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultDiagramLocker = void 0;
      var inversify_1 = require_cjs4();
      var DefaultDiagramLocker = class DefaultDiagramLocker {
        isAllowed(action) {
          return true;
        }
      };
      exports.DefaultDiagramLocker = DefaultDiagramLocker;
      exports.DefaultDiagramLocker = DefaultDiagramLocker = __decorate([
        (0, inversify_1.injectable)()
      ], DefaultDiagramLocker);
    }
  });

  // ../../node_modules/sprotty/lib/base/animations/easing.js
  var require_easing = __commonJS({
    "../../node_modules/sprotty/lib/base/animations/easing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.easeInOut = void 0;
      function easeInOut(x3) {
        if (x3 < 0.5)
          return x3 * x3 * 2;
        else
          return 1 - (1 - x3) * (1 - x3) * 2;
      }
      exports.easeInOut = easeInOut;
    }
  });

  // ../../node_modules/sprotty/lib/base/animations/animation.js
  var require_animation = __commonJS({
    "../../node_modules/sprotty/lib/base/animations/animation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompoundAnimation = exports.Animation = void 0;
      var easing_1 = require_easing();
      var Animation = class {
        constructor(context, ease = easing_1.easeInOut) {
          this.context = context;
          this.ease = ease;
          this.stopped = false;
        }
        start() {
          this.stopped = false;
          return new Promise((resolve, reject) => {
            let start = void 0;
            let frames = 0;
            const lambda = (time) => {
              frames++;
              let dtime;
              if (start === void 0) {
                start = time;
                dtime = 0;
              } else {
                dtime = time - start;
              }
              const t3 = Math.min(1, dtime / this.context.duration);
              const current = this.tween(this.ease(t3), this.context);
              this.context.modelChanged.update(current);
              if (t3 === 1) {
                this.context.logger.log(this, frames * 1e3 / this.context.duration + " fps");
                resolve(current);
              } else if (this.stopped) {
                this.context.logger.log(this, "Animation stopped at " + t3 * 100 + "%");
                resolve(current);
              } else {
                this.context.syncer.onNextFrame(lambda);
              }
            };
            if (this.context.syncer.isAvailable()) {
              this.context.syncer.onNextFrame(lambda);
            } else {
              const finalModel = this.tween(1, this.context);
              resolve(finalModel);
            }
          });
        }
        /**
         * Stop the animation at the current state.
         * The promise returned by start() will be resolved with the current state after the next tweening step.
         */
        stop() {
          this.stopped = true;
        }
      };
      exports.Animation = Animation;
      var CompoundAnimation = class extends Animation {
        constructor(model, context, components = [], ease = easing_1.easeInOut) {
          super(context, ease);
          this.model = model;
          this.context = context;
          this.components = components;
          this.ease = ease;
        }
        include(animation) {
          this.components.push(animation);
          return this;
        }
        tween(t3, context) {
          for (const a3 of this.components) {
            a3.tween(t3, context);
          }
          return this.model;
        }
      };
      exports.CompoundAnimation = CompoundAnimation;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/action-handler.js
  var require_action_handler2 = __commonJS({
    "../../node_modules/sprotty-protocol/lib/action-handler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ServerActionHandlerRegistry = void 0;
      var ServerActionHandlerRegistry = class {
        constructor() {
          this.handlers = /* @__PURE__ */ new Map();
        }
        /**
         * Returns the action handlers for the given action kind, or `undefined` if there are none.
         */
        getHandler(kind) {
          return this.handlers.get(kind);
        }
        /**
         * Add an action handler to be called when an action of the specified kind is received.
         */
        onAction(kind, handler) {
          if (this.handlers.has(kind)) {
            this.handlers.get(kind).push(handler);
          } else {
            this.handlers.set(kind, [handler]);
          }
        }
        /**
         * Remove an action handler that was previously added with `onAction`.
         */
        removeActionHandler(kind, handler) {
          const list = this.handlers.get(kind);
          if (list) {
            const index = list.indexOf(handler);
            if (index >= 0) {
              list.splice(index, 1);
            }
          }
        }
      };
      exports.ServerActionHandlerRegistry = ServerActionHandlerRegistry;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/utils/model-utils.js
  var require_model_utils = __commonJS({
    "../../node_modules/sprotty-protocol/lib/utils/model-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
      function cloneModel(model) {
        return JSON.parse(JSON.stringify(model));
      }
      exports.cloneModel = cloneModel;
      function applyBounds(root, action) {
        const index = new SModelIndex();
        index.add(root);
        for (const b3 of action.bounds) {
          const element = index.getById(b3.elementId);
          if (element) {
            const bae = element;
            if (b3.newPosition) {
              bae.position = { x: b3.newPosition.x, y: b3.newPosition.y };
            }
            if (b3.newSize) {
              bae.size = { width: b3.newSize.width, height: b3.newSize.height };
            }
          }
        }
        if (action.alignments) {
          for (const a3 of action.alignments) {
            const element = index.getById(a3.elementId);
            if (element) {
              const alignable = element;
              alignable.alignment = { x: a3.newAlignment.x, y: a3.newAlignment.y };
            }
          }
        }
      }
      exports.applyBounds = applyBounds;
      function getBasicType(element) {
        if (!element.type) {
          return "";
        }
        const colonIndex = element.type.indexOf(":");
        return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
      }
      exports.getBasicType = getBasicType;
      function getSubType(schema) {
        if (!schema.type) {
          return "";
        }
        const colonIndex = schema.type.indexOf(":");
        return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
      }
      exports.getSubType = getSubType;
      function findElement(parent, elementId) {
        if (parent.id === elementId) {
          return parent;
        }
        if (parent.children) {
          for (const child of parent.children) {
            const result = findElement(child, elementId);
            if (result !== void 0) {
              return result;
            }
          }
        }
        return void 0;
      }
      exports.findElement = findElement;
      var SModelIndex = class {
        constructor() {
          this.id2element = /* @__PURE__ */ new Map();
          this.id2parent = /* @__PURE__ */ new Map();
        }
        add(element) {
          if (!element.id) {
            throw new Error("Model element has no ID.");
          } else if (this.contains(element)) {
            throw new Error("Duplicate ID in model: " + element.id);
          }
          this.id2element.set(element.id, element);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.add(child);
              this.id2parent.set(child.id, element);
            }
          }
          return this;
        }
        remove(element) {
          this.id2element.delete(element.id);
          if (Array.isArray(element.children)) {
            for (const child of element.children) {
              this.id2parent.delete(child.id);
              this.remove(child);
            }
          }
          return this;
        }
        contains(element) {
          return this.id2element.has(element.id);
        }
        getById(id) {
          return this.id2element.get(id);
        }
        getParent(id) {
          return this.id2parent.get(id);
        }
        getRoot(element) {
          let current = element;
          while (current) {
            const parent = this.id2parent.get(current.id);
            if (parent === void 0) {
              return current;
            }
            current = parent;
          }
          throw new Error("Element has no root");
        }
      };
      exports.SModelIndex = SModelIndex;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/diagram-server.js
  var require_diagram_server = __commonJS({
    "../../node_modules/sprotty-protocol/lib/diagram-server.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServer = void 0;
      var actions_1 = require_actions();
      var async_1 = require_async2();
      var model_utils_1 = require_model_utils();
      var DiagramServer = class {
        constructor(dispatch, services) {
          this.state = {
            currentRoot: {
              type: "NONE",
              id: "ROOT"
            },
            revision: 0
          };
          this.requests = /* @__PURE__ */ new Map();
          this.dispatch = dispatch;
          this.diagramGenerator = services.DiagramGenerator;
          this.layoutEngine = services.ModelLayoutEngine;
          this.actionHandlerRegistry = services.ServerActionHandlerRegistry;
        }
        /**
         * Set the model and submit it to the client.
         */
        setModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        /**
         * Update the model to a new state and submit it to the client.
         */
        updateModel(newRoot) {
          newRoot.revision = ++this.state.revision;
          this.state.currentRoot = newRoot;
          return this.submitModel(newRoot, true);
        }
        /**
         * Whether the client needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs client layout, the default value
         * is `true`.
         */
        get needsClientLayout() {
          if (this.state.options && this.state.options.needsClientLayout !== void 0) {
            return !!this.state.options.needsClientLayout;
          }
          return true;
        }
        /**
         * Whether the server needs to compute the layout of parts of the model. This affects the behavior
         * of `submitModel`.
         *
         * This setting is determined by the `DiagramOptions` that are received with the `RequestModelAction`
         * from the client. If the client does not specify whether it needs server layout, the default value
         * is `false`.
         */
        get needsServerLayout() {
          if (this.state.options && this.state.options.needsServerLayout !== void 0) {
            return !!this.state.options.needsServerLayout;
          }
          return false;
        }
        /**
         * Called when an action is received from the client.
         */
        accept(action) {
          if ((0, actions_1.isResponseAction)(action)) {
            const id = action.responseId;
            const future = this.requests.get(id);
            if (future) {
              this.requests.delete(id);
              if (action.kind === actions_1.RejectAction.KIND) {
                const rejectAction = action;
                future.reject(new Error(rejectAction.message));
                console.warn(`Request with id ${action.responseId} failed: ${rejectAction.message}`, rejectAction.detail);
              } else {
                future.resolve(action);
              }
              return Promise.resolve();
            }
            console.info("No matching request for response:", action);
          }
          return this.handleAction(action);
        }
        /**
         * Send a request action to the client. The resulting promise is resolved when a matching
         * response is received and rejected when a `RejectAction` is received.
         */
        request(action) {
          if (!action.requestId) {
            action.requestId = "server_" + (0, actions_1.generateRequestId)();
          }
          const future = new async_1.Deferred();
          this.requests.set(action.requestId, future);
          this.dispatch(action).catch((err) => {
            this.requests.delete(action.requestId);
            future.reject(err);
          });
          return future.promise;
        }
        /**
         * Send a `RejectAction` to the client to notify that a request could not be fulfilled.
         */
        rejectRemoteRequest(action, error) {
          if (action && (0, actions_1.isRequestAction)(action)) {
            this.dispatch({
              kind: actions_1.RejectAction.KIND,
              responseId: action.requestId,
              message: error.message,
              detail: error.stack
            });
          }
        }
        handleAction(action) {
          var _a4, _b2;
          const handlers = (_a4 = this.actionHandlerRegistry) === null || _a4 === void 0 ? void 0 : _a4.getHandler(action.kind);
          if (handlers && handlers.length === 1) {
            return (_b2 = handlers[0](action, this.state, this)) !== null && _b2 !== void 0 ? _b2 : Promise.resolve();
          } else if (handlers && handlers.length > 1) {
            return Promise.all(handlers.map((h4) => {
              var _a5;
              return (_a5 = h4(action, this.state, this)) !== null && _a5 !== void 0 ? _a5 : Promise.resolve();
            }));
          }
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.LayoutAction.KIND:
              return this.handleLayout(action);
          }
          console.warn(`Unhandled action from client: ${action.kind}`);
          return Promise.resolve();
        }
        async handleRequestModel(action) {
          var _a4;
          this.state.options = action.options;
          try {
            const newRoot = await this.diagramGenerator.generate({
              options: (_a4 = this.state.options) !== null && _a4 !== void 0 ? _a4 : {},
              state: this.state
            });
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
            await this.submitModel(this.state.currentRoot, false, action);
          } catch (err) {
            this.rejectRemoteRequest(action, err);
            console.error("Failed to generate diagram:", err);
          }
        }
        /**
         * Submit a model to the client after it has been updated in the server state.
         */
        async submitModel(newRoot, update, cause) {
          if (this.needsClientLayout) {
            if (!this.needsServerLayout) {
              this.dispatch({ kind: actions_1.RequestBoundsAction.KIND, newRoot });
            } else {
              const request = actions_1.RequestBoundsAction.create(newRoot);
              const response = await this.request(request);
              const currentRoot = this.state.currentRoot;
              if (response.revision === currentRoot.revision) {
                (0, model_utils_1.applyBounds)(currentRoot, response);
                await this.doSubmitModel(currentRoot, update, cause);
              } else {
                this.rejectRemoteRequest(cause, new Error(`Model revision does not match: ${response.revision}`));
              }
            }
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        async doSubmitModel(newRoot, update, cause) {
          if (newRoot.revision !== this.state.revision) {
            return;
          }
          if (this.needsServerLayout && this.layoutEngine) {
            newRoot = await this.layoutEngine.layout(newRoot);
          }
          const modelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND) {
            const requestId = cause.requestId;
            const response = actions_1.SetModelAction.create(newRoot, requestId);
            await this.dispatch(response);
          } else if (update && modelType === this.state.lastSubmittedModelType) {
            await this.dispatch({ kind: actions_1.UpdateModelAction.KIND, newRoot, cause });
          } else {
            await this.dispatch({ kind: actions_1.SetModelAction.KIND, newRoot });
          }
          this.state.lastSubmittedModelType = modelType;
        }
        handleComputedBounds(action) {
          if (action.revision !== this.state.currentRoot.revision) {
            return Promise.reject();
          }
          (0, model_utils_1.applyBounds)(this.state.currentRoot, action);
          return Promise.resolve();
        }
        async handleLayout(action) {
          if (!this.layoutEngine) {
            return;
          }
          if (!this.needsServerLayout) {
            let newRoot = (0, model_utils_1.cloneModel)(this.state.currentRoot);
            newRoot = await this.layoutEngine.layout(newRoot);
            newRoot.revision = ++this.state.revision;
            this.state.currentRoot = newRoot;
          }
          await this.doSubmitModel(this.state.currentRoot, true, action);
        }
      };
      exports.DiagramServer = DiagramServer;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/diagram-services.js
  var require_diagram_services = __commonJS({
    "../../node_modules/sprotty-protocol/lib/diagram-services.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/sprotty-protocol/lib/model.js
  var require_model = __commonJS({
    "../../node_modules/sprotty-protocol/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isZoomable = exports.isScrollable = void 0;
      var object_1 = require_object();
      function isScrollable(element) {
        return (0, object_1.hasOwnProperty)(element, "scroll");
      }
      exports.isScrollable = isScrollable;
      function isZoomable(element) {
        return (0, object_1.hasOwnProperty)(element, "zoom");
      }
      exports.isZoomable = isZoomable;
    }
  });

  // ../../node_modules/sprotty-protocol/lib/utils/json.js
  var require_json = __commonJS({
    "../../node_modules/sprotty-protocol/lib/utils/json.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/sprotty-protocol/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/sprotty-protocol/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_action_handler2(), exports);
      __exportStar(require_actions(), exports);
      __exportStar(require_diagram_server(), exports);
      __exportStar(require_diagram_services(), exports);
      __exportStar(require_model(), exports);
      __exportStar(require_async2(), exports);
      __exportStar(require_geometry(), exports);
      __exportStar(require_json(), exports);
      __exportStar(require_model_utils(), exports);
      __exportStar(require_object(), exports);
    }
  });

  // ../../node_modules/sprotty/lib/base/commands/command.js
  var require_command = __commonJS({
    "../../node_modules/sprotty/lib/base/commands/command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResetCommand = exports.SystemCommand = exports.PopupCommand = exports.HiddenCommand = exports.MergeableCommand = exports.Command = exports.isStoppableCommand = void 0;
      require_Reflect();
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      function isStoppableCommand(command) {
        return command && (0, sprotty_protocol_1.hasOwnProperty)(command, "stoppableCommandKey") && "stopExecution" in command && typeof command.stopExecution === "function";
      }
      exports.isStoppableCommand = isStoppableCommand;
      var Command = class Command {
      };
      exports.Command = Command;
      exports.Command = Command = __decorate([
        (0, inversify_1.injectable)()
      ], Command);
      var MergeableCommand = class MergeableCommand extends Command {
        /**
         * Tries to merge the given command with this.
         *
         * @param command
         * @param context
         */
        merge(command, context) {
          return false;
        }
      };
      exports.MergeableCommand = MergeableCommand;
      exports.MergeableCommand = MergeableCommand = __decorate([
        (0, inversify_1.injectable)()
      ], MergeableCommand);
      var HiddenCommand = class HiddenCommand extends Command {
        undo(context) {
          context.logger.error(this, "Cannot undo a hidden command");
          return context.root;
        }
        redo(context) {
          context.logger.error(this, "Cannot redo a hidden command");
          return context.root;
        }
      };
      exports.HiddenCommand = HiddenCommand;
      exports.HiddenCommand = HiddenCommand = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenCommand);
      var PopupCommand = class PopupCommand extends Command {
      };
      exports.PopupCommand = PopupCommand;
      exports.PopupCommand = PopupCommand = __decorate([
        (0, inversify_1.injectable)()
      ], PopupCommand);
      var SystemCommand = class SystemCommand extends Command {
      };
      exports.SystemCommand = SystemCommand;
      exports.SystemCommand = SystemCommand = __decorate([
        (0, inversify_1.injectable)()
      ], SystemCommand);
      var ResetCommand = class ResetCommand extends Command {
      };
      exports.ResetCommand = ResetCommand;
      exports.ResetCommand = ResetCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ResetCommand);
    }
  });

  // ../../node_modules/sprotty/lib/base/commands/command-registration.js
  var require_command_registration = __commonJS({
    "../../node_modules/sprotty/lib/base/commands/command-registration.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureCommand = exports.CommandActionHandlerInitializer = exports.CommandActionHandler = void 0;
      var inversify_1 = require_cjs4();
      var inversify_2 = require_inversify();
      var types_1 = require_types();
      var CommandActionHandler = class {
        constructor(commandRegistration) {
          this.commandRegistration = commandRegistration;
        }
        handle(action) {
          return this.commandRegistration.factory(action);
        }
      };
      exports.CommandActionHandler = CommandActionHandler;
      var CommandActionHandlerInitializer = class CommandActionHandlerInitializer {
        constructor(registrations) {
          this.registrations = registrations;
        }
        initialize(registry) {
          this.registrations.forEach((registration) => registry.register(registration.kind, new CommandActionHandler(registration)));
        }
      };
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer;
      exports.CommandActionHandlerInitializer = CommandActionHandlerInitializer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.CommandRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandActionHandlerInitializer);
      function configureCommand(context, constr) {
        if (!(0, inversify_2.isInjectable)(constr)) {
          throw new Error(`Commands should be @injectable: ${constr.name}`);
        }
        if (!context.isBound(constr)) {
          context.bind(constr).toSelf();
        }
        context.bind(types_1.TYPES.CommandRegistration).toDynamicValue((ctx) => ({
          kind: constr.KIND,
          factory: (action) => {
            const childContainer = new inversify_1.Container();
            childContainer.parent = ctx.container;
            childContainer.bind(types_1.TYPES.Action).toConstantValue(action);
            return childContainer.get(constr);
          }
        }));
      }
      exports.configureCommand = configureCommand;
    }
  });

  // ../../node_modules/sprotty/lib/base/commands/command-stack-options.js
  var require_command_stack_options = __commonJS({
    "../../node_modules/sprotty/lib/base/commands/command-stack-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideCommandStackOptions = exports.configureCommandStackOptions = exports.defaultCommandStackOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      var defaultCommandStackOptions = () => ({
        defaultDuration: 250,
        undoHistoryLimit: 50
      });
      exports.defaultCommandStackOptions = defaultCommandStackOptions;
      function configureCommandStackOptions(context, options) {
        const opt = Object.assign(Object.assign({}, (0, exports.defaultCommandStackOptions)()), options);
        if (context.isBound(types_1.TYPES.CommandStackOptions)) {
          context.rebind(types_1.TYPES.CommandStackOptions).toConstantValue(opt);
        } else {
          context.bind(types_1.TYPES.CommandStackOptions).toConstantValue(opt);
        }
      }
      exports.configureCommandStackOptions = configureCommandStackOptions;
      function overrideCommandStackOptions(container, options) {
        const defaultOptions = container.get(types_1.TYPES.CommandStackOptions);
        (0, object_1.safeAssign)(defaultOptions, options);
        return defaultOptions;
      }
      exports.overrideCommandStackOptions = overrideCommandStackOptions;
    }
  });

  // ../../node_modules/sprotty/lib/base/commands/command-stack.js
  var require_command_stack = __commonJS({
    "../../node_modules/sprotty/lib/base/commands/command-stack.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandStack = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_1 = require_smodel();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var command_1 = require_command();
      var CommandStack = class CommandStack {
        constructor() {
          this.undoStack = [];
          this.redoStack = [];
          this.stoppableCommands = /* @__PURE__ */ new Map();
          this.offStack = [];
        }
        initialize() {
          this.currentPromise = Promise.resolve({
            main: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            hidden: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            },
            popup: {
              model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
              modelChanged: false
            }
          });
        }
        get currentModel() {
          return this.currentPromise.then((state) => state.main.model);
        }
        executeAll(commands) {
          commands.forEach((command) => {
            this.logger.log(this, "Executing", command);
            this.handleCommand(command, command.execute, this.mergeOrPush);
          });
          return this.thenUpdate();
        }
        execute(command) {
          this.logger.log(this, "Executing", command);
          this.handleCommand(command, command.execute, this.mergeOrPush);
          return this.thenUpdate();
        }
        undo() {
          this.undoOffStackSystemCommands();
          this.undoPreceedingSystemCommands();
          const command = this.undoStack[this.undoStack.length - 1];
          if (command !== void 0 && !this.isBlockUndo(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c3, context) => {
              this.redoStack.push(c3);
            });
          }
          return this.thenUpdate();
        }
        redo() {
          this.undoOffStackSystemCommands();
          const command = this.redoStack.pop();
          if (command !== void 0) {
            this.logger.log(this, "Redoing", command);
            this.handleCommand(command, command.redo, (c3, context) => {
              this.pushToUndoStack(c3);
            });
          }
          this.redoFollowingSystemCommands();
          return this.thenUpdate();
        }
        /**
         * Chains the current promise with another Promise that performs the
         * given operation on the given command.
         *
         * @param beforeResolve a function that is called directly before
         *      resolving the Promise to return the new model. Usually puts the
         *      command on the appropriate stack.
         */
        handleCommand(command, operation, beforeResolve) {
          if ((0, command_1.isStoppableCommand)(command)) {
            const stoppableCommand = this.stoppableCommands.get(command.stoppableCommandKey);
            if (stoppableCommand) {
              stoppableCommand.stopExecution();
            }
            this.stoppableCommands.set(command.stoppableCommandKey, command);
          }
          this.currentPromise = this.currentPromise.then((state) => new Promise((resolve) => {
            let target;
            if (command instanceof command_1.HiddenCommand)
              target = "hidden";
            else if (command instanceof command_1.PopupCommand)
              target = "popup";
            else
              target = "main";
            const context = this.createContext(state.main.model);
            let commandResult;
            try {
              commandResult = operation.call(command, context);
            } catch (error) {
              this.logger.error(this, "Failed to execute command:", error);
              commandResult = state[target].model;
            }
            const newState = copyState(state);
            if (commandResult instanceof Promise) {
              commandResult.then((newModel) => {
                if (target === "main")
                  beforeResolve.call(this, command, context);
                newState[target] = { model: newModel, modelChanged: true };
                resolve(newState);
              });
            } else if (commandResult instanceof smodel_1.SModelRootImpl) {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = { model: commandResult, modelChanged: true };
              resolve(newState);
            } else {
              if (target === "main")
                beforeResolve.call(this, command, context);
              newState[target] = {
                model: commandResult.model,
                modelChanged: state[target].modelChanged || commandResult.modelChanged,
                cause: commandResult.cause
              };
              resolve(newState);
            }
          }));
        }
        pushToUndoStack(command) {
          this.undoStack.push(command);
          if (this.options.undoHistoryLimit >= 0 && this.undoStack.length > this.options.undoHistoryLimit)
            this.undoStack.splice(0, this.undoStack.length - this.options.undoHistoryLimit);
        }
        /**
         * Notifies the Viewer to render the new model and/or the new hidden model
         * and returns a Promise for the new model.
         */
        thenUpdate() {
          this.currentPromise = this.currentPromise.then((state) => {
            const newState = copyState(state);
            if (state.hidden.modelChanged) {
              this.updateHidden(state.hidden.model, state.hidden.cause);
              newState.hidden.modelChanged = false;
              newState.hidden.cause = void 0;
            }
            if (state.main.modelChanged) {
              this.update(state.main.model, state.main.cause);
              newState.main.modelChanged = false;
              newState.main.cause = void 0;
            }
            if (state.popup.modelChanged) {
              this.updatePopup(state.popup.model, state.popup.cause);
              newState.popup.modelChanged = false;
              newState.popup.cause = void 0;
            }
            return newState;
          });
          return this.currentModel;
        }
        /**
         * Notify the `ModelViewer` that the model has changed.
         */
        update(model, cause) {
          if (this.modelViewer === void 0) {
            this.modelViewer = this.viewerProvider.modelViewer;
          }
          this.modelViewer.update(model, cause);
        }
        /**
         * Notify the `HiddenModelViewer` that the hidden model has changed.
         */
        updateHidden(model, cause) {
          if (this.hiddenModelViewer === void 0) {
            this.hiddenModelViewer = this.viewerProvider.hiddenModelViewer;
          }
          this.hiddenModelViewer.update(model, cause);
        }
        /**
         * Notify the `PopupModelViewer` that the popup model has changed.
         */
        updatePopup(model, cause) {
          if (this.popupModelViewer === void 0) {
            this.popupModelViewer = this.viewerProvider.popupModelViewer;
          }
          this.popupModelViewer.update(model, cause);
        }
        /**
         * Handling of commands after their execution.
         *
         * Hidden commands are not pushed to any stack.
         *
         * System commands are pushed to the <code>offStack</code> when the redo
         * stack is not empty, allowing to undo the before a redo to keep the chain
         * of commands consistent.
         *
         * Mergable commands are merged if possible.
         */
        mergeOrPush(command, context) {
          if (this.isBlockUndo(command)) {
            this.undoStack = [];
            this.redoStack = [];
            this.offStack = [];
            this.pushToUndoStack(command);
            return;
          }
          if (this.isPushToOffStack(command) && this.redoStack.length > 0) {
            if (this.offStack.length > 0) {
              const lastCommand = this.offStack[this.offStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.offStack.push(command);
            return;
          }
          if (this.isPushToUndoStack(command)) {
            this.offStack.forEach((c3) => this.undoStack.push(c3));
            this.offStack = [];
            this.redoStack = [];
            if (this.undoStack.length > 0) {
              const lastCommand = this.undoStack[this.undoStack.length - 1];
              if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                return;
            }
            this.pushToUndoStack(command);
          }
        }
        /**
         * Reverts all system commands on the offStack.
         */
        undoOffStackSystemCommands() {
          let command = this.offStack.pop();
          while (command !== void 0) {
            this.logger.log(this, "Undoing off-stack", command);
            this.handleCommand(command, command.undo, () => {
            });
            command = this.offStack.pop();
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>undo()</code> to revert all system commands
         * at the top of the undoStack.
         */
        undoPreceedingSystemCommands() {
          let command = this.undoStack[this.undoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.undoStack.pop();
            this.logger.log(this, "Undoing", command);
            this.handleCommand(command, command.undo, (c3, context) => {
              this.redoStack.push(c3);
            });
            command = this.undoStack[this.undoStack.length - 1];
          }
        }
        /**
         * System commands should be transparent to the user, so this method
         * is called from <code>redo()</code> to re-execute all system commands
         * at the top of the redoStack.
         */
        redoFollowingSystemCommands() {
          let command = this.redoStack[this.redoStack.length - 1];
          while (command !== void 0 && this.isPushToOffStack(command)) {
            this.redoStack.pop();
            this.logger.log(this, "Redoing ", command);
            this.handleCommand(command, command.redo, (c3, context) => {
              this.pushToUndoStack(c3);
            });
            command = this.redoStack[this.redoStack.length - 1];
          }
        }
        /**
         * Assembles the context object that is passed to the commands execution method.
         */
        createContext(currentModel) {
          return {
            root: currentModel,
            modelChanged: this,
            modelFactory: this.modelFactory,
            duration: this.options.defaultDuration,
            logger: this.logger,
            syncer: this.syncer
          };
        }
        isPushToOffStack(command) {
          return command instanceof command_1.SystemCommand;
        }
        isPushToUndoStack(command) {
          return !(command instanceof command_1.HiddenCommand);
        }
        isBlockUndo(command) {
          return command instanceof command_1.ResetCommand;
        }
      };
      exports.CommandStack = CommandStack;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelFactory),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "modelFactory", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewerProvider),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "viewerProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], CommandStack.prototype, "syncer", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.CommandStackOptions),
        __metadata("design:type", Object)
      ], CommandStack.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.postConstruct)(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
      ], CommandStack.prototype, "initialize", null);
      exports.CommandStack = CommandStack = __decorate([
        (0, inversify_1.injectable)()
      ], CommandStack);
      function copyState(state) {
        return {
          main: Object.assign({}, state.main),
          hidden: Object.assign({}, state.hidden),
          popup: Object.assign({}, state.popup)
        };
      }
    }
  });

  // ../../node_modules/sprotty/lib/utils/browser.js
  var require_browser = __commonJS({
    "../../node_modules/sprotty/lib/utils/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSVGGraphicsElement = exports.hitsMouseEvent = exports.getWindowScroll = exports.isCrossSite = exports.isMac = exports.isCtrlOrCmd = void 0;
      var sprotty_protocol_1 = require_lib();
      function isCtrlOrCmd(event) {
        if (isMac())
          return event.metaKey;
        else
          return event.ctrlKey;
      }
      exports.isCtrlOrCmd = isCtrlOrCmd;
      function isMac() {
        return window.navigator.userAgent.indexOf("Mac") !== -1;
      }
      exports.isMac = isMac;
      function isCrossSite(url) {
        if (url && typeof window !== "undefined" && window.location) {
          let baseURL = "";
          if (window.location.protocol)
            baseURL += window.location.protocol + "//";
          if (window.location.host)
            baseURL += window.location.host;
          return baseURL.length > 0 && !url.startsWith(baseURL);
        }
        return false;
      }
      exports.isCrossSite = isCrossSite;
      function getWindowScroll() {
        if (typeof window === "undefined") {
          return sprotty_protocol_1.Point.ORIGIN;
        }
        return {
          x: window.pageXOffset,
          y: window.pageYOffset
        };
      }
      exports.getWindowScroll = getWindowScroll;
      function hitsMouseEvent(child, event) {
        const clientRect = child.getBoundingClientRect();
        return event.clientX >= clientRect.left && event.clientX <= clientRect.right && event.clientY >= clientRect.top && event.clientY <= clientRect.bottom;
      }
      exports.hitsMouseEvent = hitsMouseEvent;
      function isSVGGraphicsElement(node) {
        return typeof node.getBBox === "function";
      }
      exports.isSVGGraphicsElement = isSVGGraphicsElement;
    }
  });

  // ../../node_modules/sprotty/lib/base/features/initialize-canvas.js
  var require_initialize_canvas = __commonJS({
    "../../node_modules/sprotty/lib/base/features/initialize-canvas.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InitializeCanvasBoundsCommand = exports.InitializeCanvasBoundsAction = exports.CanvasBoundsInitializer = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var browser_1 = require_browser();
      var CanvasBoundsInitializer = class CanvasBoundsInitializer {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl && !geometry_1.Dimension.isValid(element.canvasBounds)) {
            this.rootAndVnode = [element, vnode];
          }
          return vnode;
        }
        postUpdate() {
          if (this.rootAndVnode !== void 0) {
            const domElement = this.rootAndVnode[1].elm;
            const oldBounds = this.rootAndVnode[0].canvasBounds;
            if (domElement !== void 0) {
              const newBounds = this.getBoundsInPage(domElement);
              if (!((0, geometry_1.almostEquals)(newBounds.x, oldBounds.x) && (0, geometry_1.almostEquals)(newBounds.y, oldBounds.y) && (0, geometry_1.almostEquals)(newBounds.width, oldBounds.width) && (0, geometry_1.almostEquals)(newBounds.height, oldBounds.width)))
                this.actionDispatcher.dispatch(InitializeCanvasBoundsAction.create(newBounds));
            }
            this.rootAndVnode = void 0;
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], CanvasBoundsInitializer.prototype, "actionDispatcher", void 0);
      exports.CanvasBoundsInitializer = CanvasBoundsInitializer = __decorate([
        (0, inversify_1.injectable)()
      ], CanvasBoundsInitializer);
      var InitializeCanvasBoundsAction;
      (function(InitializeCanvasBoundsAction2) {
        InitializeCanvasBoundsAction2.KIND = "initializeCanvasBounds";
        function create(newCanvasBounds) {
          return {
            kind: InitializeCanvasBoundsAction2.KIND,
            newCanvasBounds
          };
        }
        InitializeCanvasBoundsAction2.create = create;
      })(InitializeCanvasBoundsAction || (exports.InitializeCanvasBoundsAction = InitializeCanvasBoundsAction = {}));
      var InitializeCanvasBoundsCommand = class InitializeCanvasBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newCanvasBounds = this.action.newCanvasBounds;
          context.root.canvasBounds = this.newCanvasBounds;
          return context.root;
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand;
      InitializeCanvasBoundsCommand.KIND = InitializeCanvasBoundsAction.KIND;
      exports.InitializeCanvasBoundsCommand = InitializeCanvasBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], InitializeCanvasBoundsCommand);
    }
  });

  // ../../node_modules/sprotty/lib/base/features/set-model.js
  var require_set_model = __commonJS({
    "../../node_modules/sprotty/lib/base/features/set-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetModelCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var SetModelCommand = class SetModelCommand extends command_1.ResetCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.modelFactory.createRoot(context.root);
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
        get blockUntil() {
          return (action) => action.kind === initialize_canvas_1.InitializeCanvasBoundsCommand.KIND;
        }
      };
      exports.SetModelCommand = SetModelCommand;
      SetModelCommand.KIND = actions_1.SetModelAction.KIND;
      exports.SetModelCommand = SetModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetModelCommand);
    }
  });

  // ../../node_modules/sprotty/lib/base/model/smodel-utils.js
  var require_smodel_utils = __commonJS({
    "../../node_modules/sprotty/lib/base/model/smodel-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.transformToRootBounds = exports.containsSome = exports.translateBounds = exports.translatePoint = exports.findParentByFeature = exports.findParent = exports.registerModelElement = void 0;
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      function registerModelElement(context, type, constr, features, isOverride) {
        context.bind(types_1.TYPES.SModelElementRegistration).toConstantValue({
          type,
          constr,
          features,
          isOverride
        });
      }
      exports.registerModelElement = registerModelElement;
      function findParent(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParent = findParent;
      function findParentByFeature(element, predicate) {
        let current = element;
        while (current !== void 0) {
          if (predicate(current))
            return current;
          else if (current instanceof smodel_1.SChildElementImpl)
            current = current.parent;
          else
            current = void 0;
        }
        return current;
      }
      exports.findParentByFeature = findParentByFeature;
      function translatePoint(point, source, target) {
        if (source !== target) {
          while (source instanceof smodel_1.SChildElementImpl) {
            point = source.localToParent(point);
            source = source.parent;
            if (source === target)
              return point;
          }
          const targetTrace = [];
          while (target instanceof smodel_1.SChildElementImpl) {
            targetTrace.push(target);
            target = target.parent;
          }
          if (source !== target)
            throw new Error("Incompatible source and target: " + source.id + ", " + target.id);
          for (let i2 = targetTrace.length - 1; i2 >= 0; i2--) {
            point = targetTrace[i2].parentToLocal(point);
          }
        }
        return point;
      }
      exports.translatePoint = translatePoint;
      function translateBounds(bounds, source, target) {
        const upperLeft = translatePoint(bounds, source, target);
        const lowerRight = translatePoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, source, target);
        return {
          x: upperLeft.x,
          y: upperLeft.y,
          width: lowerRight.x - upperLeft.x,
          height: lowerRight.y - upperLeft.y
        };
      }
      exports.translateBounds = translateBounds;
      function containsSome(root, element) {
        const test = (el) => root.index.getById(el.id) !== void 0;
        const find = (elements) => elements.some((el) => test(el) || find(el.children));
        return find([element]);
      }
      exports.containsSome = containsSome;
      function transformToRootBounds(parent, bounds) {
        while (parent instanceof smodel_1.SChildElementImpl) {
          bounds = parent.localToParent(bounds);
          parent = parent.parent;
        }
        return bounds;
      }
      exports.transformToRootBounds = transformToRootBounds;
    }
  });

  // ../../node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js
  var require_ui_extension_registry = __commonJS({
    "../../node_modules/sprotty/lib/base/ui-extensions/ui-extension-registry.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SetUIExtensionVisibilityCommand = exports.SetUIExtensionVisibilityAction = exports.UIExtensionRegistry = void 0;
      var inversify_1 = require_cjs4();
      var registry_1 = require_registry();
      var command_1 = require_command();
      var types_1 = require_types();
      var UIExtensionRegistry = class UIExtensionRegistry extends registry_1.InstanceRegistry {
        constructor(extensions = []) {
          super();
          extensions.forEach((extension) => this.register(extension.id(), extension));
        }
      };
      exports.UIExtensionRegistry = UIExtensionRegistry;
      exports.UIExtensionRegistry = UIExtensionRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IUIExtension)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], UIExtensionRegistry);
      var SetUIExtensionVisibilityAction;
      (function(SetUIExtensionVisibilityAction2) {
        SetUIExtensionVisibilityAction2.KIND = "setUIExtensionVisibility";
        function create(options) {
          var _a4;
          return {
            kind: SetUIExtensionVisibilityAction2.KIND,
            extensionId: options.extensionId,
            visible: options.visible,
            contextElementsId: (_a4 = options.contextElementsId) !== null && _a4 !== void 0 ? _a4 : []
          };
        }
        SetUIExtensionVisibilityAction2.create = create;
      })(SetUIExtensionVisibilityAction || (exports.SetUIExtensionVisibilityAction = SetUIExtensionVisibilityAction = {}));
      var SetUIExtensionVisibilityCommand = class SetUIExtensionVisibilityCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const extension = this.registry.get(this.action.extensionId);
          if (extension) {
            this.action.visible ? extension.show(context.root, ...this.action.contextElementsId) : extension.hide();
          }
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand;
      SetUIExtensionVisibilityCommand.KIND = SetUIExtensionVisibilityAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.UIExtensionRegistry),
        __metadata("design:type", UIExtensionRegistry)
      ], SetUIExtensionVisibilityCommand.prototype, "registry", void 0);
      exports.SetUIExtensionVisibilityCommand = SetUIExtensionVisibilityCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetUIExtensionVisibilityCommand);
    }
  });

  // ../../node_modules/sprotty/lib/base/ui-extensions/ui-extension.js
  var require_ui_extension = __commonJS({
    "../../node_modules/sprotty/lib/base/ui-extensions/ui-extension.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractUIExtension = exports.isUIExtension = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      var types_1 = require_types();
      function isUIExtension(object) {
        return (0, sprotty_protocol_1.hasOwnProperty)(object, "id", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "show", "function") && (0, sprotty_protocol_1.hasOwnProperty)(object, "hide", "function");
      }
      exports.isUIExtension = isUIExtension;
      var AbstractUIExtension = class AbstractUIExtension {
        show(root, ...contextElementIds) {
          this.activeElement = document.activeElement;
          if (!this.containerElement) {
            if (!this.initialize())
              return;
          }
          this.onBeforeShow(this.containerElement, root, ...contextElementIds);
          this.setContainerVisible(true);
        }
        hide() {
          this.setContainerVisible(false);
          this.restoreFocus();
          this.activeElement = null;
        }
        restoreFocus() {
          const focusedElement = this.activeElement;
          if (focusedElement) {
            focusedElement.focus();
          }
        }
        initialize() {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (!baseDiv) {
            this.logger.warn(this, `Could not obtain sprotty base container for initializing UI extension ${this.id}`, this);
            return false;
          }
          this.containerElement = this.getOrCreateContainer(baseDiv.id);
          this.initializeContents(this.containerElement);
          if (baseDiv) {
            baseDiv.insertBefore(this.containerElement, baseDiv.firstChild);
          }
          return true;
        }
        getOrCreateContainer(baseDivId) {
          let container = document.getElementById(this.id());
          if (container === null) {
            container = document.createElement("div");
            container.id = baseDivId + "_" + this.id();
            container.classList.add(this.containerClass());
          }
          return container;
        }
        setContainerVisible(visible) {
          if (this.containerElement) {
            if (visible) {
              this.containerElement.style.visibility = "visible";
              this.containerElement.style.opacity = "1";
            } else {
              this.containerElement.style.visibility = "hidden";
              this.containerElement.style.opacity = "0";
            }
          }
        }
        /**
         * Updates the `containerElement` under the given `context` before it becomes visible.
         *
         * Subclasses may override this method to, for instance, modifying the position of the
         * `containerElement`, add or remove elements, etc. depending on the specified `root`
         * or `contextElementIds`.
         */
        onBeforeShow(containerElement, root, ...contextElementIds) {
        }
      };
      exports.AbstractUIExtension = AbstractUIExtension;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], AbstractUIExtension.prototype, "logger", void 0);
      exports.AbstractUIExtension = AbstractUIExtension = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractUIExtension);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/vnode-utils.js
  var require_vnode_utils = __commonJS({
    "../../node_modules/sprotty/lib/base/views/vnode-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getAttrs = exports.on = exports.mergeStyle = exports.copyClassesFromElement = exports.copyClassesFromVNode = exports.setNamespace = exports.setClass = exports.setAttr = void 0;
      function setAttr(vnode, name, value) {
        getAttrs(vnode)[name] = value;
      }
      exports.setAttr = setAttr;
      function setClass(vnode, name, value) {
        getClass(vnode)[name] = value;
      }
      exports.setClass = setClass;
      function setNamespace(node, ns) {
        if (node.data === void 0)
          node.data = {};
        node.data.ns = ns;
        const children = node.children;
        if (children !== void 0) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (typeof child !== "string")
              setNamespace(child, ns);
          }
        }
      }
      exports.setNamespace = setNamespace;
      function copyClassesFromVNode(source, target) {
        const classList = getClass(source);
        Object.keys(classList).forEach((c3) => setClass(target, c3, true));
      }
      exports.copyClassesFromVNode = copyClassesFromVNode;
      function copyClassesFromElement(element, target) {
        const classList = element.classList;
        for (let i2 = 0; i2 < classList.length; i2++) {
          const item = classList.item(i2);
          if (item)
            setClass(target, item, true);
        }
      }
      exports.copyClassesFromElement = copyClassesFromElement;
      function mergeStyle(vnode, style) {
        getData(vnode).style = Object.assign(Object.assign({}, getData(vnode).style || {}), style);
      }
      exports.mergeStyle = mergeStyle;
      function on(vnode, event, listener) {
        const val = getOn(vnode);
        if (val[event]) {
          throw new Error("EventListener for " + event + " already registered on VNode");
        }
        val[event] = listener;
      }
      exports.on = on;
      function getAttrs(vnode) {
        const data = getData(vnode);
        if (!data.attrs)
          data.attrs = {};
        return data.attrs;
      }
      exports.getAttrs = getAttrs;
      function getData(vnode) {
        if (!vnode.data)
          vnode.data = {};
        return vnode.data;
      }
      function getClass(vnode) {
        const data = getData(vnode);
        if (!data.class)
          data.class = {};
        return data.class;
      }
      function getOn(vnode) {
        const data = getData(vnode);
        if (!data.on)
          data.on = {};
        return data.on;
      }
    }
  });

  // ../../node_modules/sprotty/lib/base/views/key-tool.js
  var require_key_tool = __commonJS({
    "../../node_modules/sprotty/lib/base/views/key-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.KeyListener = exports.KeyTool = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var KeyTool = class KeyTool {
        constructor(keyListeners = []) {
          this.keyListeners = keyListeners;
        }
        register(keyListener) {
          this.keyListeners.push(keyListener);
        }
        deregister(keyListener) {
          const index = this.keyListeners.indexOf(keyListener);
          if (index >= 0)
            this.keyListeners.splice(index, 1);
        }
        handleEvent(methodName, model, event) {
          const actions = this.keyListeners.map((listener) => listener[methodName].apply(listener, [model, event])).reduce((a3, b3) => a3.concat(b3));
          if (actions.length > 0) {
            event.preventDefault();
            this.actionDispatcher.dispatchAll(actions);
          }
        }
        keyDown(element, event) {
          this.handleEvent("keyDown", element, event);
        }
        keyUp(element, event) {
          this.handleEvent("keyUp", element, event);
        }
        focus() {
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "focus", this.focus.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keydown", this.keyDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "keyup", this.keyUp.bind(this, element));
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.KeyTool = KeyTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], KeyTool.prototype, "actionDispatcher", void 0);
      exports.KeyTool = KeyTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.KeyListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], KeyTool);
      var KeyListener = class KeyListener {
        keyDown(element, event) {
          return [];
        }
        keyUp(element, event) {
          return [];
        }
      };
      exports.KeyListener = KeyListener;
      exports.KeyListener = KeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], KeyListener);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/dom-helper.js
  var require_dom_helper = __commonJS({
    "../../node_modules/sprotty/lib/base/views/dom-helper.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMHelper = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var DOMHelper = class DOMHelper {
        getPrefix() {
          const prefix = this.viewerOptions !== void 0 && this.viewerOptions.baseDiv !== void 0 ? this.viewerOptions.baseDiv + "_" : "";
          return prefix;
        }
        createUniqueDOMElementId(element) {
          return this.getPrefix() + element.id;
        }
        findSModelIdByDOMElement(element) {
          return element.id.replace(this.getPrefix(), "");
        }
      };
      exports.DOMHelper = DOMHelper;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], DOMHelper.prototype, "viewerOptions", void 0);
      exports.DOMHelper = DOMHelper = __decorate([
        (0, inversify_1.injectable)()
      ], DOMHelper);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/mouse-tool.js
  var require_mouse_tool = __commonJS({
    "../../node_modules/sprotty/lib/base/views/mouse-tool.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MousePositionTracker = exports.MouseListener = exports.PopupMouseTool = exports.MouseTool = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var MouseTool = class MouseTool {
        constructor(mouseListeners = []) {
          this.mouseListeners = mouseListeners;
        }
        register(mouseListener) {
          this.mouseListeners.push(mouseListener);
        }
        deregister(mouseListener) {
          const index = this.mouseListeners.indexOf(mouseListener);
          if (index >= 0)
            this.mouseListeners.splice(index, 1);
        }
        getTargetElement(model, event) {
          let target = event.target;
          const index = model.index;
          while (target) {
            if (target.id) {
              const element = index.getById(this.domHelper.findSModelIdByDOMElement(target));
              if (element !== void 0)
                return element;
            }
            target = target.parentNode;
          }
          return void 0;
        }
        handleEvent(methodName, model, event) {
          this.focusOnMouseEvent(methodName, model);
          const element = this.getTargetElement(model, event);
          if (!element)
            return;
          const actions = this.mouseListeners.map((listener) => listener[methodName](element, event)).reduce((a3, b3) => a3.concat(b3));
          if (actions.length > 0) {
            event.preventDefault();
            for (const actionOrPromise of actions) {
              if ((0, actions_1.isAction)(actionOrPromise)) {
                this.actionDispatcher.dispatch(actionOrPromise);
              } else {
                actionOrPromise.then((action) => {
                  this.actionDispatcher.dispatch(action);
                });
              }
            }
          }
        }
        focusOnMouseEvent(methodName, model) {
          if (document && methodName === "mouseDown") {
            const domElement = document.getElementById(this.domHelper.createUniqueDOMElementId(model));
            if (domElement !== null && typeof domElement.focus === "function")
              domElement.focus();
          }
        }
        mouseOver(model, event) {
          this.handleEvent("mouseOver", model, event);
        }
        mouseOut(model, event) {
          this.handleEvent("mouseOut", model, event);
        }
        mouseEnter(model, event) {
          this.handleEvent("mouseEnter", model, event);
        }
        mouseLeave(model, event) {
          this.handleEvent("mouseLeave", model, event);
        }
        mouseDown(model, event) {
          this.handleEvent("mouseDown", model, event);
        }
        mouseMove(model, event) {
          this.handleEvent("mouseMove", model, event);
        }
        mouseUp(model, event) {
          this.handleEvent("mouseUp", model, event);
        }
        wheel(model, event) {
          this.handleEvent("wheel", model, event);
        }
        contextMenu(model, event) {
          event.preventDefault();
          this.handleEvent("contextMenu", model, event);
        }
        doubleClick(model, event) {
          this.handleEvent("doubleClick", model, event);
        }
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl) {
            (0, vnode_utils_1.on)(vnode, "mouseover", this.mouseOver.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseout", this.mouseOut.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseenter", this.mouseEnter.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseleave", this.mouseLeave.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousedown", this.mouseDown.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mouseup", this.mouseUp.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "mousemove", this.mouseMove.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "wheel", this.wheel.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "contextmenu", this.contextMenu.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dblclick", this.doubleClick.bind(this, element));
            (0, vnode_utils_1.on)(vnode, "dragover", (event) => this.handleEvent("dragOver", element, event));
            (0, vnode_utils_1.on)(vnode, "drop", (event) => this.handleEvent("drop", element, event));
          }
          vnode = this.mouseListeners.reduce((n, listener) => listener.decorate(n, element), vnode);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.MouseTool = MouseTool;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], MouseTool.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], MouseTool.prototype, "domHelper", void 0);
      exports.MouseTool = MouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.MouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], MouseTool);
      var PopupMouseTool = class PopupMouseTool extends MouseTool {
        constructor(mouseListeners = []) {
          super(mouseListeners);
          this.mouseListeners = mouseListeners;
        }
      };
      exports.PopupMouseTool = PopupMouseTool;
      exports.PopupMouseTool = PopupMouseTool = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.PopupMouseListener)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], PopupMouseTool);
      var MouseListener = class MouseListener {
        mouseOver(target, event) {
          return [];
        }
        mouseOut(target, event) {
          return [];
        }
        mouseEnter(target, event) {
          return [];
        }
        mouseLeave(target, event) {
          return [];
        }
        mouseDown(target, event) {
          return [];
        }
        mouseMove(target, event) {
          return [];
        }
        mouseUp(target, event) {
          return [];
        }
        wheel(target, event) {
          return [];
        }
        doubleClick(target, event) {
          return [];
        }
        contextMenu(target, event) {
          return [];
        }
        dragOver(target, event) {
          return [];
        }
        drop(target, event) {
          return [];
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MouseListener = MouseListener;
      exports.MouseListener = MouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], MouseListener);
      var MousePositionTracker = class MousePositionTracker extends MouseListener {
        mouseMove(target, event) {
          this.lastPosition = target.root.parentToLocal({ x: event.offsetX, y: event.offsetY });
          return [];
        }
        /**
         * Returns the last tracked mouse cursor position relative to the diagram root or `undefined`
         * if no mouse cursor position was ever tracked yet.
         */
        get lastPositionOnDiagram() {
          return this.lastPosition;
        }
      };
      exports.MousePositionTracker = MousePositionTracker;
      exports.MousePositionTracker = MousePositionTracker = __decorate([
        (0, inversify_1.injectable)()
      ], MousePositionTracker);
    }
  });

  // ../../node_modules/snabbdom/build/snabbdom.cjs.js
  var require_snabbdom_cjs = __commonJS({
    "../../node_modules/snabbdom/build/snabbdom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function createElement(tagName2, options) {
        return document.createElement(tagName2, options);
      }
      function createElementNS(namespaceURI, qualifiedName, options) {
        return document.createElementNS(namespaceURI, qualifiedName, options);
      }
      function createDocumentFragment() {
        return parseFragment(document.createDocumentFragment());
      }
      function createTextNode(text) {
        return document.createTextNode(text);
      }
      function createComment(text) {
        return document.createComment(text);
      }
      function insertBefore(parentNode2, newNode, referenceNode) {
        if (isDocumentFragment$1(parentNode2)) {
          let node = parentNode2;
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          parentNode2 = node !== null && node !== void 0 ? node : parentNode2;
        }
        if (isDocumentFragment$1(newNode)) {
          newNode = parseFragment(newNode, parentNode2);
        }
        if (referenceNode && isDocumentFragment$1(referenceNode)) {
          referenceNode = parseFragment(referenceNode).firstChildNode;
        }
        parentNode2.insertBefore(newNode, referenceNode);
      }
      function removeChild(node, child) {
        node.removeChild(child);
      }
      function appendChild(node, child) {
        if (isDocumentFragment$1(child)) {
          child = parseFragment(child, node);
        }
        node.appendChild(child);
      }
      function parentNode(node) {
        if (isDocumentFragment$1(node)) {
          while (node && isDocumentFragment$1(node)) {
            const fragment2 = parseFragment(node);
            node = fragment2.parent;
          }
          return node !== null && node !== void 0 ? node : null;
        }
        return node.parentNode;
      }
      function nextSibling(node) {
        var _a4;
        if (isDocumentFragment$1(node)) {
          const fragment2 = parseFragment(node);
          const parent = parentNode(fragment2);
          if (parent && fragment2.lastChildNode) {
            const children = Array.from(parent.childNodes);
            const index = children.indexOf(fragment2.lastChildNode);
            return (_a4 = children[index + 1]) !== null && _a4 !== void 0 ? _a4 : null;
          }
          return null;
        }
        return node.nextSibling;
      }
      function tagName(elm) {
        return elm.tagName;
      }
      function setTextContent(node, text) {
        node.textContent = text;
      }
      function getTextContent(node) {
        return node.textContent;
      }
      function isElement$1(node) {
        return node.nodeType === 1;
      }
      function isText(node) {
        return node.nodeType === 3;
      }
      function isComment(node) {
        return node.nodeType === 8;
      }
      function isDocumentFragment$1(node) {
        return node.nodeType === 11;
      }
      function parseFragment(fragmentNode, parentNode2) {
        var _a4, _b2, _c;
        const fragment2 = fragmentNode;
        (_a4 = fragment2.parent) !== null && _a4 !== void 0 ? _a4 : fragment2.parent = parentNode2 !== null && parentNode2 !== void 0 ? parentNode2 : null;
        (_b2 = fragment2.firstChildNode) !== null && _b2 !== void 0 ? _b2 : fragment2.firstChildNode = fragmentNode.firstChild;
        (_c = fragment2.lastChildNode) !== null && _c !== void 0 ? _c : fragment2.lastChildNode = fragmentNode.lastChild;
        return fragment2;
      }
      var htmlDomApi = {
        createElement,
        createElementNS,
        createTextNode,
        createDocumentFragment,
        createComment,
        insertBefore,
        removeChild,
        appendChild,
        parentNode,
        nextSibling,
        tagName,
        setTextContent,
        getTextContent,
        isElement: isElement$1,
        isText,
        isComment,
        isDocumentFragment: isDocumentFragment$1
      };
      function vnode(sel, data, children, text, elm) {
        const key = data === void 0 ? void 0 : data.key;
        return { sel, data, children, text, elm, key };
      }
      var array = Array.isArray;
      function primitive(s3) {
        return typeof s3 === "string" || typeof s3 === "number" || s3 instanceof String || s3 instanceof Number;
      }
      function isUndef(s3) {
        return s3 === void 0;
      }
      function isDef(s3) {
        return s3 !== void 0;
      }
      var emptyNode = vnode("", {}, [], void 0, void 0);
      function sameVnode(vnode1, vnode2) {
        var _a4, _b2;
        const isSameKey = vnode1.key === vnode2.key;
        const isSameIs = ((_a4 = vnode1.data) === null || _a4 === void 0 ? void 0 : _a4.is) === ((_b2 = vnode2.data) === null || _b2 === void 0 ? void 0 : _b2.is);
        const isSameSel = vnode1.sel === vnode2.sel;
        const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
        return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
      }
      function documentFragmentIsNotSupported() {
        throw new Error("The document fragment is not supported on this platform.");
      }
      function isElement(api, vnode2) {
        return api.isElement(vnode2);
      }
      function isDocumentFragment(api, vnode2) {
        return api.isDocumentFragment(vnode2);
      }
      function createKeyToOldIdx(children, beginIdx, endIdx) {
        var _a4;
        const map = {};
        for (let i2 = beginIdx; i2 <= endIdx; ++i2) {
          const key = (_a4 = children[i2]) === null || _a4 === void 0 ? void 0 : _a4.key;
          if (key !== void 0) {
            map[key] = i2;
          }
        }
        return map;
      }
      var hooks = [
        "create",
        "update",
        "remove",
        "destroy",
        "pre",
        "post"
      ];
      function init$1(modules, domApi, options) {
        const cbs = {
          create: [],
          update: [],
          remove: [],
          destroy: [],
          pre: [],
          post: []
        };
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        for (const hook of hooks) {
          for (const module2 of modules) {
            const currentHook = module2[hook];
            if (currentHook !== void 0) {
              cbs[hook].push(currentHook);
            }
          }
        }
        function emptyNodeAt(elm) {
          const id = elm.id ? "#" + elm.id : "";
          const classes = elm.getAttribute("class");
          const c3 = classes ? "." + classes.split(" ").join(".") : "";
          return vnode(api.tagName(elm).toLowerCase() + id + c3, {}, [], void 0, elm);
        }
        function emptyDocumentFragmentAt(frag) {
          return vnode(void 0, {}, [], void 0, frag);
        }
        function createRmCb(childElm, listeners) {
          return function rmCb() {
            if (--listeners === 0) {
              const parent = api.parentNode(childElm);
              api.removeChild(parent, childElm);
            }
          };
        }
        function createElm(vnode2, insertedVnodeQueue) {
          var _a4, _b2, _c, _d;
          let i2;
          let data = vnode2.data;
          if (data !== void 0) {
            const init2 = (_a4 = data.hook) === null || _a4 === void 0 ? void 0 : _a4.init;
            if (isDef(init2)) {
              init2(vnode2);
              data = vnode2.data;
            }
          }
          const children = vnode2.children;
          const sel = vnode2.sel;
          if (sel === "!") {
            if (isUndef(vnode2.text)) {
              vnode2.text = "";
            }
            vnode2.elm = api.createComment(vnode2.text);
          } else if (sel !== void 0) {
            const hashIdx = sel.indexOf("#");
            const dotIdx = sel.indexOf(".", hashIdx);
            const hash = hashIdx > 0 ? hashIdx : sel.length;
            const dot = dotIdx > 0 ? dotIdx : sel.length;
            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            const elm = vnode2.elm = isDef(data) && isDef(i2 = data.ns) ? api.createElementNS(i2, tag, data) : api.createElement(tag, data);
            if (hash < dot)
              elm.setAttribute("id", sel.slice(hash + 1, dot));
            if (dotIdx > 0)
              elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
            for (i2 = 0; i2 < cbs.create.length; ++i2)
              cbs.create[i2](emptyNode, vnode2);
            if (array(children)) {
              for (i2 = 0; i2 < children.length; ++i2) {
                const ch = children[i2];
                if (ch != null) {
                  api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                }
              }
            } else if (primitive(vnode2.text)) {
              api.appendChild(elm, api.createTextNode(vnode2.text));
            }
            const hook = vnode2.data.hook;
            if (isDef(hook)) {
              (_b2 = hook.create) === null || _b2 === void 0 ? void 0 : _b2.call(hook, emptyNode, vnode2);
              if (hook.insert) {
                insertedVnodeQueue.push(vnode2);
              }
            }
          } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode2.children) {
            vnode2.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
            for (i2 = 0; i2 < cbs.create.length; ++i2)
              cbs.create[i2](emptyNode, vnode2);
            for (i2 = 0; i2 < vnode2.children.length; ++i2) {
              const ch = vnode2.children[i2];
              if (ch != null) {
                api.appendChild(vnode2.elm, createElm(ch, insertedVnodeQueue));
              }
            }
          } else {
            vnode2.elm = api.createTextNode(vnode2.text);
          }
          return vnode2.elm;
        }
        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
          for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (ch != null) {
              api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
            }
          }
        }
        function invokeDestroyHook(vnode2) {
          var _a4, _b2;
          const data = vnode2.data;
          if (data !== void 0) {
            (_b2 = (_a4 = data === null || data === void 0 ? void 0 : data.hook) === null || _a4 === void 0 ? void 0 : _a4.destroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, vnode2);
            for (let i2 = 0; i2 < cbs.destroy.length; ++i2)
              cbs.destroy[i2](vnode2);
            if (vnode2.children !== void 0) {
              for (let j3 = 0; j3 < vnode2.children.length; ++j3) {
                const child = vnode2.children[j3];
                if (child != null && typeof child !== "string") {
                  invokeDestroyHook(child);
                }
              }
            }
          }
        }
        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
          var _a4, _b2;
          for (; startIdx <= endIdx; ++startIdx) {
            let listeners;
            let rm;
            const ch = vnodes[startIdx];
            if (ch != null) {
              if (isDef(ch.sel)) {
                invokeDestroyHook(ch);
                listeners = cbs.remove.length + 1;
                rm = createRmCb(ch.elm, listeners);
                for (let i2 = 0; i2 < cbs.remove.length; ++i2)
                  cbs.remove[i2](ch, rm);
                const removeHook = (_b2 = (_a4 = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a4 === void 0 ? void 0 : _a4.hook) === null || _b2 === void 0 ? void 0 : _b2.remove;
                if (isDef(removeHook)) {
                  removeHook(ch, rm);
                } else {
                  rm();
                }
              } else if (ch.children) {
                invokeDestroyHook(ch);
                removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
              } else {
                api.removeChild(parentElm, ch.elm);
              }
            }
          }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
          let oldStartIdx = 0;
          let newStartIdx = 0;
          let oldEndIdx = oldCh.length - 1;
          let oldStartVnode = oldCh[0];
          let oldEndVnode = oldCh[oldEndIdx];
          let newEndIdx = newCh.length - 1;
          let newStartVnode = newCh[0];
          let newEndVnode = newCh[newEndIdx];
          let oldKeyToIdx;
          let idxInOld;
          let elmToMove;
          let before;
          while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
              oldStartVnode = oldCh[++oldStartIdx];
            } else if (oldEndVnode == null) {
              oldEndVnode = oldCh[--oldEndIdx];
            } else if (newStartVnode == null) {
              newStartVnode = newCh[++newStartIdx];
            } else if (newEndVnode == null) {
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
              patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
              patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
              patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
              patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
              api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
            } else {
              if (oldKeyToIdx === void 0) {
                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
              }
              idxInOld = oldKeyToIdx[newStartVnode.key];
              if (isUndef(idxInOld)) {
                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
              } else {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.sel !== newStartVnode.sel) {
                  api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                } else {
                  patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                  oldCh[idxInOld] = void 0;
                  api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                }
              }
              newStartVnode = newCh[++newStartIdx];
            }
          }
          if (newStartIdx <= newEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
          }
          if (oldStartIdx <= oldEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
          }
        }
        function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
          var _a4, _b2, _c, _d, _e3, _f, _g, _h;
          const hook = (_a4 = vnode2.data) === null || _a4 === void 0 ? void 0 : _a4.hook;
          (_b2 = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b2 === void 0 ? void 0 : _b2.call(hook, oldVnode, vnode2);
          const elm = vnode2.elm = oldVnode.elm;
          if (oldVnode === vnode2)
            return;
          if (vnode2.data !== void 0 || isDef(vnode2.text) && vnode2.text !== oldVnode.text) {
            (_c = vnode2.data) !== null && _c !== void 0 ? _c : vnode2.data = {};
            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
            for (let i2 = 0; i2 < cbs.update.length; ++i2)
              cbs.update[i2](oldVnode, vnode2);
            (_g = (_f = (_e3 = vnode2.data) === null || _e3 === void 0 ? void 0 : _e3.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode2);
          }
          const oldCh = oldVnode.children;
          const ch = vnode2.children;
          if (isUndef(vnode2.text)) {
            if (isDef(oldCh) && isDef(ch)) {
              if (oldCh !== ch)
                updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
              if (isDef(oldVnode.text))
                api.setTextContent(elm, "");
              addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
              api.setTextContent(elm, "");
            }
          } else if (oldVnode.text !== vnode2.text) {
            if (isDef(oldCh)) {
              removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            }
            api.setTextContent(elm, vnode2.text);
          }
          (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode2);
        }
        return function patch(oldVnode, vnode2) {
          let i2, elm, parent;
          const insertedVnodeQueue = [];
          for (i2 = 0; i2 < cbs.pre.length; ++i2)
            cbs.pre[i2]();
          if (isElement(api, oldVnode)) {
            oldVnode = emptyNodeAt(oldVnode);
          } else if (isDocumentFragment(api, oldVnode)) {
            oldVnode = emptyDocumentFragmentAt(oldVnode);
          }
          if (sameVnode(oldVnode, vnode2)) {
            patchVnode(oldVnode, vnode2, insertedVnodeQueue);
          } else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode2, insertedVnodeQueue);
            if (parent !== null) {
              api.insertBefore(parent, vnode2.elm, api.nextSibling(elm));
              removeVnodes(parent, [oldVnode], 0, 0);
            }
          }
          for (i2 = 0; i2 < insertedVnodeQueue.length; ++i2) {
            insertedVnodeQueue[i2].data.hook.insert(insertedVnodeQueue[i2]);
          }
          for (i2 = 0; i2 < cbs.post.length; ++i2)
            cbs.post[i2]();
          return vnode2;
        };
      }
      function addNS(data, children, sel) {
        data.ns = "http://www.w3.org/2000/svg";
        if (sel !== "foreignObject" && children !== void 0) {
          for (let i2 = 0; i2 < children.length; ++i2) {
            const child = children[i2];
            if (typeof child === "string")
              continue;
            const childData = child.data;
            if (childData !== void 0) {
              addNS(childData, child.children, child.sel);
            }
          }
        }
      }
      function h4(sel, b3, c3) {
        let data = {};
        let children;
        let text;
        let i2;
        if (c3 !== void 0) {
          if (b3 !== null) {
            data = b3;
          }
          if (array(c3)) {
            children = c3;
          } else if (primitive(c3)) {
            text = c3.toString();
          } else if (c3 && c3.sel) {
            children = [c3];
          }
        } else if (b3 !== void 0 && b3 !== null) {
          if (array(b3)) {
            children = b3;
          } else if (primitive(b3)) {
            text = b3.toString();
          } else if (b3 && b3.sel) {
            children = [b3];
          } else {
            data = b3;
          }
        }
        if (children !== void 0) {
          for (i2 = 0; i2 < children.length; ++i2) {
            if (primitive(children[i2]))
              children[i2] = vnode(void 0, void 0, void 0, children[i2], void 0);
          }
        }
        if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
          addNS(data, children, sel);
        }
        return vnode(sel, data, children, text, void 0);
      }
      function fragment(children) {
        let c3;
        let text;
        if (array(children)) {
          c3 = children;
        } else if (primitive(c3)) {
          text = children;
        } else if (c3 && c3.sel) {
          c3 = [children];
        }
        if (c3 !== void 0) {
          for (let i2 = 0; i2 < c3.length; ++i2) {
            if (primitive(c3[i2]))
              c3[i2] = vnode(void 0, void 0, void 0, c3[i2], void 0);
          }
        }
        return vnode(void 0, {}, c3, text, void 0);
      }
      function copyToThunk(vnode2, thunk2) {
        var _a4;
        const ns = (_a4 = thunk2.data) === null || _a4 === void 0 ? void 0 : _a4.ns;
        vnode2.data.fn = thunk2.data.fn;
        vnode2.data.args = thunk2.data.args;
        thunk2.data = vnode2.data;
        thunk2.children = vnode2.children;
        thunk2.text = vnode2.text;
        thunk2.elm = vnode2.elm;
        if (ns)
          addNS(thunk2.data, thunk2.children, thunk2.sel);
      }
      function init(thunk2) {
        const cur = thunk2.data;
        const vnode2 = cur.fn(...cur.args);
        copyToThunk(vnode2, thunk2);
      }
      function prepatch(oldVnode, thunk2) {
        let i2;
        const old = oldVnode.data;
        const cur = thunk2.data;
        const oldArgs = old.args;
        const args = cur.args;
        if (old.fn !== cur.fn || oldArgs.length !== args.length) {
          copyToThunk(cur.fn(...args), thunk2);
          return;
        }
        for (i2 = 0; i2 < args.length; ++i2) {
          if (oldArgs[i2] !== args[i2]) {
            copyToThunk(cur.fn(...args), thunk2);
            return;
          }
        }
        copyToThunk(oldVnode, thunk2);
      }
      var thunk = function thunk2(sel, key, fn, args) {
        if (args === void 0) {
          args = fn;
          fn = key;
          key = void 0;
        }
        return h4(sel, {
          key,
          hook: { init, prepatch },
          fn,
          args
        });
      };
      function pre(vnode2, newVnode) {
        const attachData = vnode2.data.attachData;
        newVnode.data.attachData.placeholder = attachData.placeholder;
        newVnode.data.attachData.real = attachData.real;
        vnode2.elm = vnode2.data.attachData.real;
      }
      function post(_3, vnode2) {
        vnode2.elm = vnode2.data.attachData.placeholder;
      }
      function destroy(vnode2) {
        if (vnode2.elm !== void 0) {
          vnode2.elm.parentNode.removeChild(vnode2.elm);
        }
        vnode2.elm = vnode2.data.attachData.real;
      }
      function create(_3, vnode2) {
        const real = vnode2.elm;
        const attachData = vnode2.data.attachData;
        const placeholder = document.createElement("span");
        vnode2.elm = placeholder;
        attachData.target.appendChild(real);
        attachData.real = real;
        attachData.placeholder = placeholder;
      }
      function attachTo(target, vnode2) {
        if (vnode2.data === void 0)
          vnode2.data = {};
        if (vnode2.data.hook === void 0)
          vnode2.data.hook = {};
        const data = vnode2.data;
        const hook = vnode2.data.hook;
        data.attachData = { target, placeholder: void 0, real: void 0 };
        hook.create = create;
        hook.prepatch = pre;
        hook.postpatch = post;
        hook.destroy = destroy;
        return vnode2;
      }
      function toVNode(node, domApi) {
        const api = domApi !== void 0 ? domApi : htmlDomApi;
        let text;
        if (api.isElement(node)) {
          const id = node.id ? "#" + node.id : "";
          const cn = node.getAttribute("class");
          const c3 = cn ? "." + cn.split(" ").join(".") : "";
          const sel = api.tagName(node).toLowerCase() + id + c3;
          const attrs = {};
          const dataset = {};
          const data = {};
          const children = [];
          let name;
          let i2, n;
          const elmAttrs = node.attributes;
          const elmChildren = node.childNodes;
          for (i2 = 0, n = elmAttrs.length; i2 < n; i2++) {
            name = elmAttrs[i2].nodeName;
            if (name[0] === "d" && name[1] === "a" && name[2] === "t" && name[3] === "a" && name[4] === "-") {
              dataset[name.slice(5)] = elmAttrs[i2].nodeValue || "";
            } else if (name !== "id" && name !== "class") {
              attrs[name] = elmAttrs[i2].nodeValue;
            }
          }
          for (i2 = 0, n = elmChildren.length; i2 < n; i2++) {
            children.push(toVNode(elmChildren[i2], domApi));
          }
          if (Object.keys(attrs).length > 0)
            data.attrs = attrs;
          if (Object.keys(dataset).length > 0)
            data.dataset = dataset;
          if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
            addNS(data, children, sel);
          }
          return vnode(sel, data, children, void 0, node);
        } else if (api.isText(node)) {
          text = api.getTextContent(node);
          return vnode(void 0, void 0, void 0, text, node);
        } else if (api.isComment(node)) {
          text = api.getTextContent(node);
          return vnode("!", {}, [], text, node);
        } else {
          return vnode("", {}, [], void 0, node);
        }
      }
      var xlinkNS = "http://www.w3.org/1999/xlink";
      var xmlNS = "http://www.w3.org/XML/1998/namespace";
      var colonChar = 58;
      var xChar = 120;
      function updateAttrs(oldVnode, vnode2) {
        let key;
        const elm = vnode2.elm;
        let oldAttrs = oldVnode.data.attrs;
        let attrs = vnode2.data.attrs;
        if (!oldAttrs && !attrs)
          return;
        if (oldAttrs === attrs)
          return;
        oldAttrs = oldAttrs || {};
        attrs = attrs || {};
        for (key in attrs) {
          const cur = attrs[key];
          const old = oldAttrs[key];
          if (old !== cur) {
            if (cur === true) {
              elm.setAttribute(key, "");
            } else if (cur === false) {
              elm.removeAttribute(key);
            } else {
              if (key.charCodeAt(0) !== xChar) {
                elm.setAttribute(key, cur);
              } else if (key.charCodeAt(3) === colonChar) {
                elm.setAttributeNS(xmlNS, key, cur);
              } else if (key.charCodeAt(5) === colonChar) {
                elm.setAttributeNS(xlinkNS, key, cur);
              } else {
                elm.setAttribute(key, cur);
              }
            }
          }
        }
        for (key in oldAttrs) {
          if (!(key in attrs)) {
            elm.removeAttribute(key);
          }
        }
      }
      var attributesModule = {
        create: updateAttrs,
        update: updateAttrs
      };
      function updateClass(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldClass = oldVnode.data.class;
        let klass = vnode2.data.class;
        if (!oldClass && !klass)
          return;
        if (oldClass === klass)
          return;
        oldClass = oldClass || {};
        klass = klass || {};
        for (name in oldClass) {
          if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {
            elm.classList.remove(name);
          }
        }
        for (name in klass) {
          cur = klass[name];
          if (cur !== oldClass[name]) {
            elm.classList[cur ? "add" : "remove"](name);
          }
        }
      }
      var classModule = { create: updateClass, update: updateClass };
      var CAPS_REGEX = /[A-Z]/g;
      function updateDataset(oldVnode, vnode2) {
        const elm = vnode2.elm;
        let oldDataset = oldVnode.data.dataset;
        let dataset = vnode2.data.dataset;
        let key;
        if (!oldDataset && !dataset)
          return;
        if (oldDataset === dataset)
          return;
        oldDataset = oldDataset || {};
        dataset = dataset || {};
        const d3 = elm.dataset;
        for (key in oldDataset) {
          if (!dataset[key]) {
            if (d3) {
              if (key in d3) {
                delete d3[key];
              }
            } else {
              elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
            }
          }
        }
        for (key in dataset) {
          if (oldDataset[key] !== dataset[key]) {
            if (d3) {
              d3[key] = dataset[key];
            } else {
              elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset[key]);
            }
          }
        }
      }
      var datasetModule = {
        create: updateDataset,
        update: updateDataset
      };
      function invokeHandler(handler, vnode2, event) {
        if (typeof handler === "function") {
          handler.call(vnode2, event, vnode2);
        } else if (typeof handler === "object") {
          for (let i2 = 0; i2 < handler.length; i2++) {
            invokeHandler(handler[i2], vnode2, event);
          }
        }
      }
      function handleEvent(event, vnode2) {
        const name = event.type;
        const on = vnode2.data.on;
        if (on && on[name]) {
          invokeHandler(on[name], vnode2, event);
        }
      }
      function createListener() {
        return function handler(event) {
          handleEvent(event, handler.vnode);
        };
      }
      function updateEventListeners(oldVnode, vnode2) {
        const oldOn = oldVnode.data.on;
        const oldListener = oldVnode.listener;
        const oldElm = oldVnode.elm;
        const on = vnode2 && vnode2.data.on;
        const elm = vnode2 && vnode2.elm;
        let name;
        if (oldOn === on) {
          return;
        }
        if (oldOn && oldListener) {
          if (!on) {
            for (name in oldOn) {
              oldElm.removeEventListener(name, oldListener, false);
            }
          } else {
            for (name in oldOn) {
              if (!on[name]) {
                oldElm.removeEventListener(name, oldListener, false);
              }
            }
          }
        }
        if (on) {
          const listener = vnode2.listener = oldVnode.listener || createListener();
          listener.vnode = vnode2;
          if (!oldOn) {
            for (name in on) {
              elm.addEventListener(name, listener, false);
            }
          } else {
            for (name in on) {
              if (!oldOn[name]) {
                elm.addEventListener(name, listener, false);
              }
            }
          }
        }
      }
      var eventListenersModule = {
        create: updateEventListeners,
        update: updateEventListeners,
        destroy: updateEventListeners
      };
      function updateProps(oldVnode, vnode2) {
        let key;
        let cur;
        let old;
        const elm = vnode2.elm;
        let oldProps = oldVnode.data.props;
        let props = vnode2.data.props;
        if (!oldProps && !props)
          return;
        if (oldProps === props)
          return;
        oldProps = oldProps || {};
        props = props || {};
        for (key in props) {
          cur = props[key];
          old = oldProps[key];
          if (old !== cur && (key !== "value" || elm[key] !== cur)) {
            elm[key] = cur;
          }
        }
      }
      var propsModule = { create: updateProps, update: updateProps };
      var raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
      var nextFrame = function(fn) {
        raf(function() {
          raf(fn);
        });
      };
      var reflowForced = false;
      function setNextFrame(obj, prop, val) {
        nextFrame(function() {
          obj[prop] = val;
        });
      }
      function updateStyle(oldVnode, vnode2) {
        let cur;
        let name;
        const elm = vnode2.elm;
        let oldStyle = oldVnode.data.style;
        let style = vnode2.data.style;
        if (!oldStyle && !style)
          return;
        if (oldStyle === style)
          return;
        oldStyle = oldStyle || {};
        style = style || {};
        const oldHasDel = "delayed" in oldStyle;
        for (name in oldStyle) {
          if (!style[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.removeProperty(name);
            } else {
              elm.style[name] = "";
            }
          }
        }
        for (name in style) {
          cur = style[name];
          if (name === "delayed" && style.delayed) {
            for (const name2 in style.delayed) {
              cur = style.delayed[name2];
              if (!oldHasDel || cur !== oldStyle.delayed[name2]) {
                setNextFrame(elm.style, name2, cur);
              }
            }
          } else if (name !== "remove" && cur !== oldStyle[name]) {
            if (name[0] === "-" && name[1] === "-") {
              elm.style.setProperty(name, cur);
            } else {
              elm.style[name] = cur;
            }
          }
        }
      }
      function applyDestroyStyle(vnode2) {
        let style;
        let name;
        const elm = vnode2.elm;
        const s3 = vnode2.data.style;
        if (!s3 || !(style = s3.destroy))
          return;
        for (name in style) {
          elm.style[name] = style[name];
        }
      }
      function applyRemoveStyle(vnode2, rm) {
        const s3 = vnode2.data.style;
        if (!s3 || !s3.remove) {
          rm();
          return;
        }
        if (!reflowForced) {
          vnode2.elm.offsetLeft;
          reflowForced = true;
        }
        let name;
        const elm = vnode2.elm;
        let i2 = 0;
        const style = s3.remove;
        let amount = 0;
        const applied = [];
        for (name in style) {
          applied.push(name);
          elm.style[name] = style[name];
        }
        const compStyle = getComputedStyle(elm);
        const props = compStyle["transition-property"].split(", ");
        for (; i2 < props.length; ++i2) {
          if (applied.indexOf(props[i2]) !== -1)
            amount++;
        }
        elm.addEventListener("transitionend", function(ev) {
          if (ev.target === elm)
            --amount;
          if (amount === 0)
            rm();
        });
      }
      function forceReflow() {
        reflowForced = false;
      }
      var styleModule = {
        pre: forceReflow,
        create: updateStyle,
        update: updateStyle,
        destroy: applyDestroyStyle,
        remove: applyRemoveStyle
      };
      function Fragment(data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
          return vnode(void 0, void 0, void 0, flatChildren[0].text, void 0);
        } else {
          return vnode(void 0, data !== null && data !== void 0 ? data : {}, flatChildren, void 0, void 0);
        }
      }
      function flattenAndFilter(children, flattened) {
        for (const child of children) {
          if (child !== void 0 && child !== null && child !== false && child !== "") {
            if (Array.isArray(child)) {
              flattenAndFilter(child, flattened);
            } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
              flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
            } else {
              flattened.push(child);
            }
          }
        }
        return flattened;
      }
      function jsx(tag, data, ...children) {
        const flatChildren = flattenAndFilter(children, []);
        if (typeof tag === "function") {
          return tag(data, flatChildren);
        } else {
          if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
            return h4(tag, data, flatChildren[0].text);
          } else {
            return h4(tag, data, flatChildren);
          }
        }
      }
      /* @__PURE__ */ (function(jsx2) {
      })(jsx || (jsx = {}));
      exports.Fragment = Fragment;
      exports.array = array;
      exports.attachTo = attachTo;
      exports.attributesModule = attributesModule;
      exports.classModule = classModule;
      exports.datasetModule = datasetModule;
      exports.eventListenersModule = eventListenersModule;
      exports.fragment = fragment;
      exports.h = h4;
      exports.htmlDomApi = htmlDomApi;
      exports.init = init$1;
      exports.jsx = jsx;
      exports.primitive = primitive;
      exports.propsModule = propsModule;
      exports.styleModule = styleModule;
      exports.thunk = thunk;
      exports.toVNode = toVNode;
      exports.vnode = vnode;
    }
  });

  // ../../node_modules/sprotty/lib/base/views/thunk-view.js
  var require_thunk_view = __commonJS({
    "../../node_modules/sprotty/lib/base/views/thunk-view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isThunk = exports.ThunkView = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var inversify_1 = require_cjs4();
      var ThunkView = class ThunkView {
        render(model, context) {
          return (0, snabbdom_1.h)(this.selector(model), {
            key: model.id,
            hook: {
              init: this.init.bind(this),
              prepatch: this.prepatch.bind(this)
            },
            fn: () => this.renderAndDecorate(model, context),
            args: this.watchedArgs(model),
            thunk: true
          });
        }
        renderAndDecorate(model, context) {
          const vnode = this.doRender(model, context);
          context.decorate(vnode, model);
          return vnode;
        }
        copyToThunk(vnode, thunk) {
          thunk.elm = vnode.elm;
          vnode.data.fn = thunk.data.fn;
          vnode.data.args = thunk.data.args;
          thunk.data = vnode.data;
          thunk.children = vnode.children;
          thunk.text = vnode.text;
          thunk.elm = vnode.elm;
        }
        init(thunk) {
          const cur = thunk.data;
          const vnode = cur.fn.apply(void 0, cur.args);
          this.copyToThunk(vnode, thunk);
        }
        prepatch(oldVnode, thunk) {
          const old = oldVnode.data, cur = thunk.data;
          if (!this.equals(old.args, cur.args))
            this.copyToThunk(cur.fn.apply(void 0, cur.args), thunk);
          else
            this.copyToThunk(oldVnode, thunk);
        }
        equals(oldArg, newArg) {
          if (Array.isArray(oldArg) && Array.isArray(newArg)) {
            if (oldArg.length !== newArg.length)
              return false;
            for (let i2 = 0; i2 < newArg.length; ++i2) {
              if (!this.equals(oldArg[i2], newArg[i2]))
                return false;
            }
          } else if (typeof oldArg === "object" && typeof newArg === "object") {
            if (Object.keys(oldArg).length !== Object.keys(newArg).length)
              return false;
            for (const key in oldArg) {
              if (key !== "parent" && key !== "root" && (!(key in newArg) || !this.equals(oldArg[key], newArg[key])))
                return false;
            }
          } else if (oldArg !== newArg) {
            return false;
          }
          return true;
        }
      };
      exports.ThunkView = ThunkView;
      exports.ThunkView = ThunkView = __decorate([
        (0, inversify_1.injectable)()
      ], ThunkView);
      function isThunk(vnode) {
        return "thunk" in vnode;
      }
      exports.isThunk = isThunk;
    }
  });

  // ../../node_modules/sprotty/lib/lib/jsx.js
  var require_jsx = __commonJS({
    "../../node_modules/sprotty/lib/lib/jsx.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSX = exports.svg = exports.html = void 0;
      var snabbdom_1 = require_snabbdom_cjs();
      var modulesNS = ["hook", "on", "style", "class", "props", "attrs", "dataset"];
      var SVGNS = "http://www.w3.org/2000/svg";
      function normalizeAttrs(source, defNS, namespace) {
        const data = {};
        if (namespace) {
          data.ns = namespace;
        }
        if (source === null) {
          return data;
        }
        modulesNS.forEach((mod) => {
          if (source[mod]) {
            data[mod] = source[mod];
          }
        });
        Object.keys(source).forEach((key) => {
          if (key === "key" || key === "classNames" || key === "selector")
            return;
          const idx = key.indexOf("-");
          if (idx > 0) {
            const modname = key.slice(0, idx);
            if (modulesNS.includes(modname)) {
              addAttr(modname, key.slice(idx + 1), source[key]);
            } else {
              addAttr(defNS, key, source[key]);
            }
          } else if (!data[key])
            addAttr(defNS, key, source[key]);
        });
        return data;
        function addAttr(modname, key, val) {
          const mod = data[modname] || (data[modname] = {});
          mod[key] = val;
        }
      }
      function JSX(namespace, defNS = "props") {
        return (tag, attrs, ...children) => {
          const isComponent = typeof tag === "function";
          return (0, snabbdom_1.jsx)(tag, isComponent ? attrs : normalizeAttrs(attrs, defNS, namespace), children);
        };
      }
      exports.JSX = JSX;
      var html = JSX();
      exports.html = html;
      var svg = JSX(SVGNS, "attrs");
      exports.svg = svg;
    }
  });

  // ../../node_modules/sprotty/lib/base/views/view.js
  var require_view = __commonJS({
    "../../node_modules/sprotty/lib/base/views/view.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var MissingView_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MissingView = exports.EmptyView = exports.configureView = exports.overrideModelElement = exports.configureModelElement = exports.ViewRegistry = exports.findArgValue = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var inversify_2 = require_inversify();
      var smodel_factory_1 = require_smodel_factory();
      var smodel_utils_1 = require_smodel_utils();
      var sprotty_protocol_1 = require_lib();
      function findArgValue(arg, key) {
        while (arg !== void 0 && !(key in arg) && arg.parentArgs) {
          arg = arg.parentArgs;
        }
        return arg ? arg[key] : void 0;
      }
      exports.findArgValue = findArgValue;
      var ViewRegistry = class ViewRegistry extends registry_1.InstanceRegistry {
        constructor(registrations) {
          super();
          this.registerDefaults();
          registrations.forEach((registration) => {
            if (registration.isOverride) {
              this.override(registration.type, registration.factory());
            } else {
              this.register(registration.type, registration.factory());
            }
          });
        }
        registerDefaults() {
          this.register(smodel_factory_1.EMPTY_ROOT.type, new EmptyView2());
        }
        missing(key) {
          this.logger.warn(this, `no registered view for type '${key}', please configure a view in the ContainerModule`);
          return new MissingView();
        }
      };
      exports.ViewRegistry = ViewRegistry;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ViewRegistry.prototype, "logger", void 0);
      exports.ViewRegistry = ViewRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ViewRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ViewRegistry);
      function configureModelElement2(context, type, modelConstr, viewConstr, features) {
        (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features);
        configureView(context, type, viewConstr);
      }
      exports.configureModelElement = configureModelElement2;
      function overrideModelElement(context, type, modelConstr, viewConstr, features) {
        (0, smodel_utils_1.registerModelElement)(context, type, modelConstr, features, true);
        configureView(context, type, viewConstr, true);
      }
      exports.overrideModelElement = overrideModelElement;
      function configureView(context, type, constr, isOverride) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Views should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.ViewRegistration).toDynamicValue((ctx) => ({
          type,
          factory: () => ctx.container.get(constr),
          isOverride
        }));
      }
      exports.configureView = configureView;
      var EmptyView2 = class EmptyView {
        render(model, context) {
          return (0, jsx_1.svg)("svg", { "class-sprotty-empty": true });
        }
      };
      exports.EmptyView = EmptyView2;
      exports.EmptyView = EmptyView2 = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyView2);
      var MissingView = MissingView_1 = class MissingView {
        render(model, context) {
          const position = model.position || this.getPostion(model.type);
          return (0, jsx_1.svg)(
            "text",
            { "class-sprotty-missing": true, x: position.x, y: position.y },
            'missing "',
            model.type,
            '" view'
          );
        }
        getPostion(type) {
          let position = MissingView_1.positionMap.get(type);
          if (!position) {
            position = sprotty_protocol_1.Point.ORIGIN;
            MissingView_1.positionMap.forEach((value) => position = value.y >= position.y ? { x: 0, y: value.y + 20 } : position);
            MissingView_1.positionMap.set(type, position);
          }
          return position;
        }
      };
      exports.MissingView = MissingView;
      MissingView.positionMap = /* @__PURE__ */ new Map();
      exports.MissingView = MissingView = MissingView_1 = __decorate([
        (0, inversify_1.injectable)()
      ], MissingView);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/viewer-cache.js
  var require_viewer_cache = __commonJS({
    "../../node_modules/sprotty/lib/base/views/viewer-cache.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewerCache = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var ViewerCache = class ViewerCache {
        update(model, cause) {
          if (cause !== void 0) {
            this.delegate.update(model, cause);
            this.cachedModel = void 0;
          } else {
            const isCacheEmpty = this.cachedModel === void 0;
            this.cachedModel = model;
            if (isCacheEmpty) {
              this.scheduleUpdate();
            }
          }
        }
        scheduleUpdate() {
          this.syncer.onEndOfNextFrame(() => {
            if (this.cachedModel) {
              this.delegate.update(this.cachedModel);
              this.cachedModel = void 0;
            }
          });
        }
      };
      exports.ViewerCache = ViewerCache;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IViewer),
        __metadata("design:type", Object)
      ], ViewerCache.prototype, "delegate", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
      ], ViewerCache.prototype, "syncer", void 0);
      exports.ViewerCache = ViewerCache = __decorate([
        (0, inversify_1.injectable)()
      ], ViewerCache);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/viewer-options.js
  var require_viewer_options = __commonJS({
    "../../node_modules/sprotty/lib/base/views/viewer-options.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.overrideViewerOptions = exports.configureViewerOptions = exports.defaultViewerOptions = void 0;
      var object_1 = require_object();
      var types_1 = require_types();
      var defaultViewerOptions = () => ({
        baseDiv: "sprotty",
        baseClass: "sprotty",
        hiddenDiv: "sprotty-hidden",
        hiddenClass: "sprotty-hidden",
        popupDiv: "sprotty-popup",
        popupClass: "sprotty-popup",
        popupClosedClass: "sprotty-popup-closed",
        needsClientLayout: true,
        needsServerLayout: false,
        popupOpenDelay: 1e3,
        popupCloseDelay: 300,
        zoomLimits: { min: 0.01, max: 10 },
        horizontalScrollLimits: { min: -1e5, max: 1e5 },
        verticalScrollLimits: { min: -1e5, max: 1e5 }
      });
      exports.defaultViewerOptions = defaultViewerOptions;
      function configureViewerOptions(context, options) {
        const opt = Object.assign(Object.assign({}, (0, exports.defaultViewerOptions)()), options);
        if (context.isBound(types_1.TYPES.ViewerOptions)) {
          context.rebind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
        } else {
          context.bind(types_1.TYPES.ViewerOptions).toConstantValue(opt);
        }
      }
      exports.configureViewerOptions = configureViewerOptions;
      function overrideViewerOptions2(container, options) {
        const opt = container.get(types_1.TYPES.ViewerOptions);
        (0, object_1.safeAssign)(opt, options);
        return opt;
      }
      exports.overrideViewerOptions = overrideViewerOptions2;
    }
  });

  // ../../node_modules/sprotty/lib/base/views/viewer.js
  var require_viewer = __commonJS({
    "../../node_modules/sprotty/lib/base/views/viewer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupModelViewer = exports.HiddenModelViewer = exports.ModelViewer = exports.PatcherProvider = exports.ModelRenderer = void 0;
      var inversify_1 = require_cjs4();
      var snabbdom_1 = require_snabbdom_cjs();
      var jsx_1 = require_jsx();
      var browser_1 = require_browser();
      var initialize_canvas_1 = require_initialize_canvas();
      var smodel_factory_1 = require_smodel_factory();
      var types_1 = require_types();
      var thunk_view_1 = require_thunk_view();
      var vnode_utils_1 = require_vnode_utils();
      var ModelRenderer = class _ModelRenderer {
        constructor(viewRegistry, targetKind, postprocessors, args = {}) {
          this.viewRegistry = viewRegistry;
          this.targetKind = targetKind;
          this.postprocessors = postprocessors;
          this.args = args;
        }
        decorate(vnode, element) {
          if ((0, thunk_view_1.isThunk)(vnode)) {
            return vnode;
          }
          return this.postprocessors.reduce((n, processor) => processor.decorate(n, element), vnode);
        }
        renderElement(element) {
          const view = this.viewRegistry.get(element.type);
          const vnode = view.render(element, this, this.args);
          if (vnode) {
            return this.decorate(vnode, element);
          } else {
            return void 0;
          }
        }
        renderChildren(element, args) {
          const context = args ? new _ModelRenderer(this.viewRegistry, this.targetKind, this.postprocessors, Object.assign(Object.assign({}, args), { parentArgs: this.args })) : this;
          return element.children.map((child) => context.renderElement(child)).filter((vnode) => vnode !== void 0);
        }
        postUpdate(cause) {
          this.postprocessors.forEach((processor) => processor.postUpdate(cause));
        }
      };
      exports.ModelRenderer = ModelRenderer;
      var PatcherProvider = class PatcherProvider {
        constructor() {
          this.patcher = (0, snabbdom_1.init)(this.createModules());
        }
        createModules() {
          return [
            snabbdom_1.propsModule,
            snabbdom_1.attributesModule,
            snabbdom_1.classModule,
            snabbdom_1.styleModule,
            snabbdom_1.eventListenersModule
          ];
        }
      };
      exports.PatcherProvider = PatcherProvider;
      exports.PatcherProvider = PatcherProvider = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [])
      ], PatcherProvider);
      var ModelViewer2 = class ModelViewer {
        constructor(modelRendererFactory, patcherProvider, postprocessors) {
          this.renderer = modelRendererFactory("main", postprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          var _a4;
          this.logger.log(this, "rendering", model);
          const newVDOM = (0, jsx_1.html)("div", { id: this.options.baseDiv }, this.renderer.renderElement(model));
          if (this.lastVDOM !== void 0) {
            const hadFocus = this.hasFocus();
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastVDOM, newVDOM);
            this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
            this.restoreFocus(hadFocus);
          } else if (typeof document !== "undefined") {
            let placeholder = null;
            if (this.options.shadowRoot) {
              const shadowRoot = (_a4 = document.getElementById(this.options.shadowRoot)) === null || _a4 === void 0 ? void 0 : _a4.shadowRoot;
              if (shadowRoot) {
                placeholder = shadowRoot.getElementById(this.options.baseDiv);
              }
            } else {
              placeholder = document.getElementById(this.options.baseDiv);
            }
            if (placeholder !== null) {
              if (typeof window !== "undefined") {
                window.addEventListener("resize", () => {
                  this.onWindowResize(newVDOM);
                });
              }
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
              (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
              this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
            } else {
              this.logger.error(this, "element not in DOM:", this.options.baseDiv);
            }
          }
          this.renderer.postUpdate(cause);
        }
        hasFocus() {
          if (typeof document !== "undefined" && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              return document.activeElement === lastElement;
            }
          }
          return false;
        }
        restoreFocus(focus) {
          if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            const lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === "object") {
              const lastElement = lastRootVNode.elm;
              if (lastElement && typeof lastElement.focus === "function")
                lastElement.focus();
            }
          }
        }
        onWindowResize(vdom) {
          const baseDiv = document.getElementById(this.options.baseDiv);
          if (baseDiv !== null) {
            const newBounds = this.getBoundsInPage(baseDiv);
            this.actiondispatcher.dispatch(initialize_canvas_1.InitializeCanvasBoundsAction.create(newBounds));
          }
        }
        getBoundsInPage(element) {
          const bounds = element.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.ModelViewer = ModelViewer2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelViewer2.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], ModelViewer2.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelViewer2.prototype, "actiondispatcher", void 0);
      exports.ModelViewer = ModelViewer2 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.IVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], ModelViewer2);
      var HiddenModelViewer = class HiddenModelViewer {
        constructor(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
          this.hiddenRenderer = modelRendererFactory("hidden", hiddenPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(hiddenModel, cause) {
          this.logger.log(this, "rendering hidden");
          let newVDOM;
          if (hiddenModel.type === smodel_factory_1.EMPTY_ROOT.type) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv });
          } else {
            const hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
            if (hiddenVNode) {
              (0, vnode_utils_1.setAttr)(hiddenVNode, "opacity", 0);
            }
            newVDOM = (0, jsx_1.html)("div", { id: this.options.hiddenDiv }, hiddenVNode);
          }
          if (this.lastHiddenVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastHiddenVDOM, newVDOM);
            this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
          } else {
            let placeholder = document.getElementById(this.options.hiddenDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.baseClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.hiddenClass, true);
            this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.hiddenRenderer.postUpdate(cause);
        }
      };
      exports.HiddenModelViewer = HiddenModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenModelViewer.prototype, "logger", void 0);
      exports.HiddenModelViewer = HiddenModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.HiddenVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], HiddenModelViewer);
      var PopupModelViewer = class PopupModelViewer {
        constructor(modelRendererFactory, patcherProvider, popupPostprocessors) {
          this.modelRendererFactory = modelRendererFactory;
          this.popupRenderer = this.modelRendererFactory("popup", popupPostprocessors);
          this.patcher = patcherProvider.patcher;
        }
        update(model, cause) {
          this.logger.log(this, "rendering popup", model);
          const popupClosed = model.type === smodel_factory_1.EMPTY_ROOT.type;
          let newVDOM;
          if (popupClosed) {
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv });
          } else {
            const position = model.canvasBounds;
            const inlineStyle = {
              top: position.y + "px",
              left: position.x + "px"
            };
            newVDOM = (0, jsx_1.html)("div", { id: this.options.popupDiv, style: inlineStyle }, this.popupRenderer.renderElement(model));
          }
          if (this.lastPopupVDOM !== void 0) {
            (0, vnode_utils_1.copyClassesFromVNode)(this.lastPopupVDOM, newVDOM);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
          } else if (typeof document !== "undefined") {
            let placeholder = document.getElementById(this.options.popupDiv);
            if (placeholder === null) {
              placeholder = document.createElement("div");
              document.body.appendChild(placeholder);
            } else {
              (0, vnode_utils_1.copyClassesFromElement)(placeholder, newVDOM);
            }
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClass, true);
            (0, vnode_utils_1.setClass)(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
          }
          this.popupRenderer.postUpdate(cause);
        }
      };
      exports.PopupModelViewer = PopupModelViewer;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], PopupModelViewer.prototype, "logger", void 0);
      exports.PopupModelViewer = PopupModelViewer = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ModelRendererFactory)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.PatcherProvider)),
        __param(2, (0, inversify_1.multiInject)(types_1.TYPES.PopupVNodePostprocessor)),
        __param(2, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
      ], PopupModelViewer);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/vnode-postprocessor.js
  var require_vnode_postprocessor = __commonJS({
    "../../node_modules/sprotty/lib/base/views/vnode-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FocusFixPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var vnode_utils_1 = require_vnode_utils();
      var FocusFixPostprocessor = class FocusFixPostprocessor {
        decorate(vnode, element) {
          if (vnode.sel && vnode.sel.startsWith("svg"))
            (0, vnode_utils_1.setAttr)(vnode, "tabindex", 0);
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.FocusFixPostprocessor = FocusFixPostprocessor;
      exports.FocusFixPostprocessor = FocusFixPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], FocusFixPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/utils/logging.js
  var require_logging = __commonJS({
    "../../node_modules/sprotty/lib/utils/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConsoleLogger = exports.NullLogger = exports.LogLevel = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var LogLevel2;
      (function(LogLevel3) {
        LogLevel3[LogLevel3["none"] = 0] = "none";
        LogLevel3[LogLevel3["error"] = 1] = "error";
        LogLevel3[LogLevel3["warn"] = 2] = "warn";
        LogLevel3[LogLevel3["info"] = 3] = "info";
        LogLevel3[LogLevel3["log"] = 4] = "log";
      })(LogLevel2 || (exports.LogLevel = LogLevel2 = {}));
      var NullLogger = class NullLogger {
        constructor() {
          this.logLevel = LogLevel2.none;
        }
        error(thisArg, message, ...params) {
        }
        warn(thisArg, message, ...params) {
        }
        info(thisArg, message, ...params) {
        }
        log(thisArg, message, ...params) {
        }
      };
      exports.NullLogger = NullLogger;
      exports.NullLogger = NullLogger = __decorate([
        (0, inversify_1.injectable)()
      ], NullLogger);
      var ConsoleLogger2 = class ConsoleLogger {
        constructor() {
          this.logLevel = LogLevel2.log;
          this.viewOptions = { baseDiv: "" };
        }
        error(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.error)
            try {
              console.error.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.warn)
            try {
              console.warn.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.info)
            try {
              console.info.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= LogLevel2.log)
            try {
              console.log.apply(thisArg, this.consoleArguments(thisArg, message, params));
            } catch (error) {
            }
        }
        consoleArguments(thisArg, message, params) {
          let caller;
          if (typeof thisArg === "object")
            caller = thisArg.constructor.name;
          else
            caller = thisArg;
          const date = /* @__PURE__ */ new Date();
          return [date.toLocaleTimeString() + " " + this.viewOptions.baseDiv + " " + caller + ": " + message, ...params];
        }
      };
      exports.ConsoleLogger = ConsoleLogger2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ConsoleLogger2.prototype, "logLevel", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ConsoleLogger2.prototype, "viewOptions", void 0);
      exports.ConsoleLogger = ConsoleLogger2 = __decorate([
        (0, inversify_1.injectable)()
      ], ConsoleLogger2);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/id-postprocessor.js
  var require_id_postprocessor = __commonJS({
    "../../node_modules/sprotty/lib/base/views/id-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IdPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var dom_helper_1 = require_dom_helper();
      var vnode_utils_1 = require_vnode_utils();
      var IdPostprocessor = class IdPostprocessor {
        decorate(vnode, element) {
          const attrs = (0, vnode_utils_1.getAttrs)(vnode);
          if (attrs.id !== void 0)
            this.logger.warn(vnode, "Overriding id of vnode (" + attrs.id + "). Make sure not to set it manually in view.");
          attrs.id = this.domHelper.createUniqueDOMElementId(element);
          if (!vnode.key)
            vnode.key = element.id;
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.IdPostprocessor = IdPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], IdPostprocessor.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], IdPostprocessor.prototype, "domHelper", void 0);
      exports.IdPostprocessor = IdPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], IdPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/base/views/css-class-postprocessor.js
  var require_css_class_postprocessor = __commonJS({
    "../../node_modules/sprotty/lib/base/views/css-class-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CssClassPostprocessor = void 0;
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_cjs4();
      var CssClassPostprocessor = class CssClassPostprocessor {
        decorate(vnode, element) {
          if (element.cssClasses) {
            for (const cssClass of element.cssClasses)
              (0, vnode_utils_1.setClass)(vnode, cssClass, true);
          }
          const subType = (0, model_utils_1.getSubType)(element);
          if (subType && subType !== element.type) {
            (0, vnode_utils_1.setClass)(vnode, subType, true);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.CssClassPostprocessor = CssClassPostprocessor;
      exports.CssClassPostprocessor = CssClassPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], CssClassPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/base/di.config.js
  var require_di_config = __commonJS({
    "../../node_modules/sprotty/lib/base/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var initialize_canvas_1 = require_initialize_canvas();
      var logging_1 = require_logging();
      var action_dispatcher_1 = require_action_dispatcher();
      var action_handler_1 = require_action_handler();
      var command_stack_1 = require_command_stack();
      var command_stack_options_1 = require_command_stack_options();
      var smodel_factory_1 = require_smodel_factory();
      var animation_frame_syncer_1 = require_animation_frame_syncer();
      var viewer_1 = require_viewer();
      var viewer_options_1 = require_viewer_options();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var vnode_postprocessor_1 = require_vnode_postprocessor();
      var view_1 = require_view();
      var viewer_cache_1 = require_viewer_cache();
      var dom_helper_1 = require_dom_helper();
      var id_postprocessor_1 = require_id_postprocessor();
      var command_registration_1 = require_command_registration();
      var css_class_postprocessor_1 = require_css_class_postprocessor();
      var set_model_1 = require_set_model();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var diagram_locker_1 = require_diagram_locker();
      var defaultContainerModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ILogger).to(logging_1.NullLogger).inSingletonScope();
        bind(types_1.TYPES.LogLevel).toConstantValue(logging_1.LogLevel.warn);
        bind(types_1.TYPES.SModelRegistry).to(smodel_factory_1.SModelRegistry).inSingletonScope();
        bind(action_handler_1.ActionHandlerRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ActionHandlerRegistryProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(action_handler_1.ActionHandlerRegistry));
            });
          };
        });
        bind(types_1.TYPES.ViewRegistry).to(view_1.ViewRegistry).inSingletonScope();
        bind(types_1.TYPES.IModelFactory).to(smodel_factory_1.SModelFactory).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcher).to(action_dispatcher_1.ActionDispatcher).inSingletonScope();
        bind(types_1.TYPES.IActionDispatcherProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.IActionDispatcher));
            });
          };
        });
        bind(types_1.TYPES.IDiagramLocker).to(diagram_locker_1.DefaultDiagramLocker).inSingletonScope();
        bind(command_registration_1.CommandActionHandlerInitializer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IActionHandlerInitializer).toService(command_registration_1.CommandActionHandlerInitializer);
        bind(types_1.TYPES.ICommandStack).to(command_stack_1.CommandStack).inSingletonScope();
        bind(types_1.TYPES.ICommandStackProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve) => {
              resolve(ctx.container.get(types_1.TYPES.ICommandStack));
            });
          };
        });
        bind(types_1.TYPES.CommandStackOptions).toConstantValue((0, command_stack_options_1.defaultCommandStackOptions)());
        bind(viewer_1.ModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.HiddenModelViewer).toSelf().inSingletonScope();
        bind(viewer_1.PopupModelViewer).toSelf().inSingletonScope();
        bind(types_1.TYPES.ModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.ModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.PopupModelViewer).toDynamicValue((ctx) => {
          const container = ctx.container.createChild();
          container.bind(types_1.TYPES.IViewer).toService(viewer_1.PopupModelViewer);
          container.bind(viewer_cache_1.ViewerCache).toSelf();
          return container.get(viewer_cache_1.ViewerCache);
        }).inSingletonScope();
        bind(types_1.TYPES.HiddenModelViewer).toService(viewer_1.HiddenModelViewer);
        bind(types_1.TYPES.IViewerProvider).toDynamicValue((ctx) => {
          return {
            get modelViewer() {
              return ctx.container.get(types_1.TYPES.ModelViewer);
            },
            get hiddenModelViewer() {
              return ctx.container.get(types_1.TYPES.HiddenModelViewer);
            },
            get popupModelViewer() {
              return ctx.container.get(types_1.TYPES.PopupModelViewer);
            }
          };
        });
        bind(types_1.TYPES.ViewerOptions).toConstantValue((0, viewer_options_1.defaultViewerOptions)());
        bind(types_1.TYPES.PatcherProvider).to(viewer_1.PatcherProvider).inSingletonScope();
        bind(types_1.TYPES.DOMHelper).to(dom_helper_1.DOMHelper).inSingletonScope();
        bind(types_1.TYPES.ModelRendererFactory).toFactory((ctx) => {
          return (targetKind, processors, args = {}) => {
            const viewRegistry = ctx.container.get(types_1.TYPES.ViewRegistry);
            return new viewer_1.ModelRenderer(viewRegistry, targetKind, processors, args);
          };
        });
        bind(id_postprocessor_1.IdPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(css_class_postprocessor_1.CssClassPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(css_class_postprocessor_1.CssClassPostprocessor);
        bind(mouse_tool_1.MouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(mouse_tool_1.MouseTool);
        bind(key_tool_1.KeyTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(key_tool_1.KeyTool);
        bind(vnode_postprocessor_1.FocusFixPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(vnode_postprocessor_1.FocusFixPostprocessor);
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(id_postprocessor_1.IdPostprocessor);
        bind(mouse_tool_1.PopupMouseTool).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(mouse_tool_1.PopupMouseTool);
        bind(types_1.TYPES.AnimationFrameSyncer).to(animation_frame_syncer_1.AnimationFrameSyncer).inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, initialize_canvas_1.InitializeCanvasBoundsCommand);
        bind(initialize_canvas_1.CanvasBoundsInitializer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(initialize_canvas_1.CanvasBoundsInitializer);
        (0, command_registration_1.configureCommand)(context, set_model_1.SetModelCommand);
        bind(types_1.TYPES.UIExtensionRegistry).to(ui_extension_registry_1.UIExtensionRegistry).inSingletonScope();
        (0, command_registration_1.configureCommand)(context, ui_extension_registry_1.SetUIExtensionVisibilityCommand);
        bind(mouse_tool_1.MousePositionTracker).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_tool_1.MousePositionTracker);
      });
      exports.default = defaultContainerModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/model.js
  var require_model2 = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SShapeElementImpl = exports.findChildrenAtPosition = exports.getAbsoluteClientBounds = exports.getAbsoluteBounds = exports.isAlignable = exports.isSizeable = exports.isLayoutableChild = exports.isLayoutContainer = exports.isBoundsAware = exports.alignFeature = exports.layoutableChildFeature = exports.layoutContainerFeature = exports.boundsFeature = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var browser_1 = require_browser();
      exports.boundsFeature = Symbol("boundsFeature");
      exports.layoutContainerFeature = Symbol("layoutContainerFeature");
      exports.layoutableChildFeature = Symbol("layoutableChildFeature");
      exports.alignFeature = Symbol("alignFeature");
      function isBoundsAware(element) {
        return "bounds" in element;
      }
      exports.isBoundsAware = isBoundsAware;
      function isLayoutContainer(element) {
        return isBoundsAware(element) && element.hasFeature(exports.layoutContainerFeature) && "layout" in element;
      }
      exports.isLayoutContainer = isLayoutContainer;
      function isLayoutableChild(element) {
        return isBoundsAware(element) && element.hasFeature(exports.layoutableChildFeature);
      }
      exports.isLayoutableChild = isLayoutableChild;
      function isSizeable(element) {
        return element.hasFeature(exports.boundsFeature) && isBoundsAware(element);
      }
      exports.isSizeable = isSizeable;
      function isAlignable(element) {
        return element.hasFeature(exports.alignFeature) && "alignment" in element;
      }
      exports.isAlignable = isAlignable;
      function getAbsoluteBounds(element) {
        const boundsAware = (0, smodel_utils_1.findParentByFeature)(element, isBoundsAware);
        if (boundsAware !== void 0) {
          let bounds = boundsAware.bounds;
          let current = boundsAware;
          while (current instanceof smodel_1.SChildElementImpl) {
            const parent = current.parent;
            bounds = parent.localToParent(bounds);
            current = parent;
          }
          return bounds;
        } else if (element instanceof smodel_1.SModelRootImpl) {
          const canvasBounds = element.canvasBounds;
          return { x: 0, y: 0, width: canvasBounds.width, height: canvasBounds.height };
        } else {
          return geometry_1.Bounds.EMPTY;
        }
      }
      exports.getAbsoluteBounds = getAbsoluteBounds;
      function getAbsoluteClientBounds(element, domHelper, viewerOptions) {
        let x3 = 0;
        let y3 = 0;
        let width = 0;
        let height = 0;
        const svgElementId = domHelper.createUniqueDOMElementId(element);
        const svgElement = document.getElementById(svgElementId);
        if (svgElement) {
          const rect = svgElement.getBoundingClientRect();
          const scroll = (0, browser_1.getWindowScroll)();
          x3 = rect.left + scroll.x;
          y3 = rect.top + scroll.y;
          width = rect.width;
          height = rect.height;
        }
        let container = document.getElementById(viewerOptions.baseDiv);
        if (container) {
          while (container.offsetParent instanceof HTMLElement && (container = container.offsetParent)) {
            x3 -= container.offsetLeft;
            y3 -= container.offsetTop;
          }
        }
        return { x: x3, y: y3, width, height };
      }
      exports.getAbsoluteClientBounds = getAbsoluteClientBounds;
      function findChildrenAtPosition(parent, point) {
        const matches = [];
        doFindChildrenAtPosition(parent, point, matches);
        return matches;
      }
      exports.findChildrenAtPosition = findChildrenAtPosition;
      function doFindChildrenAtPosition(parent, point, matches) {
        parent.children.forEach((child) => {
          if (isBoundsAware(child) && geometry_1.Bounds.includes(child.bounds, point))
            matches.push(child);
          if (child instanceof smodel_1.SParentElementImpl) {
            const newPoint = child.parentToLocal(point);
            doFindChildrenAtPosition(child, newPoint, matches);
          }
        });
      }
      var SShapeElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: point.x + this.position.x,
            y: point.y + this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x - this.position.x,
            y: point.y - this.position.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width;
            result.height = point.height;
          }
          return result;
        }
      };
      exports.SShapeElementImpl = SShapeElementImpl;
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/bounds-manipulation.js
  var require_bounds_manipulation = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/bounds-manipulation.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RequestBoundsCommand = exports.SetBoundsCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model2();
      var SetBoundsCommand = class SetBoundsCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
          this.bounds = [];
        }
        execute(context) {
          this.action.bounds.forEach((b3) => {
            const element = context.root.index.getById(b3.elementId);
            if (element && (0, model_1.isBoundsAware)(element)) {
              this.bounds.push({
                element,
                oldBounds: element.bounds,
                newPosition: b3.newPosition,
                newSize: b3.newSize
              });
            }
          });
          return this.redo(context);
        }
        undo(context) {
          this.bounds.forEach((b3) => b3.element.bounds = b3.oldBounds);
          return context.root;
        }
        redo(context) {
          this.bounds.forEach((b3) => {
            if (b3.newPosition)
              b3.element.bounds = Object.assign(Object.assign({}, b3.newPosition), b3.newSize);
            else
              b3.element.bounds = Object.assign({ x: b3.element.bounds.x, y: b3.element.bounds.y }, b3.newSize);
          });
          return context.root;
        }
      };
      exports.SetBoundsCommand = SetBoundsCommand;
      SetBoundsCommand.KIND = actions_1.SetBoundsAction.KIND;
      exports.SetBoundsCommand = SetBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetBoundsCommand);
      var RequestBoundsCommand = class RequestBoundsCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          return {
            model: context.modelFactory.createRoot(this.action.newRoot),
            modelChanged: true,
            cause: this.action
          };
        }
        get blockUntil() {
          return (action) => action.kind === actions_1.ComputedBoundsAction.KIND;
        }
      };
      exports.RequestBoundsCommand = RequestBoundsCommand;
      RequestBoundsCommand.KIND = actions_1.RequestBoundsAction.KIND;
      exports.RequestBoundsCommand = RequestBoundsCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], RequestBoundsCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/layout.js
  var require_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureLayout = exports.StatefulLayouter = exports.Layouter = exports.LayoutRegistry = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var types_1 = require_types();
      var registry_1 = require_registry();
      var model_1 = require_model2();
      var inversify_2 = require_inversify();
      var LayoutRegistry = class LayoutRegistry extends registry_1.InstanceRegistry {
        constructor(layouts = []) {
          super();
          layouts.forEach((layout) => {
            if (this.hasKey(layout.layoutKind)) {
              this.logger.warn("Layout kind is already defined: ", layout.layoutKind);
            } else {
              this.register(layout.layoutKind, layout.factory());
            }
          });
        }
      };
      exports.LayoutRegistry = LayoutRegistry;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LayoutRegistry.prototype, "logger", void 0);
      exports.LayoutRegistry = LayoutRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.LayoutRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], LayoutRegistry);
      var Layouter = class Layouter {
        layout(element2boundsData) {
          new StatefulLayouter(element2boundsData, this.layoutRegistry, this.logger).layout();
        }
      };
      exports.Layouter = Layouter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LayoutRegistry),
        __metadata("design:type", LayoutRegistry)
      ], Layouter.prototype, "layoutRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], Layouter.prototype, "logger", void 0);
      exports.Layouter = Layouter = __decorate([
        (0, inversify_1.injectable)()
      ], Layouter);
      var StatefulLayouter = class {
        constructor(element2boundsData, layoutRegistry, log) {
          this.element2boundsData = element2boundsData;
          this.layoutRegistry = layoutRegistry;
          this.log = log;
          this.toBeLayouted = [];
          element2boundsData.forEach((data, element) => {
            if ((0, model_1.isLayoutContainer)(element))
              this.toBeLayouted.push(element);
          });
        }
        getBoundsData(element) {
          let boundsData = this.element2boundsData.get(element);
          let bounds = element.bounds;
          if ((0, model_1.isLayoutContainer)(element) && this.toBeLayouted.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
          }
          if (!boundsData) {
            boundsData = {
              bounds,
              boundsChanged: false,
              alignmentChanged: false
            };
            this.element2boundsData.set(element, boundsData);
          }
          return boundsData;
        }
        layout() {
          while (this.toBeLayouted.length > 0) {
            const element = this.toBeLayouted[0];
            this.doLayout(element);
          }
        }
        doLayout(element) {
          const index = this.toBeLayouted.indexOf(element);
          if (index >= 0)
            this.toBeLayouted.splice(index, 1);
          const layout = this.layoutRegistry.get(element.layout);
          if (layout)
            layout.layout(element, this);
          const boundsData = this.element2boundsData.get(element);
          if (boundsData !== void 0 && boundsData.bounds !== void 0) {
            return boundsData.bounds;
          } else {
            this.log.error(element, "Layout failed");
            return geometry_1.Bounds.EMPTY;
          }
        }
      };
      exports.StatefulLayouter = StatefulLayouter;
      function configureLayout(context, kind, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Layouts be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.LayoutRegistration).toDynamicValue((ctx) => ({
          layoutKind: kind,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureLayout = configureLayout;
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js
  var require_hidden_bounds_updater = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/hidden-bounds-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ATTR_BBOX_ELEMENT = exports.HiddenBoundsUpdater = exports.BoundsData = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var browser_1 = require_browser();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var layout_1 = require_layout();
      var model_1 = require_model2();
      var BoundsData = class {
      };
      exports.BoundsData = BoundsData;
      var HiddenBoundsUpdater = class HiddenBoundsUpdater {
        constructor() {
          this.element2boundsData = /* @__PURE__ */ new Map();
        }
        decorate(vnode, element) {
          if ((0, model_1.isSizeable)(element) || (0, model_1.isLayoutContainer)(element)) {
            this.element2boundsData.set(element, {
              vnode,
              bounds: element.bounds,
              boundsChanged: false,
              alignmentChanged: false
            });
          }
          if (element instanceof smodel_1.SModelRootImpl) {
            this.root = element;
          }
          return vnode;
        }
        postUpdate(cause) {
          if (cause === void 0 || cause.kind !== actions_1.RequestBoundsAction.KIND) {
            return;
          }
          const request = cause;
          this.getBoundsFromDOM();
          this.layouter.layout(this.element2boundsData);
          const resizes = [];
          const alignments = [];
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.boundsChanged && boundsData.bounds !== void 0) {
              const resize = {
                elementId: element.id,
                newSize: {
                  width: boundsData.bounds.width,
                  height: boundsData.bounds.height
                }
              };
              if (element instanceof smodel_1.SChildElementImpl && (0, model_1.isLayoutContainer)(element.parent)) {
                resize.newPosition = {
                  x: boundsData.bounds.x,
                  y: boundsData.bounds.y
                };
              }
              resizes.push(resize);
            }
            if (boundsData.alignmentChanged && boundsData.alignment !== void 0) {
              alignments.push({
                elementId: element.id,
                newAlignment: boundsData.alignment
              });
            }
          });
          const revision = this.root !== void 0 ? this.root.revision : void 0;
          this.actionDispatcher.dispatch(actions_1.ComputedBoundsAction.create(resizes, { revision, alignments, requestId: request.requestId }));
          this.element2boundsData.clear();
        }
        getBoundsFromDOM() {
          this.element2boundsData.forEach((boundsData, element) => {
            if (boundsData.bounds && (0, model_1.isSizeable)(element)) {
              const vnode = boundsData.vnode;
              if (vnode && vnode.elm) {
                const boundingBox = this.getBounds(vnode.elm, element);
                if ((0, model_1.isAlignable)(element) && !((0, geometry_1.almostEquals)(boundingBox.x, 0) && (0, geometry_1.almostEquals)(boundingBox.y, 0))) {
                  boundsData.alignment = {
                    x: -boundingBox.x,
                    y: -boundingBox.y
                  };
                  boundsData.alignmentChanged = true;
                }
                const newBounds = {
                  x: element.bounds.x,
                  y: element.bounds.y,
                  width: boundingBox.width,
                  height: boundingBox.height
                };
                if (!((0, geometry_1.almostEquals)(newBounds.x, element.bounds.x) && (0, geometry_1.almostEquals)(newBounds.y, element.bounds.y) && (0, geometry_1.almostEquals)(newBounds.width, element.bounds.width) && (0, geometry_1.almostEquals)(newBounds.height, element.bounds.height))) {
                  boundsData.bounds = newBounds;
                  boundsData.boundsChanged = true;
                }
              }
            }
          });
        }
        /**
         * Compute the bounds of the given DOM element. Override this method to customize how
         * the bounding box of a rendered view is determined.
         *
         * In case your Sprotty model element contains children that are rendered outside of
         * their parent, you can add the `ATTR_BBOX_ELEMENT` attribute to the SVG element
         * that shall be used to compute the bounding box.
         */
        getBounds(elm, element) {
          if (!(0, browser_1.isSVGGraphicsElement)(elm)) {
            this.logger.error(this, "Not an SVG element:", elm);
            return geometry_1.Bounds.EMPTY;
          }
          if (elm.tagName === "g") {
            for (const child of Array.from(elm.children)) {
              if (child.getAttribute(exports.ATTR_BBOX_ELEMENT) !== null) {
                return this.getBounds(child, element);
              }
            }
          }
          const bounds = elm.getBBox();
          return {
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height
          };
        }
      };
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], HiddenBoundsUpdater.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.Layouter),
        __metadata("design:type", layout_1.Layouter)
      ], HiddenBoundsUpdater.prototype, "layouter", void 0);
      exports.HiddenBoundsUpdater = HiddenBoundsUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], HiddenBoundsUpdater);
      exports.ATTR_BBOX_ELEMENT = "bboxElement";
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/abstract-layout.js
  var require_abstract_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/abstract-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractLayout = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var inversify_1 = require_cjs4();
      var AbstractLayout = class AbstractLayout {
        layout(container, layouter) {
          const boundsData = layouter.getBoundsData(container);
          const options = this.getLayoutOptions(container);
          const childrenSize = this.getChildrenSize(container, options, layouter);
          const maxWidth = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.width, options.minWidth) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).width) - options.paddingLeft - options.paddingRight);
          const maxHeight = options.paddingFactor * (options.resizeContainer ? Math.max(childrenSize.height, options.minHeight) : Math.max(0, this.getFixedContainerBounds(container, options, layouter).height) - options.paddingTop - options.paddingBottom);
          if (maxWidth > 0 && maxHeight > 0) {
            const offset = this.layoutChildren(container, layouter, options, maxWidth, maxHeight);
            boundsData.bounds = this.getFinalContainerBounds(container, offset, options, maxWidth, maxHeight);
            boundsData.boundsChanged = true;
          }
        }
        getFinalContainerBounds(container, lastOffset, options, maxWidth, maxHeight) {
          return {
            x: container.bounds.x,
            y: container.bounds.y,
            width: Math.max(options.minWidth, maxWidth + options.paddingLeft + options.paddingRight),
            height: Math.max(options.minHeight, maxHeight + options.paddingTop + options.paddingBottom)
          };
        }
        getFixedContainerBounds(container, layoutOptions, layouter) {
          let currentContainer = container;
          while (true) {
            if ((0, model_1.isBoundsAware)(currentContainer)) {
              const bounds = currentContainer.bounds;
              if ((0, model_1.isLayoutContainer)(currentContainer) && layoutOptions.resizeContainer)
                layouter.log.error(currentContainer, "Resizable container found while detecting fixed bounds");
              if (geometry_1.Dimension.isValid(bounds))
                return bounds;
            }
            if (currentContainer instanceof smodel_1.SChildElementImpl) {
              currentContainer = currentContainer.parent;
            } else {
              layouter.log.error(currentContainer, "Cannot detect fixed bounds");
              return geometry_1.Bounds.EMPTY;
            }
          }
        }
        layoutChildren(container, layouter, containerOptions, maxWidth, maxHeight) {
          let currentOffset = {
            x: containerOptions.paddingLeft + 0.5 * (maxWidth - maxWidth / containerOptions.paddingFactor),
            y: containerOptions.paddingTop + 0.5 * (maxHeight - maxHeight / containerOptions.paddingFactor)
          };
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const boundsData = layouter.getBoundsData(child);
              const bounds = boundsData.bounds;
              const childOptions = this.getChildLayoutOptions(child, containerOptions);
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                currentOffset = this.layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight);
              }
            }
          });
          return currentOffset;
        }
        getDx(hAlign, bounds, maxWidth) {
          switch (hAlign) {
            case "left":
              return 0;
            case "center":
              return 0.5 * (maxWidth - bounds.width);
            case "right":
              return maxWidth - bounds.width;
          }
        }
        getDy(vAlign, bounds, maxHeight) {
          switch (vAlign) {
            case "top":
              return 0;
            case "center":
              return 0.5 * (maxHeight - bounds.height);
            case "bottom":
              return maxHeight - bounds.height;
          }
        }
        getChildLayoutOptions(child, containerOptions) {
          const layoutOptions = child.layoutOptions;
          if (layoutOptions === void 0)
            return containerOptions;
          else
            return this.spread(containerOptions, layoutOptions);
        }
        getLayoutOptions(element) {
          let current = element;
          const allOptions = [];
          while (current !== void 0) {
            const layoutOptions = current.layoutOptions;
            if (layoutOptions !== void 0)
              allOptions.push(layoutOptions);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          return allOptions.reverse().reduce((a3, b3) => {
            return this.spread(a3, b3);
          }, this.getDefaultLayoutOptions());
        }
      };
      exports.AbstractLayout = AbstractLayout;
      exports.AbstractLayout = AbstractLayout = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractLayout);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/vbox-layout.js
  var require_vbox_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/vbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VBoxLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var VBoxLayouter = class VBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = -1;
          let maxHeight = 0;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxHeight += bounds.height;
                if (isFirst)
                  isFirst = false;
                else
                  maxHeight += containerOptions.vGap;
                maxWidth = Math.max(maxWidth, bounds.width);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: currentOffset.y + child.bounds.y - bounds.y,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x,
            y: currentOffset.y + bounds.height + containerOptions.vGap
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            vGap: 1,
            hAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.VBoxLayouter = VBoxLayouter;
      VBoxLayouter.KIND = "vbox";
      exports.VBoxLayouter = VBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], VBoxLayouter);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/hbox-layout.js
  var require_hbox_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/hbox-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HBoxLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var HBoxLayouter = class HBoxLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, containerOptions, layouter) {
          let maxWidth = 0;
          let maxHeight = -1;
          let isFirst = true;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                if (isFirst)
                  isFirst = false;
                else
                  maxWidth += containerOptions.hGap;
                maxWidth += bounds.width;
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: currentOffset.x + child.bounds.x - bounds.x,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return {
            x: currentOffset.x + bounds.width + containerOptions.hGap,
            y: currentOffset.y
          };
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hGap: 1,
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.HBoxLayouter = HBoxLayouter;
      HBoxLayouter.KIND = "hbox";
      exports.HBoxLayouter = HBoxLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], HBoxLayouter);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/stack-layout.js
  var require_stack_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/stack-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StackLayouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var abstract_layout_1 = require_abstract_layout();
      var model_1 = require_model2();
      var StackLayouter = class StackLayouter extends abstract_layout_1.AbstractLayout {
        getChildrenSize(container, options, layouter) {
          let maxWidth = -1;
          let maxHeight = -1;
          container.children.forEach((child) => {
            if ((0, model_1.isLayoutableChild)(child)) {
              const bounds = layouter.getBoundsData(child).bounds;
              if (bounds !== void 0 && geometry_1.Dimension.isValid(bounds)) {
                maxWidth = Math.max(maxWidth, bounds.width);
                maxHeight = Math.max(maxHeight, bounds.height);
              }
            }
          });
          return {
            width: maxWidth,
            height: maxHeight
          };
        }
        layoutChild(child, boundsData, bounds, childOptions, containerOptions, currentOffset, maxWidth, maxHeight) {
          const dx = this.getDx(childOptions.hAlign, bounds, maxWidth);
          const dy = this.getDy(childOptions.vAlign, bounds, maxHeight);
          boundsData.bounds = {
            x: containerOptions.paddingLeft + child.bounds.x - bounds.x + dx,
            y: containerOptions.paddingTop + child.bounds.y - bounds.y + dy,
            width: bounds.width,
            height: bounds.height
          };
          boundsData.boundsChanged = true;
          return currentOffset;
        }
        getDefaultLayoutOptions() {
          return {
            resizeContainer: true,
            paddingTop: 5,
            paddingBottom: 5,
            paddingLeft: 5,
            paddingRight: 5,
            paddingFactor: 1,
            hAlign: "center",
            vAlign: "center",
            minWidth: 0,
            minHeight: 0
          };
        }
        spread(a3, b3) {
          return Object.assign(Object.assign({}, a3), b3);
        }
      };
      exports.StackLayouter = StackLayouter;
      StackLayouter.KIND = "stack";
      exports.StackLayouter = StackLayouter = __decorate([
        (0, inversify_1.injectable)()
      ], StackLayouter);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/views.js
  var require_views = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShapeView = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model2();
      var ShapeView = class ShapeView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (!geometry_1.Dimension.isValid(model.bounds)) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteBounds)(model);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.ShapeView = ShapeView;
      exports.ShapeView = ShapeView = __decorate([
        (0, inversify_1.injectable)()
      ], ShapeView);
    }
  });

  // ../../node_modules/sprotty/lib/features/button/button-handler.js
  var require_button_handler = __commonJS({
    "../../node_modules/sprotty/lib/features/button/button-handler.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.configureButtonHandler = exports.ButtonHandlerRegistry = void 0;
      var inversify_1 = require_cjs4();
      var registry_1 = require_registry();
      var types_1 = require_types();
      var inversify_2 = require_inversify();
      var ButtonHandlerRegistry = class ButtonHandlerRegistry extends registry_1.InstanceRegistry {
        constructor(buttonHandlerRegistrations) {
          super();
          buttonHandlerRegistrations.forEach((factory) => this.register(factory.TYPE, factory.factory()));
        }
      };
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry;
      exports.ButtonHandlerRegistry = ButtonHandlerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IButtonHandlerRegistration)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ButtonHandlerRegistry);
      function configureButtonHandler(context, type, constr) {
        if (typeof constr === "function") {
          if (!(0, inversify_2.isInjectable)(constr)) {
            throw new Error(`Button handlers should be @injectable: ${constr.name}`);
          }
          if (!context.isBound(constr)) {
            context.bind(constr).toSelf();
          }
        }
        context.bind(types_1.TYPES.IButtonHandlerRegistration).toDynamicValue((ctx) => ({
          TYPE: type,
          factory: () => ctx.container.get(constr)
        }));
      }
      exports.configureButtonHandler = configureButtonHandler;
    }
  });

  // ../../node_modules/sprotty/lib/features/fade/model.js
  var require_model3 = __commonJS({
    "../../node_modules/sprotty/lib/features/fade/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFadeable = exports.fadeFeature = void 0;
      exports.fadeFeature = Symbol("fadeFeature");
      function isFadeable(element) {
        return element.hasFeature(exports.fadeFeature) && element["opacity"] !== void 0;
      }
      exports.isFadeable = isFadeable;
    }
  });

  // ../../node_modules/sprotty/lib/features/button/model.js
  var require_model4 = __commonJS({
    "../../node_modules/sprotty/lib/features/button/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SButtonImpl = void 0;
      var model_1 = require_model2();
      var model_2 = require_model3();
      var SButtonImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.enabled = true;
        }
      };
      exports.SButtonImpl = SButtonImpl;
      SButtonImpl.DEFAULT_FEATURES = [model_1.boundsFeature, model_1.layoutableChildFeature, model_2.fadeFeature];
    }
  });

  // ../../node_modules/sprotty/lib/features/nameable/model.js
  var require_model5 = __commonJS({
    "../../node_modules/sprotty/lib/features/nameable/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.name = exports.isNameable = exports.nameFeature = void 0;
      exports.nameFeature = Symbol("nameableFeature");
      function isNameable(element) {
        return element.hasFeature(exports.nameFeature);
      }
      exports.isNameable = isNameable;
      function name(element) {
        if (isNameable(element)) {
          return element.name;
        } else {
          return void 0;
        }
      }
      exports.name = name;
    }
  });

  // ../../node_modules/sprotty/lib/features/command-palette/action-providers.js
  var require_action_providers = __commonJS({
    "../../node_modules/sprotty/lib/features/command-palette/action-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RevealNamedElementActionProvider = exports.CommandPaletteActionProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var iterable_1 = require_iterable();
      var model_1 = require_model5();
      var CommandPaletteActionProviderRegistry = class CommandPaletteActionProviderRegistry {
        constructor(actionProviders = []) {
          this.actionProviders = actionProviders;
        }
        getActions(root, text, lastMousePosition, index) {
          const actionLists = this.actionProviders.map((provider) => provider.getActions(root, text, lastMousePosition, index));
          return Promise.all(actionLists).then((p3) => p3.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc));
        }
      };
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry;
      exports.CommandPaletteActionProviderRegistry = CommandPaletteActionProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.ICommandPaletteActionProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], CommandPaletteActionProviderRegistry);
      var RevealNamedElementActionProvider = class RevealNamedElementActionProvider {
        constructor(logger) {
          this.logger = logger;
        }
        getActions(root, text, lastMousePosition, index) {
          if (index !== void 0 && index % 2 === 0)
            return Promise.resolve(this.createSelectActions(root));
          else
            return Promise.resolve([new action_1.LabeledAction("Select all", [actions_1.SelectAllAction.create()])]);
        }
        createSelectActions(modelRoot) {
          const nameables = (0, iterable_1.toArray)(modelRoot.index.all().filter((element) => (0, model_1.isNameable)(element)));
          return nameables.map((nameable) => new action_1.LabeledAction(`Reveal ${(0, model_1.name)(nameable)}`, [actions_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), actions_1.CenterAction.create([nameable.id])], "eye"));
        }
      };
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider;
      exports.RevealNamedElementActionProvider = RevealNamedElementActionProvider = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.ILogger)),
        __metadata("design:paramtypes", [Object])
      ], RevealNamedElementActionProvider);
    }
  });

  // ../../node_modules/sprotty/lib/utils/codicon.js
  var require_codicon = __commonJS({
    "../../node_modules/sprotty/lib/utils/codicon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.codiconCSSClasses = exports.codiconCSSString = exports.ANIMATION_SPIN = exports.ACTION_ITEM = void 0;
      exports.ACTION_ITEM = "action-item";
      exports.ANIMATION_SPIN = "animation-spin";
      function codiconCSSString(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        return codiconCSSClasses(codiconId, actionItem, animationSpin, additionalCSS).join(" ");
      }
      exports.codiconCSSString = codiconCSSString;
      function codiconCSSClasses(codiconId, actionItem = false, animationSpin = false, additionalCSS = []) {
        const cssClassArray = ["codicon", `codicon-${codiconId}`];
        if (actionItem) {
          cssClassArray.push(exports.ACTION_ITEM);
        }
        if (animationSpin) {
          cssClassArray.push(exports.ANIMATION_SPIN);
        }
        if (additionalCSS.length > 0) {
          cssClassArray.push(...additionalCSS);
        }
        return cssClassArray;
      }
      exports.codiconCSSClasses = codiconCSSClasses;
    }
  });

  // ../../node_modules/sprotty/lib/utils/keyboard.js
  var require_keyboard = __commonJS({
    "../../node_modules/sprotty/lib/utils/keyboard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getActualCode = exports.matchesKeystroke = void 0;
      var browser_1 = require_browser();
      function matchesKeystroke(event, code, ...modifiers) {
        if (getActualCode(event) !== code)
          return false;
        if ((0, browser_1.isMac)()) {
          if (event.ctrlKey !== modifiers.findIndex((m3) => m3 === "ctrl") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m3) => m3 === "meta" || m3 === "ctrlCmd") >= 0)
            return false;
        } else {
          if (event.ctrlKey !== modifiers.findIndex((m3) => m3 === "ctrl" || m3 === "ctrlCmd") >= 0)
            return false;
          if (event.metaKey !== modifiers.findIndex((m3) => m3 === "meta") >= 0)
            return false;
        }
        if (event.altKey !== modifiers.findIndex((m3) => m3 === "alt") >= 0)
          return false;
        if (event.shiftKey !== modifiers.findIndex((m3) => m3 === "shift") >= 0)
          return false;
        return true;
      }
      exports.matchesKeystroke = matchesKeystroke;
      function getActualCode(event) {
        if (event.keyCode) {
          const result = STRING_CODE[event.keyCode];
          if (result !== void 0)
            return result;
        }
        return event.code;
      }
      exports.getActualCode = getActualCode;
      var STRING_CODE = new Array(256);
      (() => {
        function addKeyCode(stringCode, numericCode) {
          if (STRING_CODE[numericCode] === void 0)
            STRING_CODE[numericCode] = stringCode;
        }
        addKeyCode("Pause", 3);
        addKeyCode("Backspace", 8);
        addKeyCode("Tab", 9);
        addKeyCode("Enter", 13);
        addKeyCode("ShiftLeft", 16);
        addKeyCode("ShiftRight", 16);
        addKeyCode("ControlLeft", 17);
        addKeyCode("ControlRight", 17);
        addKeyCode("AltLeft", 18);
        addKeyCode("AltRight", 18);
        addKeyCode("CapsLock", 20);
        addKeyCode("Escape", 27);
        addKeyCode("Space", 32);
        addKeyCode("PageUp", 33);
        addKeyCode("PageDown", 34);
        addKeyCode("End", 35);
        addKeyCode("Home", 36);
        addKeyCode("ArrowLeft", 37);
        addKeyCode("ArrowUp", 38);
        addKeyCode("ArrowRight", 39);
        addKeyCode("ArrowDown", 40);
        addKeyCode("Insert", 45);
        addKeyCode("Delete", 46);
        addKeyCode("Digit1", 49);
        addKeyCode("Digit2", 50);
        addKeyCode("Digit3", 51);
        addKeyCode("Digit4", 52);
        addKeyCode("Digit5", 53);
        addKeyCode("Digit6", 54);
        addKeyCode("Digit7", 55);
        addKeyCode("Digit8", 56);
        addKeyCode("Digit9", 57);
        addKeyCode("Digit0", 48);
        addKeyCode("KeyA", 65);
        addKeyCode("KeyB", 66);
        addKeyCode("KeyC", 67);
        addKeyCode("KeyD", 68);
        addKeyCode("KeyE", 69);
        addKeyCode("KeyF", 70);
        addKeyCode("KeyG", 71);
        addKeyCode("KeyH", 72);
        addKeyCode("KeyI", 73);
        addKeyCode("KeyJ", 74);
        addKeyCode("KeyK", 75);
        addKeyCode("KeyL", 76);
        addKeyCode("KeyM", 77);
        addKeyCode("KeyN", 78);
        addKeyCode("KeyO", 79);
        addKeyCode("KeyP", 80);
        addKeyCode("KeyQ", 81);
        addKeyCode("KeyR", 82);
        addKeyCode("KeyS", 83);
        addKeyCode("KeyT", 84);
        addKeyCode("KeyU", 85);
        addKeyCode("KeyV", 86);
        addKeyCode("KeyW", 87);
        addKeyCode("KeyX", 88);
        addKeyCode("KeyY", 89);
        addKeyCode("KeyZ", 90);
        addKeyCode("OSLeft", 91);
        addKeyCode("MetaLeft", 91);
        addKeyCode("OSRight", 92);
        addKeyCode("MetaRight", 92);
        addKeyCode("ContextMenu", 93);
        addKeyCode("Numpad0", 96);
        addKeyCode("Numpad1", 97);
        addKeyCode("Numpad2", 98);
        addKeyCode("Numpad3", 99);
        addKeyCode("Numpad4", 100);
        addKeyCode("Numpad5", 101);
        addKeyCode("Numpad6", 102);
        addKeyCode("Numpad7", 103);
        addKeyCode("Numpad8", 104);
        addKeyCode("Numpad9", 105);
        addKeyCode("NumpadMultiply", 106);
        addKeyCode("NumpadAdd", 107);
        addKeyCode("NumpadSeparator", 108);
        addKeyCode("NumpadSubtract", 109);
        addKeyCode("NumpadDecimal", 110);
        addKeyCode("NumpadDivide", 111);
        addKeyCode("F1", 112);
        addKeyCode("F2", 113);
        addKeyCode("F3", 114);
        addKeyCode("F4", 115);
        addKeyCode("F5", 116);
        addKeyCode("F6", 117);
        addKeyCode("F7", 118);
        addKeyCode("F8", 119);
        addKeyCode("F9", 120);
        addKeyCode("F10", 121);
        addKeyCode("F11", 122);
        addKeyCode("F12", 123);
        addKeyCode("F13", 124);
        addKeyCode("F14", 125);
        addKeyCode("F15", 126);
        addKeyCode("F16", 127);
        addKeyCode("F17", 128);
        addKeyCode("F18", 129);
        addKeyCode("F19", 130);
        addKeyCode("F20", 131);
        addKeyCode("F21", 132);
        addKeyCode("F22", 133);
        addKeyCode("F23", 134);
        addKeyCode("F24", 135);
        addKeyCode("NumLock", 144);
        addKeyCode("ScrollLock", 145);
        addKeyCode("Semicolon", 186);
        addKeyCode("Equal", 187);
        addKeyCode("Comma", 188);
        addKeyCode("Minus", 189);
        addKeyCode("Period", 190);
        addKeyCode("Slash", 191);
        addKeyCode("Backquote", 192);
        addKeyCode("IntlRo", 193);
        addKeyCode("BracketLeft", 219);
        addKeyCode("Backslash", 220);
        addKeyCode("BracketRight", 221);
        addKeyCode("Quote", 222);
        addKeyCode("IntlYen", 255);
      })();
    }
  });

  // ../../node_modules/sprotty/lib/features/select/model.js
  var require_model6 = __commonJS({
    "../../node_modules/sprotty/lib/features/select/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSelected = exports.isSelectable = exports.selectFeature = void 0;
      exports.selectFeature = Symbol("selectFeature");
      function isSelectable(element) {
        return element.hasFeature(exports.selectFeature);
      }
      exports.isSelectable = isSelectable;
      function isSelected(element) {
        return element !== void 0 && isSelectable(element) && element.selected;
      }
      exports.isSelected = isSelected;
    }
  });

  // ../../node_modules/autocompleter/autocomplete.js
  var require_autocomplete = __commonJS({
    "../../node_modules/autocompleter/autocomplete.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.autocomplete = factory());
      })(exports, (function() {
        "use strict";
        function autocomplete(settings) {
          var doc = document;
          var container = settings.container || doc.createElement("div");
          var preventSubmit = settings.preventSubmit || 0;
          container.id = container.id || "autocomplete-" + uid();
          var containerStyle = container.style;
          var debounceWaitMs = settings.debounceWaitMs || 0;
          var disableAutoSelect = settings.disableAutoSelect || false;
          var customContainerParent = container.parentElement;
          var items = [];
          var inputValue = "";
          var minLen = 2;
          var showOnFocus = settings.showOnFocus;
          var selected;
          var fetchCounter = 0;
          var debounceTimer;
          var destroyed = false;
          var suppressAutocomplete = false;
          if (settings.minLength !== void 0) {
            minLen = settings.minLength;
          }
          if (!settings.input) {
            throw new Error("input undefined");
          }
          var input = settings.input;
          container.className = [container.className, "autocomplete", settings.className || ""].join(" ").trim();
          container.setAttribute("role", "listbox");
          input.setAttribute("role", "combobox");
          input.setAttribute("aria-expanded", "false");
          input.setAttribute("aria-autocomplete", "list");
          input.setAttribute("aria-controls", container.id);
          input.setAttribute("aria-owns", container.id);
          input.setAttribute("aria-activedescendant", "");
          input.setAttribute("aria-haspopup", "listbox");
          containerStyle.position = "absolute";
          function uid() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
          }
          function detach() {
            var parent = container.parentNode;
            if (parent) {
              parent.removeChild(container);
            }
          }
          function clearDebounceTimer() {
            if (debounceTimer) {
              window.clearTimeout(debounceTimer);
            }
          }
          function attach() {
            if (!container.parentNode) {
              (customContainerParent || doc.body).appendChild(container);
            }
          }
          function containerDisplayed() {
            return !!container.parentNode;
          }
          function clear() {
            fetchCounter++;
            items = [];
            inputValue = "";
            selected = void 0;
            input.setAttribute("aria-activedescendant", "");
            input.setAttribute("aria-expanded", "false");
            detach();
          }
          function updatePosition() {
            if (!containerDisplayed()) {
              return;
            }
            input.setAttribute("aria-expanded", "true");
            containerStyle.height = "auto";
            containerStyle.width = input.offsetWidth + "px";
            var maxHeight = 0;
            var inputRect;
            function calc() {
              var docEl = doc.documentElement;
              var clientTop = docEl.clientTop || doc.body.clientTop || 0;
              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
              var scrollTop = window.pageYOffset || docEl.scrollTop;
              var scrollLeft = window.pageXOffset || docEl.scrollLeft;
              inputRect = input.getBoundingClientRect();
              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
              var left = inputRect.left + scrollLeft - clientLeft;
              containerStyle.top = top + "px";
              containerStyle.left = left + "px";
              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);
              if (maxHeight < 0) {
                maxHeight = 0;
              }
              containerStyle.top = top + "px";
              containerStyle.bottom = "";
              containerStyle.left = left + "px";
              containerStyle.maxHeight = maxHeight + "px";
            }
            calc();
            calc();
            if (settings.customize && inputRect) {
              settings.customize(input, inputRect, container, maxHeight);
            }
          }
          function update() {
            container.textContent = "";
            input.setAttribute("aria-activedescendant", "");
            var render = function(item, _3, __) {
              var itemElement = doc.createElement("div");
              itemElement.textContent = item.label || "";
              return itemElement;
            };
            if (settings.render) {
              render = settings.render;
            }
            var renderGroup = function(groupName, _3) {
              var groupDiv = doc.createElement("div");
              groupDiv.textContent = groupName;
              return groupDiv;
            };
            if (settings.renderGroup) {
              renderGroup = settings.renderGroup;
            }
            var fragment = doc.createDocumentFragment();
            var prevGroup = uid();
            items.forEach(function(item, index) {
              if (item.group && item.group !== prevGroup) {
                prevGroup = item.group;
                var groupDiv = renderGroup(item.group, inputValue);
                if (groupDiv) {
                  groupDiv.className += " group";
                  fragment.appendChild(groupDiv);
                }
              }
              var div = render(item, inputValue, index);
              if (div) {
                div.id = container.id + "_" + index;
                div.setAttribute("role", "option");
                div.addEventListener("click", function(ev) {
                  suppressAutocomplete = true;
                  try {
                    settings.onSelect(item, input);
                  } finally {
                    suppressAutocomplete = false;
                  }
                  clear();
                  ev.preventDefault();
                  ev.stopPropagation();
                });
                if (item === selected) {
                  div.className += " selected";
                  div.setAttribute("aria-selected", "true");
                  input.setAttribute("aria-activedescendant", div.id);
                }
                fragment.appendChild(div);
              }
            });
            container.appendChild(fragment);
            if (items.length < 1) {
              if (settings.emptyMsg) {
                var empty = doc.createElement("div");
                empty.id = container.id + "_" + uid();
                empty.className = "empty";
                empty.textContent = settings.emptyMsg;
                container.appendChild(empty);
                input.setAttribute("aria-activedescendant", empty.id);
              } else {
                clear();
                return;
              }
            }
            attach();
            updatePosition();
            updateScroll();
          }
          function updateIfDisplayed() {
            if (containerDisplayed()) {
              update();
            }
          }
          function resizeEventHandler() {
            updateIfDisplayed();
          }
          function scrollEventHandler(e2) {
            if (e2.target !== container) {
              updateIfDisplayed();
            } else {
              e2.preventDefault();
            }
          }
          function inputEventHandler() {
            if (!suppressAutocomplete) {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function updateScroll() {
            var elements = container.getElementsByClassName("selected");
            if (elements.length > 0) {
              var element = elements[0];
              var previous = element.previousElementSibling;
              if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
                element = previous;
              }
              if (element.offsetTop < container.scrollTop) {
                container.scrollTop = element.offsetTop;
              } else {
                var selectBottom = element.offsetTop + element.offsetHeight;
                var containerBottom = container.scrollTop + container.offsetHeight;
                if (selectBottom > containerBottom) {
                  container.scrollTop += selectBottom - containerBottom;
                }
              }
            }
          }
          function selectPreviousSuggestion() {
            var index = items.indexOf(selected);
            selected = index === -1 ? void 0 : items[(index + items.length - 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function selectNextSuggestion() {
            var index = items.indexOf(selected);
            selected = items.length < 1 ? void 0 : index === -1 ? items[0] : items[(index + 1) % items.length];
            updateSelectedSuggestion(index);
          }
          function updateSelectedSuggestion(index) {
            if (items.length > 0) {
              unselectSuggestion(index);
              selectSuggestion(items.indexOf(selected));
              updateScroll();
            }
          }
          function selectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.add("selected");
              element.setAttribute("aria-selected", "true");
              input.setAttribute("aria-activedescendant", element.id);
            }
          }
          function unselectSuggestion(index) {
            var element = doc.getElementById(container.id + "_" + index);
            if (element) {
              element.classList.remove("selected");
              element.removeAttribute("aria-selected");
              input.removeAttribute("aria-activedescendant");
            }
          }
          function handleArrowAndEscapeKeys(ev, key) {
            var containerIsDisplayed = containerDisplayed();
            if (key === "Escape") {
              clear();
            } else {
              if (!containerIsDisplayed || items.length < 1) {
                return;
              }
              key === "ArrowUp" ? selectPreviousSuggestion() : selectNextSuggestion();
            }
            ev.preventDefault();
            if (containerIsDisplayed) {
              ev.stopPropagation();
            }
          }
          function handleEnterKey(ev) {
            if (selected) {
              if (preventSubmit === 2) {
                ev.preventDefault();
              }
              suppressAutocomplete = true;
              try {
                settings.onSelect(selected, input);
              } finally {
                suppressAutocomplete = false;
              }
              clear();
            }
            if (preventSubmit === 1) {
              ev.preventDefault();
            }
          }
          function keydownEventHandler(ev) {
            var key = ev.key;
            switch (key) {
              case "ArrowUp":
              case "ArrowDown":
              case "Escape":
                handleArrowAndEscapeKeys(ev, key);
                break;
              case "Enter":
                handleEnterKey(ev);
                break;
            }
          }
          function focusEventHandler() {
            if (showOnFocus) {
              fetch(
                1
                /* Focus */
              );
            }
          }
          function fetch(trigger) {
            if (input.value.length >= minLen || trigger === 1) {
              clearDebounceTimer();
              debounceTimer = window.setTimeout(function() {
                return startFetch(input.value, trigger, input.selectionStart || 0);
              }, trigger === 0 || trigger === 2 ? debounceWaitMs : 0);
            } else {
              clear();
            }
          }
          function startFetch(inputText, trigger, cursorPos) {
            if (destroyed)
              return;
            var savedFetchCounter = ++fetchCounter;
            settings.fetch(inputText, function(elements) {
              if (fetchCounter === savedFetchCounter && elements) {
                items = elements;
                inputValue = inputText;
                selected = items.length < 1 || disableAutoSelect ? void 0 : items[0];
                update();
              }
            }, trigger, cursorPos);
          }
          function keyupEventHandler(e2) {
            if (settings.keyup) {
              settings.keyup({
                event: e2,
                fetch: function() {
                  return fetch(
                    0
                    /* Keyboard */
                  );
                }
              });
              return;
            }
            if (!containerDisplayed() && e2.key === "ArrowDown") {
              fetch(
                0
                /* Keyboard */
              );
            }
          }
          function clickEventHandler(e2) {
            settings.click && settings.click({
              event: e2,
              fetch: function() {
                return fetch(
                  2
                  /* Mouse */
                );
              }
            });
          }
          function blurEventHandler() {
            setTimeout(function() {
              if (doc.activeElement !== input) {
                clear();
              }
            }, 200);
          }
          function manualFetch() {
            startFetch(input.value, 3, input.selectionStart || 0);
          }
          container.addEventListener("mousedown", function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
          });
          container.addEventListener("focus", function() {
            return input.focus();
          });
          detach();
          function destroy() {
            input.removeEventListener("focus", focusEventHandler);
            input.removeEventListener("keyup", keyupEventHandler);
            input.removeEventListener("click", clickEventHandler);
            input.removeEventListener("keydown", keydownEventHandler);
            input.removeEventListener("input", inputEventHandler);
            input.removeEventListener("blur", blurEventHandler);
            window.removeEventListener("resize", resizeEventHandler);
            doc.removeEventListener("scroll", scrollEventHandler, true);
            input.removeAttribute("role");
            input.removeAttribute("aria-expanded");
            input.removeAttribute("aria-autocomplete");
            input.removeAttribute("aria-controls");
            input.removeAttribute("aria-activedescendant");
            input.removeAttribute("aria-owns");
            input.removeAttribute("aria-haspopup");
            clearDebounceTimer();
            clear();
            destroyed = true;
          }
          input.addEventListener("keyup", keyupEventHandler);
          input.addEventListener("click", clickEventHandler);
          input.addEventListener("keydown", keydownEventHandler);
          input.addEventListener("input", inputEventHandler);
          input.addEventListener("blur", blurEventHandler);
          input.addEventListener("focus", focusEventHandler);
          window.addEventListener("resize", resizeEventHandler);
          doc.addEventListener("scroll", scrollEventHandler, true);
          return {
            destroy,
            fetch: manualFetch
          };
        }
        return autocomplete;
      }));
    }
  });

  // ../../node_modules/sprotty/lib/features/command-palette/command-palette.js
  var require_command_palette = __commonJS({
    "../../node_modules/sprotty/lib/features/command-palette/command-palette.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var CommandPalette_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommandPaletteKeyListener = exports.CommandPalette = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var action_1 = require_action();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var key_tool_1 = require_key_tool();
      var codicon_1 = require_codicon();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var action_providers_1 = require_action_providers();
      var mouse_tool_1 = require_mouse_tool();
      var autocompleter_1 = __importDefault(require_autocomplete());
      var CommandPalette = CommandPalette_1 = class CommandPalette extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.loadingIndicatorClasses = (0, codicon_1.codiconCSSClasses)("loading", false, true, ["loading"]);
          this.xOffset = 20;
          this.yOffset = 20;
          this.defaultWidth = 400;
          this.debounceWaitMs = 100;
          this.noCommandsMsg = "No commands available";
          this.paletteIndex = 0;
        }
        id() {
          return CommandPalette_1.ID;
        }
        containerClass() {
          return "command-palette";
        }
        show(root, ...contextElementIds) {
          super.show(root, ...contextElementIds);
          this.paletteIndex = 0;
          this.contextActions = void 0;
          this.inputElement.value = "";
          this.autoCompleteResult = (0, autocompleter_1.default)(this.autocompleteSettings(root));
          this.inputElement.focus();
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.inputElement.style.width = "100%";
          this.inputElement.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          this.inputElement.addEventListener("keydown", (event) => this.cylceIfInvokePaletteKey(event));
          this.inputElement.onblur = () => window.setTimeout(() => this.hide(), 200);
          containerElement.appendChild(this.inputElement);
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        cylceIfInvokePaletteKey(event) {
          if (CommandPalette_1.isInvokePaletteKey(event)) {
            this.cycle();
          }
        }
        cycle() {
          this.contextActions = void 0;
          this.paletteIndex++;
        }
        onBeforeShow(containerElement, root, ...selectedElementIds) {
          let x3 = this.xOffset;
          let y3 = this.yOffset;
          const selectedElements = (0, iterable_1.toArray)(root.index.all().filter((e2) => (0, model_2.isSelectable)(e2) && e2.selected));
          if (selectedElements.length === 1) {
            const bounds = (0, model_1.getAbsoluteClientBounds)(selectedElements[0], this.domHelper, this.viewerOptions);
            x3 += bounds.x + bounds.width;
            y3 += bounds.y;
          } else {
            const bounds = (0, model_1.getAbsoluteClientBounds)(root, this.domHelper, this.viewerOptions);
            x3 += bounds.x;
            y3 += bounds.y;
          }
          containerElement.style.left = `${x3}px`;
          containerElement.style.top = `${y3}px`;
          containerElement.style.width = `${this.defaultWidth}px`;
        }
        autocompleteSettings(root) {
          return {
            input: this.inputElement,
            emptyMsg: this.noCommandsMsg,
            className: "command-palette-suggestions",
            debounceWaitMs: this.debounceWaitMs,
            showOnFocus: true,
            minLength: -1,
            fetch: (text, update) => this.updateAutoCompleteActions(update, text, root),
            onSelect: (item) => this.onSelect(item),
            render: (item, currentValue) => this.renderLabeledActionSuggestion(item, currentValue),
            customize: (input, inputRect, container, maxHeight) => {
              this.customizeSuggestionContainer(container, inputRect, maxHeight);
            }
          };
        }
        onSelect(item) {
          this.executeAction(item);
          this.hide();
        }
        updateAutoCompleteActions(update, text, root) {
          this.onLoading();
          if (this.contextActions) {
            update(this.filterActions(text, this.contextActions));
            this.onLoaded("success");
          } else {
            this.actionProviderRegistry.getActions(root, text, this.mousePositionTracker.lastPositionOnDiagram, this.paletteIndex).then((actions) => {
              this.contextActions = actions;
              update(this.filterActions(text, actions));
              this.onLoaded("success");
            }).catch((reason) => {
              this.logger.error(this, "Failed to obtain actions from command palette action providers", reason);
              this.onLoaded("error");
            });
          }
        }
        onLoading() {
          if (this.loadingIndicator && this.containerElement.contains(this.loadingIndicator)) {
            return;
          }
          this.loadingIndicator = document.createElement("span");
          this.loadingIndicator.classList.add(...this.loadingIndicatorClasses);
          this.containerElement.appendChild(this.loadingIndicator);
        }
        onLoaded(success) {
          if (this.containerElement.contains(this.loadingIndicator)) {
            this.containerElement.removeChild(this.loadingIndicator);
          }
        }
        renderLabeledActionSuggestion(item, value) {
          const itemElement = document.createElement("div");
          const wordMatcher = espaceForRegExp(value).split(" ").join("|");
          const regex = new RegExp(wordMatcher, "gi");
          if (item.icon) {
            this.renderIcon(itemElement, item.icon);
          }
          if (value.length > 0) {
            itemElement.innerHTML += item.label.replace(regex, (match) => "<em>" + match + "</em>").replace(/ /g, "&nbsp;");
          } else {
            itemElement.innerHTML += item.label.replace(/ /g, "&nbsp;");
          }
          return itemElement;
        }
        renderIcon(itemElement, iconId) {
          itemElement.innerHTML += `<span class="icon ${this.getCodicon(iconId)}"></span>`;
        }
        getFontAwesomeIcon(iconId) {
          return `fa fa-${iconId}`;
        }
        getCodicon(iconId) {
          return (0, codicon_1.codiconCSSString)(iconId);
        }
        filterActions(filterText, actions) {
          return (0, iterable_1.toArray)(actions.filter((action) => {
            const label = action.label.toLowerCase();
            const searchWords = filterText.split(" ");
            return searchWords.every((word) => label.indexOf(word.toLowerCase()) !== -1);
          }));
        }
        customizeSuggestionContainer(container, inputRect, maxHeight) {
          container.style.position = "fixed";
          if (this.containerElement) {
            this.containerElement.appendChild(container);
          }
        }
        hide() {
          super.hide();
          if (this.autoCompleteResult) {
            this.autoCompleteResult.destroy();
          }
        }
        executeAction(input) {
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll(toActionArray(input))).catch((reason) => this.logger.error(this, "No action dispatcher available to execute command palette action", reason));
        }
      };
      exports.CommandPalette = CommandPalette;
      CommandPalette.ID = "command-palette";
      CommandPalette.isInvokePaletteKey = (event) => (0, keyboard_1.matchesKeystroke)(event, "Space", "ctrl");
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], CommandPalette.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ICommandPaletteActionProviderRegistry),
        __metadata("design:type", action_providers_1.CommandPaletteActionProviderRegistry)
      ], CommandPalette.prototype, "actionProviderRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], CommandPalette.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], CommandPalette.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(mouse_tool_1.MousePositionTracker),
        __metadata("design:type", mouse_tool_1.MousePositionTracker)
      ], CommandPalette.prototype, "mousePositionTracker", void 0);
      exports.CommandPalette = CommandPalette = CommandPalette_1 = __decorate([
        (0, inversify_1.injectable)()
      ], CommandPalette);
      function toActionArray(input) {
        if ((0, action_1.isLabeledAction)(input)) {
          return input.actions;
        } else if ((0, actions_1.isAction)(input)) {
          return [input];
        }
        return [];
      }
      function espaceForRegExp(value) {
        return value.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }
      var CommandPaletteKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: false, contextElementsId: [] })];
          } else if (CommandPalette.isInvokePaletteKey(event)) {
            const selectedElements = (0, iterable_1.toArray)(element.index.all().filter((e2) => (0, model_2.isSelectable)(e2) && e2.selected).map((e2) => e2.id));
            return [ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: CommandPalette.ID, visible: true, contextElementsId: selectedElements })];
          }
          return [];
        }
      };
      exports.CommandPaletteKeyListener = CommandPaletteKeyListener;
    }
  });

  // ../../node_modules/sprotty/lib/features/context-menu/context-menu-service.js
  var require_context_menu_service = __commonJS({
    "../../node_modules/sprotty/lib/features/context-menu/context-menu-service.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toAnchor = void 0;
      function toAnchor(anchor) {
        return anchor instanceof HTMLElement ? { x: anchor.offsetLeft, y: anchor.offsetTop } : anchor;
      }
      exports.toAnchor = toAnchor;
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/delete.js
  var require_delete = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/delete.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteElementCommand = exports.ResolvedDelete = exports.isDeletable = exports.deletableFeature = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      exports.deletableFeature = Symbol("deletableFeature");
      function isDeletable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.hasFeature(exports.deletableFeature);
      }
      exports.isDeletable = isDeletable;
      var ResolvedDelete = class {
      };
      exports.ResolvedDelete = ResolvedDelete;
      var DeleteElementCommand = class DeleteElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedDeletes = [];
        }
        execute(context) {
          const index = context.root.index;
          for (const id of this.action.elementIds) {
            const element = index.getById(id);
            if (element && isDeletable(element)) {
              this.resolvedDeletes.push({ child: element, parent: element.parent });
              element.parent.remove(element);
            }
          }
          return context.root;
        }
        undo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.add(resolvedDelete.child);
          return context.root;
        }
        redo(context) {
          for (const resolvedDelete of this.resolvedDeletes)
            resolvedDelete.parent.remove(resolvedDelete.child);
          return context.root;
        }
      };
      exports.DeleteElementCommand = DeleteElementCommand;
      DeleteElementCommand.KIND = actions_1.DeleteElementAction.KIND;
      exports.DeleteElementCommand = DeleteElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], DeleteElementCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/context-menu/menu-providers.js
  var require_menu_providers = __commonJS({
    "../../node_modules/sprotty/lib/features/context-menu/menu-providers.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DeleteContextMenuItemProvider = exports.ContextMenuProviderRegistry = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var delete_1 = require_delete();
      var model_1 = require_model6();
      var sprotty_protocol_1 = require_lib();
      var ContextMenuProviderRegistry = class ContextMenuProviderRegistry {
        constructor(menuProviders = []) {
          this.menuProviders = menuProviders;
        }
        getItems(root, lastMousePosition) {
          const menues = this.menuProviders.map((provider) => provider.getItems(root, lastMousePosition));
          return Promise.all(menues).then(this.flattenAndRestructure);
        }
        flattenAndRestructure(p3) {
          let menuItems = p3.reduce((acc, promise) => promise !== void 0 ? acc.concat(promise) : acc, []);
          const menuItemsWithParentId = menuItems.filter((menuItem) => menuItem.parentId);
          for (const menuItem of menuItemsWithParentId) {
            if (menuItem.parentId) {
              const fragments = menuItem.parentId.split(".");
              let matchingParent = void 0;
              let nextParents = menuItems;
              for (const fragment of fragments) {
                matchingParent = nextParents.find((item) => fragment === item.id);
                if (matchingParent && matchingParent.children)
                  nextParents = matchingParent.children;
              }
              if (matchingParent) {
                if (matchingParent.children) {
                  matchingParent.children.push(menuItem);
                } else {
                  matchingParent.children = [menuItem];
                }
                menuItems = menuItems.filter((item) => item !== menuItem);
              }
            }
          }
          return menuItems;
        }
      };
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry;
      exports.ContextMenuProviderRegistry = ContextMenuProviderRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IContextMenuItemProvider)),
        __param(0, (0, inversify_1.optional)()),
        __metadata("design:paramtypes", [Array])
      ], ContextMenuProviderRegistry);
      var DeleteContextMenuItemProvider = class DeleteContextMenuItemProvider {
        getItems(root, lastMousePosition) {
          const selectedElements = Array.from(root.index.all().filter(model_1.isSelected).filter(delete_1.isDeletable));
          return Promise.resolve([
            {
              id: "delete",
              label: "Delete",
              sortString: "d",
              group: "edit",
              actions: [sprotty_protocol_1.DeleteElementAction.create(selectedElements.map((e2) => e2.id))],
              isEnabled: () => selectedElements.length > 0
            }
          ]);
        }
      };
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider;
      exports.DeleteContextMenuItemProvider = DeleteContextMenuItemProvider = __decorate([
        (0, inversify_1.injectable)()
      ], DeleteContextMenuItemProvider);
    }
  });

  // ../../node_modules/sprotty/lib/features/context-menu/mouse-listener.js
  var require_mouse_listener = __commonJS({
    "../../node_modules/sprotty/lib/features/context-menu/mouse-listener.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ContextMenuMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var model_1 = require_model6();
      var menu_providers_1 = require_menu_providers();
      var ContextMenuMouseListener = class ContextMenuMouseListener extends mouse_tool_1.MouseListener {
        constructor(contextMenuService, menuProvider) {
          super();
          this.contextMenuService = contextMenuService;
          this.menuProvider = menuProvider;
        }
        contextMenu(target, event) {
          this.showContextMenu(target, event);
          return [];
        }
        async showContextMenu(target, event) {
          let menuService;
          try {
            menuService = await this.contextMenuService();
          } catch (rejected) {
            return;
          }
          let isTargetSelected = false;
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isSelectable);
          if (selectableTarget) {
            isTargetSelected = selectableTarget.selected;
            selectableTarget.selected = true;
          }
          const root = target.root;
          const mousePosition = { x: event.x, y: event.y };
          if (target.id === root.id || (0, model_1.isSelected)(selectableTarget)) {
            const menuItems = await this.menuProvider.getItems(root, mousePosition);
            const restoreSelection = () => {
              if (selectableTarget)
                selectableTarget.selected = isTargetSelected;
            };
            menuService.show(menuItems, mousePosition, restoreSelection);
          } else {
            if ((0, model_1.isSelectable)(target)) {
              const options = { selectedElementsIDs: [target.id], deselectedElementsIDs: Array.from(root.index.all().filter(model_1.isSelected), (val) => {
                return val.id;
              }) };
              await this.actionDispatcher.dispatch(actions_1.SelectAction.create(options));
            }
            const items = await this.menuProvider.getItems(root, mousePosition);
            menuService.show(items, mousePosition);
          }
        }
      };
      exports.ContextMenuMouseListener = ContextMenuMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ContextMenuMouseListener.prototype, "actionDispatcher", void 0);
      exports.ContextMenuMouseListener = ContextMenuMouseListener = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.IContextMenuServiceProvider)),
        __param(1, (0, inversify_1.inject)(types_1.TYPES.IContextMenuProviderRegistry)),
        __metadata("design:paramtypes", [Function, menu_providers_1.ContextMenuProviderRegistry])
      ], ContextMenuMouseListener);
    }
  });

  // ../../node_modules/sprotty/lib/features/hover/model.js
  var require_model7 = __commonJS({
    "../../node_modules/sprotty/lib/features/hover/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasPopupFeature = exports.popupFeature = exports.isHoverable = exports.hoverFeedbackFeature = void 0;
      exports.hoverFeedbackFeature = Symbol("hoverFeedbackFeature");
      function isHoverable(element) {
        return element.hasFeature(exports.hoverFeedbackFeature);
      }
      exports.isHoverable = isHoverable;
      exports.popupFeature = Symbol("popupFeature");
      function hasPopupFeature(element) {
        return element.hasFeature(exports.popupFeature);
      }
      exports.hasPopupFeature = hasPopupFeature;
    }
  });

  // ../../node_modules/sprotty/lib/features/move/model.js
  var require_model8 = __commonJS({
    "../../node_modules/sprotty/lib/features/move/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isMoveable = exports.isLocateable = exports.moveFeature = void 0;
      var object_1 = require_object();
      exports.moveFeature = Symbol("moveFeature");
      function isLocateable(element) {
        return (0, object_1.hasOwnProperty)(element, "position");
      }
      exports.isLocateable = isLocateable;
      function isMoveable(element) {
        return element.hasFeature(exports.moveFeature) && isLocateable(element);
      }
      exports.isMoveable = isMoveable;
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/model.js
  var require_model9 = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID = exports.SDanglingAnchorImpl = exports.SRoutingHandleImpl = exports.SConnectableElementImpl = exports.getRouteBounds = exports.getAbsoluteRouteBounds = exports.isConnectable = exports.connectableFeature = exports.SRoutableElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var delete_1 = require_delete();
      var model_2 = require_model6();
      var model_3 = require_model7();
      var model_4 = require_model8();
      var SRoutableElementImpl = class extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.routingPoints = [];
        }
        get source() {
          return this.index.getById(this.sourceId);
        }
        get target() {
          return this.index.getById(this.targetId);
        }
        get bounds() {
          return this.routingPoints.reduce((bounds, routingPoint) => geometry_1.Bounds.combine(bounds, {
            x: routingPoint.x,
            y: routingPoint.y,
            width: 0,
            height: 0
          }), geometry_1.Bounds.EMPTY);
        }
      };
      exports.SRoutableElementImpl = SRoutableElementImpl;
      exports.connectableFeature = Symbol("connectableFeature");
      function isConnectable(element) {
        return element.hasFeature(exports.connectableFeature) && element.canConnect;
      }
      exports.isConnectable = isConnectable;
      function getAbsoluteRouteBounds(model, route = model.routingPoints) {
        let bounds = getRouteBounds(route);
        let current = model;
        while (current instanceof smodel_1.SChildElementImpl) {
          const parent = current.parent;
          bounds = parent.localToParent(bounds);
          current = parent;
        }
        return bounds;
      }
      exports.getAbsoluteRouteBounds = getAbsoluteRouteBounds;
      function getRouteBounds(route) {
        const bounds = { x: NaN, y: NaN, width: 0, height: 0 };
        for (const point of route) {
          if (isNaN(bounds.x)) {
            bounds.x = point.x;
            bounds.y = point.y;
          } else {
            if (point.x < bounds.x) {
              bounds.width += bounds.x - point.x;
              bounds.x = point.x;
            } else if (point.x > bounds.x + bounds.width) {
              bounds.width = point.x - bounds.x;
            }
            if (point.y < bounds.y) {
              bounds.height += bounds.y - point.y;
              bounds.y = point.y;
            } else if (point.y > bounds.y + bounds.height) {
              bounds.height = point.y - bounds.y;
            }
          }
        }
        return bounds;
      }
      exports.getRouteBounds = getRouteBounds;
      var SConnectableElementImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.strokeWidth = 0;
        }
        get anchorKind() {
          return void 0;
        }
        /**
         * The incoming edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get incomingEdges() {
          const allEdges = this.index.all().filter((e2) => e2 instanceof SRoutableElementImpl);
          return allEdges.filter((e2) => e2.targetId === this.id);
        }
        /**
         * The outgoing edges of this connectable element. They are resolved by the index, which must
         * be an `SGraphIndex` for efficient lookup.
         */
        get outgoingEdges() {
          const allEdges = this.index.all().filter((e2) => e2 instanceof SRoutableElementImpl);
          return allEdges.filter((e2) => e2.sourceId === this.id);
        }
        canConnect(routable, role) {
          return true;
        }
      };
      exports.SConnectableElementImpl = SConnectableElementImpl;
      var SRoutingHandleImpl = class _SRoutingHandleImpl extends smodel_1.SChildElementImpl {
        constructor() {
          super(...arguments);
          this.editMode = false;
          this.hoverFeedback = false;
          this.selected = false;
        }
        /**
         * SRoutingHandles are created using the constructor, so we hard-wire the
         * default features
         */
        hasFeature(feature) {
          return _SRoutingHandleImpl.DEFAULT_FEATURES.indexOf(feature) !== -1;
        }
      };
      exports.SRoutingHandleImpl = SRoutingHandleImpl;
      SRoutingHandleImpl.DEFAULT_FEATURES = [model_2.selectFeature, model_4.moveFeature, model_3.hoverFeedbackFeature];
      var SDanglingAnchorImpl = class extends SConnectableElementImpl {
        constructor() {
          super();
          this.type = "dangling-anchor";
          this.size = { width: 0, height: 0 };
        }
      };
      exports.SDanglingAnchorImpl = SDanglingAnchorImpl;
      SDanglingAnchorImpl.DEFAULT_FEATURES = [delete_1.deletableFeature];
      exports.edgeInProgressID = "edge-in-progress";
      exports.edgeInProgressTargetHandleID = exports.edgeInProgressID + "-target-anchor";
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-layout/model.js
  var require_model10 = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-layout/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DEFAULT_EDGE_PLACEMENT = exports.EdgePlacement = exports.checkEdgePlacement = exports.isEdgeLayoutable = exports.edgeLayoutFeature = void 0;
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model9();
      exports.edgeLayoutFeature = Symbol("edgeLayout");
      function isEdgeLayoutable(element) {
        return element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_2.SRoutableElementImpl && (0, model_1.isBoundsAware)(element) && element.hasFeature(exports.edgeLayoutFeature);
      }
      exports.isEdgeLayoutable = isEdgeLayoutable;
      function checkEdgePlacement(element) {
        return "edgePlacement" in element;
      }
      exports.checkEdgePlacement = checkEdgePlacement;
      var EdgePlacement = class extends Object {
      };
      exports.EdgePlacement = EdgePlacement;
      exports.DEFAULT_EDGE_PLACEMENT = {
        rotate: true,
        side: "top",
        position: 0.5,
        offset: 7
      };
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/model.js
  var require_model11 = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isWithEditableLabel = exports.withEditLabelFeature = exports.isEditableLabel = exports.editLabelFeature = exports.canEditRouting = exports.editFeature = void 0;
      var model_1 = require_model9();
      exports.editFeature = Symbol("editFeature");
      function canEditRouting(element) {
        return element instanceof model_1.SRoutableElementImpl && element.hasFeature(exports.editFeature);
      }
      exports.canEditRouting = canEditRouting;
      exports.editLabelFeature = Symbol("editLabelFeature");
      function isEditableLabel(element) {
        return "text" in element && element.hasFeature(exports.editLabelFeature);
      }
      exports.isEditableLabel = isEditableLabel;
      exports.withEditLabelFeature = Symbol("withEditLabelFeature");
      function isWithEditableLabel(element) {
        return "editableLabel" in element && element.hasFeature(exports.withEditLabelFeature);
      }
      exports.isWithEditableLabel = isWithEditableLabel;
    }
  });

  // ../../node_modules/sprotty/lib/utils/geometry.js
  var require_geometry2 = __commonJS({
    "../../node_modules/sprotty/lib/utils/geometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limit = exports.intersection = exports.PointToPointLine = exports.Diamond = void 0;
      var sprotty_protocol_1 = require_lib();
      var Diamond = class {
        constructor(bounds) {
          this.bounds = bounds;
        }
        get topPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y
          };
        }
        get rightPoint() {
          return {
            x: this.bounds.x + this.bounds.width,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get bottomPoint() {
          return {
            x: this.bounds.x + this.bounds.width / 2,
            y: this.bounds.y + this.bounds.height
          };
        }
        get leftPoint() {
          return {
            x: this.bounds.x,
            y: this.bounds.y + this.bounds.height / 2
          };
        }
        get topRightSideLine() {
          return new PointToPointLine(this.topPoint, this.rightPoint);
        }
        get topLeftSideLine() {
          return new PointToPointLine(this.topPoint, this.leftPoint);
        }
        get bottomRightSideLine() {
          return new PointToPointLine(this.bottomPoint, this.rightPoint);
        }
        get bottomLeftSideLine() {
          return new PointToPointLine(this.bottomPoint, this.leftPoint);
        }
        /**
         * Return the closest side of this diamond to the specified `refPoint`.
         * @param {Point} refPoint a reference point
         * @returns {Line} a line representing the closest side
         */
        closestSideLine(refPoint) {
          const c3 = sprotty_protocol_1.Bounds.center(this.bounds);
          if (refPoint.x > c3.x) {
            if (refPoint.y > c3.y) {
              return this.bottomRightSideLine;
            } else {
              return this.topRightSideLine;
            }
          } else {
            if (refPoint.y > c3.y) {
              return this.bottomLeftSideLine;
            } else {
              return this.topLeftSideLine;
            }
          }
        }
      };
      exports.Diamond = Diamond;
      var PointToPointLine = class {
        constructor(p1, p22) {
          this.p1 = p1;
          this.p2 = p22;
        }
        get a() {
          return this.p1.y - this.p2.y;
        }
        get b() {
          return this.p2.x - this.p1.x;
        }
        get c() {
          return this.p2.x * this.p1.y - this.p1.x * this.p2.y;
        }
        /**
         * The counter-clockwise angle of this line relative to the x-axis.
         */
        get angle() {
          return Math.atan2(-this.a, this.b);
        }
        /**
         * The slope of the line.
         * A vertical line returns `undefined`.
         */
        get slope() {
          if (this.b === 0)
            return void 0;
          return this.a / this.b;
        }
        /**
         * The slope of the line or `Number.MAX_SAFE_INTEGER` if vertical.
         */
        get slopeOrMax() {
          if (this.slope === void 0) {
            return Number.MAX_SAFE_INTEGER;
          }
          return this.slope;
        }
        /**
         * The direction of this line, such as 'north', 'south', or 'south-west'.
         */
        get direction() {
          const hDegrees = (0, sprotty_protocol_1.toDegrees)(this.angle);
          const degrees = hDegrees < 0 ? 360 + hDegrees : hDegrees;
          if (degrees === 90) {
            return "south";
          } else if (degrees === 0 || degrees === 360) {
            return "east";
          } else if (degrees === 270) {
            return "north";
          } else if (degrees === 180) {
            return "west";
          } else if (degrees > 0 && degrees < 90) {
            return "south-east";
          } else if (degrees > 90 && degrees < 180) {
            return "south-west";
          } else if (degrees > 180 && degrees < 270) {
            return "north-west";
          } else if (degrees > 270 && degrees < 360) {
            return "north-east";
          }
          throw new Error(`Cannot determine direction of line (${this.p1.x},${this.p1.y}) to (${this.p2.x},${this.p2.y})`);
        }
        /**
         * @param otherLine the other line
         * @returns the intersection point between `this` line and the `otherLine` if exists, or `undefined`.
         */
        intersection(otherLine) {
          if (this.hasIndistinctPoints(otherLine)) {
            return void 0;
          }
          const x1 = this.p1.x;
          const y1 = this.p1.y;
          const x22 = this.p2.x;
          const y22 = this.p2.y;
          const x3 = otherLine.p1.x;
          const y3 = otherLine.p1.y;
          const x4 = otherLine.p2.x;
          const y4 = otherLine.p2.y;
          const denominator = (y4 - y3) * (x22 - x1) - (x4 - x3) * (y22 - y1);
          if (denominator === 0) {
            return void 0;
          }
          const numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
          const numeratorB = (x22 - x1) * (y1 - y3) - (y22 - y1) * (x1 - x3);
          if (numeratorA === 0 && numeratorB === 0) {
            return void 0;
          }
          const determinantA = numeratorA / denominator;
          const determinantB = numeratorB / denominator;
          if (determinantA < 0 || determinantA > 1 || determinantB < 0 || determinantB > 1) {
            return void 0;
          }
          const x5 = x1 + determinantA * (x22 - x1);
          const y5 = y1 + determinantA * (y22 - y1);
          return { x: x5, y: y5 };
        }
        /**
         * @param otherLine the other line
         * @returns whether the start and end point of this line is does not have distinct start
         * or end points with the `otherLine`
         */
        hasIndistinctPoints(otherLine) {
          return sprotty_protocol_1.Point.equals(this.p1, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p1, otherLine.p2) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p1) || sprotty_protocol_1.Point.equals(this.p2, otherLine.p2);
        }
      };
      exports.PointToPointLine = PointToPointLine;
      function intersection(l1, l22) {
        return {
          x: (l1.c * l22.b - l22.c * l1.b) / (l1.a * l22.b - l22.a * l1.b),
          y: (l1.a * l22.c - l22.a * l1.c) / (l1.a * l22.b - l22.a * l1.b)
        };
      }
      exports.intersection = intersection;
      function limit(value, limits) {
        if (value < limits.min) {
          return limits.min;
        }
        if (value > limits.max) {
          return limits.max;
        }
        return value;
      }
      exports.limit = limit;
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/model.js
  var require_model12 = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.limitViewport = exports.isViewport = exports.viewportFeature = void 0;
      var sprotty_protocol_1 = require_lib();
      var smodel_1 = require_smodel();
      var geometry_1 = require_geometry2();
      exports.viewportFeature = Symbol("viewportFeature");
      function isViewport(element) {
        return element instanceof smodel_1.SModelRootImpl && element.hasFeature(exports.viewportFeature) && "zoom" in element && "scroll" in element;
      }
      exports.isViewport = isViewport;
      function limitViewport(viewport, canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits) {
        if (canvasBounds && !sprotty_protocol_1.Dimension.isValid(canvasBounds)) {
          canvasBounds = void 0;
        }
        let zoom = zoomLimits ? (0, geometry_1.limit)(viewport.zoom, zoomLimits) : viewport.zoom;
        if (canvasBounds && horizontalScrollLimits) {
          const minZoom = canvasBounds.width / (horizontalScrollLimits.max - horizontalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        if (canvasBounds && verticalScrollLimits) {
          const minZoom = canvasBounds.height / (verticalScrollLimits.max - verticalScrollLimits.min);
          if (zoom < minZoom) {
            zoom = minZoom;
          }
        }
        let scrollX;
        if (horizontalScrollLimits) {
          const min = horizontalScrollLimits.min;
          const max = canvasBounds ? horizontalScrollLimits.max - canvasBounds.width / zoom : horizontalScrollLimits.max;
          scrollX = (0, geometry_1.limit)(viewport.scroll.x, { min, max });
        } else {
          scrollX = viewport.scroll.x;
        }
        let scrollY;
        if (verticalScrollLimits) {
          const min = verticalScrollLimits.min;
          const max = canvasBounds ? verticalScrollLimits.max - canvasBounds.height / zoom : verticalScrollLimits.max;
          scrollY = (0, geometry_1.limit)(viewport.scroll.y, { min, max });
        } else {
          scrollY = viewport.scroll.y;
        }
        return { scroll: { x: scrollX, y: scrollY }, zoom };
      }
      exports.limitViewport = limitViewport;
    }
  });

  // ../../node_modules/sprotty/lib/features/export/model.js
  var require_model13 = __commonJS({
    "../../node_modules/sprotty/lib/features/export/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExportable = exports.exportFeature = void 0;
      exports.exportFeature = Symbol("exportFeature");
      function isExportable(element) {
        return element.hasFeature(exports.exportFeature);
      }
      exports.isExportable = isExportable;
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/viewport-root.js
  var require_viewport_root = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/viewport-root.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportRootElementImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model12();
      var model_2 = require_model13();
      var ViewportRootElementImpl = class extends smodel_1.SModelRootImpl {
        constructor(index) {
          super(index);
          this.scroll = { x: 0, y: 0 };
          this.zoom = 1;
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
        localToParent(point) {
          const result = {
            x: (point.x - this.scroll.x) * this.zoom,
            y: (point.y - this.scroll.y) * this.zoom,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point)) {
            result.width = point.width * this.zoom;
            result.height = point.height * this.zoom;
          }
          return result;
        }
        parentToLocal(point) {
          const result = {
            x: point.x / this.zoom + this.scroll.x,
            y: point.y / this.zoom + this.scroll.y,
            width: -1,
            height: -1
          };
          if ((0, geometry_1.isBounds)(point) && geometry_1.Dimension.isValid(point)) {
            result.width = point.width / this.zoom;
            result.height = point.height / this.zoom;
          }
          return result;
        }
      };
      exports.ViewportRootElementImpl = ViewportRootElementImpl;
      ViewportRootElementImpl.DEFAULT_FEATURES = [model_1.viewportFeature, model_2.exportFeature];
    }
  });

  // ../../node_modules/sprotty/lib/graph/sgraph.js
  var require_sgraph = __commonJS({
    "../../node_modules/sprotty/lib/graph/sgraph.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SGraphIndex = exports.SCompartmentImpl = exports.SLabelImpl = exports.SEdgeImpl = exports.SPortImpl = exports.SNodeImpl = exports.SGraphImpl = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var delete_1 = require_delete();
      var model_3 = require_model11();
      var model_4 = require_model3();
      var model_5 = require_model7();
      var model_6 = require_model8();
      var model_7 = require_model9();
      var model_8 = require_model6();
      var viewport_root_1 = require_viewport_root();
      var iterable_1 = require_iterable();
      var SGraphImpl2 = class extends viewport_root_1.ViewportRootElementImpl {
        constructor(index = new SGraphIndex()) {
          super(index);
        }
      };
      exports.SGraphImpl = SGraphImpl2;
      var SNodeImpl2 = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        canConnect(routable, role) {
          return this.children.find((c3) => c3 instanceof SPortImpl) === void 0;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          const allEdges = this.index.all().filter((e2) => e2 instanceof SEdgeImpl2);
          return allEdges.filter((e2) => e2.targetId === this.id);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          const allEdges = this.index.all().filter((e2) => e2 instanceof SEdgeImpl2);
          return allEdges.filter((e2) => e2.sourceId === this.id);
        }
      };
      exports.SNodeImpl = SNodeImpl2;
      SNodeImpl2.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_6.moveFeature,
        model_1.layoutContainerFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature,
        model_5.popupFeature
      ];
      var SPortImpl = class extends model_7.SConnectableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
        get incomingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getIncomingEdges(this);
          }
          return super.incomingEdges.filter((e2) => e2 instanceof SEdgeImpl2);
        }
        get outgoingEdges() {
          const index = this.index;
          if (index instanceof SGraphIndex) {
            return index.getOutgoingEdges(this);
          }
          return super.outgoingEdges.filter((e2) => e2 instanceof SEdgeImpl2);
        }
      };
      exports.SPortImpl = SPortImpl;
      SPortImpl.DEFAULT_FEATURES = [
        model_7.connectableFeature,
        model_8.selectFeature,
        model_1.boundsFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SEdgeImpl2 = class extends model_7.SRoutableElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.hoverFeedback = false;
          this.opacity = 1;
        }
      };
      exports.SEdgeImpl = SEdgeImpl2;
      SEdgeImpl2.DEFAULT_FEATURES = [
        model_3.editFeature,
        delete_1.deletableFeature,
        model_8.selectFeature,
        model_4.fadeFeature,
        model_5.hoverFeedbackFeature
      ];
      var SLabelImpl2 = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
          this.opacity = 1;
        }
      };
      exports.SLabelImpl = SLabelImpl2;
      SLabelImpl2.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.alignFeature,
        model_1.layoutableChildFeature,
        model_2.edgeLayoutFeature,
        model_4.fadeFeature
      ];
      var SCompartmentImpl = class extends model_1.SShapeElementImpl {
        constructor() {
          super(...arguments);
          this.opacity = 1;
        }
      };
      exports.SCompartmentImpl = SCompartmentImpl;
      SCompartmentImpl.DEFAULT_FEATURES = [
        model_1.boundsFeature,
        model_1.layoutContainerFeature,
        model_1.layoutableChildFeature,
        model_4.fadeFeature
      ];
      var SGraphIndex = class extends smodel_1.ModelIndexImpl {
        constructor() {
          super(...arguments);
          this.outgoing = /* @__PURE__ */ new Map();
          this.incoming = /* @__PURE__ */ new Map();
        }
        add(element) {
          super.add(element);
          if (element instanceof SEdgeImpl2) {
            if (element.sourceId) {
              const sourceArr = this.outgoing.get(element.sourceId);
              if (sourceArr === void 0)
                this.outgoing.set(element.sourceId, [element]);
              else
                sourceArr.push(element);
            }
            if (element.targetId) {
              const targetArr = this.incoming.get(element.targetId);
              if (targetArr === void 0)
                this.incoming.set(element.targetId, [element]);
              else
                targetArr.push(element);
            }
          }
        }
        remove(element) {
          super.remove(element);
          if (element instanceof SEdgeImpl2) {
            const sourceArr = this.outgoing.get(element.sourceId);
            if (sourceArr !== void 0) {
              const index = sourceArr.indexOf(element);
              if (index >= 0) {
                if (sourceArr.length === 1)
                  this.outgoing.delete(element.sourceId);
                else
                  sourceArr.splice(index, 1);
              }
            }
            const targetArr = this.incoming.get(element.targetId);
            if (targetArr !== void 0) {
              const index = targetArr.indexOf(element);
              if (index >= 0) {
                if (targetArr.length === 1)
                  this.incoming.delete(element.targetId);
                else
                  targetArr.splice(index, 1);
              }
            }
          }
        }
        getAttachedElements(element) {
          return new iterable_1.FluentIterableImpl(() => ({
            outgoing: this.outgoing.get(element.id),
            incoming: this.incoming.get(element.id),
            nextOutgoingIndex: 0,
            nextIncomingIndex: 0
          }), (state) => {
            let index = state.nextOutgoingIndex;
            if (state.outgoing !== void 0 && index < state.outgoing.length) {
              state.nextOutgoingIndex = index + 1;
              return { done: false, value: state.outgoing[index] };
            }
            index = state.nextIncomingIndex;
            if (state.incoming !== void 0) {
              while (index < state.incoming.length) {
                const edge = state.incoming[index];
                if (edge.sourceId !== edge.targetId) {
                  state.nextIncomingIndex = index + 1;
                  return { done: false, value: edge };
                }
                index++;
              }
            }
            return { done: true, value: void 0 };
          });
        }
        getIncomingEdges(element) {
          return this.incoming.get(element.id) || [];
        }
        getOutgoingEdges(element) {
          return this.outgoing.get(element.id) || [];
        }
      };
      exports.SGraphIndex = SGraphIndex;
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/anchor.js
  var require_anchor = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/anchor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnchorComputerRegistry = exports.RECTANGULAR_ANCHOR_KIND = exports.ELLIPTIC_ANCHOR_KIND = exports.DIAMOND_ANCHOR_KIND = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var registry_1 = require_registry();
      exports.DIAMOND_ANCHOR_KIND = "diamond";
      exports.ELLIPTIC_ANCHOR_KIND = "elliptic";
      exports.RECTANGULAR_ANCHOR_KIND = "rectangular";
      var AnchorComputerRegistry = class AnchorComputerRegistry extends registry_1.InstanceRegistry {
        constructor(anchors) {
          super();
          anchors.forEach((anchor) => this.register(anchor.kind, anchor));
        }
        get defaultAnchorKind() {
          return exports.RECTANGULAR_ANCHOR_KIND;
        }
        get(routerKind, anchorKind) {
          return super.get(`${routerKind}:${anchorKind || this.defaultAnchorKind}`);
        }
      };
      exports.AnchorComputerRegistry = AnchorComputerRegistry;
      exports.AnchorComputerRegistry = AnchorComputerRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IAnchorComputer)),
        __metadata("design:paramtypes", [Array])
      ], AnchorComputerRegistry);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/abstract-edge-router.js
  var require_abstract_edge_router = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/abstract-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractEdgeRouter = exports.DefaultAnchors = exports.Side = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var model_2 = require_model9();
      var Side;
      (function(Side2) {
        Side2[Side2["RIGHT"] = 0] = "RIGHT";
        Side2[Side2["LEFT"] = 1] = "LEFT";
        Side2[Side2["TOP"] = 2] = "TOP";
        Side2[Side2["BOTTOM"] = 3] = "BOTTOM";
      })(Side || (exports.Side = Side = {}));
      var DefaultAnchors = class {
        constructor(element, edgeParent, kind) {
          this.element = element;
          this.kind = kind;
          const bounds = element.bounds;
          this.bounds = (0, smodel_utils_1.translateBounds)(bounds, element.parent, edgeParent);
          this.left = { x: this.bounds.x, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.right = { x: this.bounds.x + this.bounds.width, y: this.bounds.y + 0.5 * this.bounds.height, kind };
          this.top = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y, kind };
          this.bottom = { x: this.bounds.x + 0.5 * this.bounds.width, y: this.bounds.y + this.bounds.height, kind };
        }
        get(side) {
          return this[Side[side].toLowerCase()];
        }
        getNearestSide(point) {
          const leftDistance = geometry_1.Point.euclideanDistance(point, this.left);
          const rightDistance = geometry_1.Point.euclideanDistance(point, this.right);
          const topDistance = geometry_1.Point.euclideanDistance(point, this.top);
          const bottomDistance = geometry_1.Point.euclideanDistance(point, this.bottom);
          let currentNearestSide = Side.LEFT;
          let currentMinDist = leftDistance;
          if (rightDistance < currentMinDist) {
            currentMinDist = rightDistance;
            currentNearestSide = Side.RIGHT;
          }
          if (topDistance < currentMinDist) {
            currentMinDist = topDistance;
            currentNearestSide = Side.TOP;
          }
          if (bottomDistance < currentMinDist) {
            currentMinDist = bottomDistance;
            currentNearestSide = Side.BOTTOM;
          }
          return currentNearestSide;
        }
      };
      exports.DefaultAnchors = DefaultAnchors;
      var AbstractEdgeRouter = class AbstractEdgeRouter {
        findOrthogonalIntersection(edge, point) {
          const calcOrthogonalIntersectionForSegment = (p1, p22) => {
            const d3 = geometry_1.Point.subtract(p22, p1);
            const pq = geometry_1.Point.subtract(point, p1);
            const t3 = geometry_1.Point.dotProduct(pq, d3) / geometry_1.Point.dotProduct(d3, d3);
            if (t3 >= 0 && t3 <= 1) {
              return geometry_1.Point.linear(p1, p22, t3);
            } else if (t3 < 0) {
              return p1;
            } else {
              return p22;
            }
          };
          const routedPoints = this.route(edge);
          let intersectionPoint = routedPoints[0];
          let index = 0;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            const intersection = calcOrthogonalIntersectionForSegment(routedPoints[i2], routedPoints[i2 + 1]);
            if (geometry_1.Point.euclideanDistance(point, intersection) < geometry_1.Point.euclideanDistance(point, intersectionPoint)) {
              intersectionPoint = intersection;
              index = i2;
            }
          }
          const derivative = geometry_1.Point.subtract(routedPoints[index + 1], routedPoints[index]);
          return { point: intersectionPoint, derivative };
        }
        pointAt(edge, t3) {
          const segments = this.calculateSegment(edge, t3);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd, lambda } = segments;
          return geometry_1.Point.linear(segmentStart, segmentEnd, lambda);
        }
        derivativeAt(edge, t3) {
          const segments = this.calculateSegment(edge, t3);
          if (!segments)
            return void 0;
          const { segmentStart, segmentEnd } = segments;
          return {
            x: segmentEnd.x - segmentStart.x,
            y: segmentEnd.y - segmentStart.y
          };
        }
        calculateSegment(edge, t3) {
          if (t3 < 0 || t3 > 1)
            return void 0;
          const routedPoints = this.route(edge);
          if (routedPoints.length < 2)
            return void 0;
          const segmentLengths = [];
          let totalLength = 0;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            segmentLengths[i2] = geometry_1.Point.euclideanDistance(routedPoints[i2], routedPoints[i2 + 1]);
            totalLength += segmentLengths[i2];
          }
          let currentLenght = 0;
          const tAsLenght = t3 * totalLength;
          for (let i2 = 0; i2 < routedPoints.length - 1; ++i2) {
            const newLength = currentLenght + segmentLengths[i2];
            if (segmentLengths[i2] > 1e-8) {
              if (newLength >= tAsLenght) {
                const lambda = Math.max(0, tAsLenght - currentLenght) / segmentLengths[i2];
                return {
                  segmentStart: routedPoints[i2],
                  segmentEnd: routedPoints[i2 + 1],
                  lambda
                };
              }
            }
            currentLenght = newLength;
          }
          return {
            segmentEnd: routedPoints.pop(),
            segmentStart: routedPoints.pop(),
            lambda: 1
          };
        }
        addHandle(edge, kind, type, routingPointIndex) {
          const handle = new model_1.SRoutingHandleImpl();
          handle.kind = kind;
          handle.pointIndex = routingPointIndex;
          handle.type = type;
          if (kind === "target" && edge.id === model_1.edgeInProgressID)
            handle.id = model_1.edgeInProgressTargetHandleID;
          edge.add(handle);
          return handle;
        }
        getHandlePosition(edge, route, handle) {
          switch (handle.kind) {
            case "source":
              if (edge.source instanceof model_1.SDanglingAnchorImpl)
                return edge.source.position;
              else
                return route[0];
            case "target":
              if (edge.target instanceof model_1.SDanglingAnchorImpl)
                return edge.target.position;
              else {
                return route[route.length - 1];
              }
            default:
              const position = this.getInnerHandlePosition(edge, route, handle);
              if (position !== void 0)
                return position;
              if (handle.pointIndex >= 0 && handle.pointIndex < edge.routingPoints.length)
                return edge.routingPoints[handle.pointIndex];
          }
          return void 0;
        }
        findRouteSegment(edge, route, handleIndex) {
          const getIndex = (rp) => {
            if (rp.pointIndex !== void 0)
              return rp.pointIndex;
            else if (rp.kind === "target")
              return edge.routingPoints.length;
            else
              return -2;
          };
          let start, end;
          for (const rp of route) {
            const i2 = getIndex(rp);
            if (i2 <= handleIndex && (start === void 0 || i2 > getIndex(start)))
              start = rp;
            if (i2 > handleIndex && (end === void 0 || i2 < getIndex(end)))
              end = rp;
          }
          return { start, end };
        }
        getTranslatedAnchor(connectable, refPoint, refContainer, edge, anchorCorrection = 0) {
          const translatedRefPoint = (0, smodel_utils_1.translatePoint)(refPoint, refContainer, connectable.parent);
          const anchorComputer = this.getAnchorComputer(connectable);
          const strokeCorrection = 0.5 * connectable.strokeWidth;
          const anchor = anchorComputer.getAnchor(connectable, translatedRefPoint, anchorCorrection + strokeCorrection);
          return (0, smodel_utils_1.translatePoint)(anchor, connectable.parent, edge.parent);
        }
        getAnchorComputer(connectable) {
          return this.anchorRegistry.get(this.kind, connectable.anchorKind);
        }
        applyHandleMoves(edge, moves) {
          const remainingMoves = moves.slice();
          moves.forEach((move) => {
            const handle = move.handle;
            if (handle.kind === "source" && !(edge.source instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-source";
              anchor.original = edge.source;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.sourceId = anchor.id;
            } else if (handle.kind === "target" && !(edge.target instanceof model_1.SDanglingAnchorImpl)) {
              const anchor = new model_1.SDanglingAnchorImpl();
              anchor.id = edge.id + "_dangling-target";
              anchor.original = edge.target;
              anchor.position = move.toPosition;
              handle.root.add(anchor);
              handle.danglingAnchor = anchor;
              edge.targetId = anchor.id;
            }
            if (handle.danglingAnchor) {
              handle.danglingAnchor.position = move.toPosition;
              remainingMoves.splice(remainingMoves.indexOf(move), 1);
            }
          });
          if (remainingMoves.length > 0)
            this.applyInnerHandleMoves(edge, remainingMoves);
          this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new DefaultAnchors(edge.target, edge.parent, "target");
          this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors);
        }
        resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors) {
          if (routingPoints.length === 0 || edge.source instanceof model_1.SDanglingAnchorImpl || edge.target instanceof model_1.SDanglingAnchorImpl) {
            const options = this.getOptions(edge);
            const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
            routingPoints.splice(0, routingPoints.length, ...corners);
            if (updateHandles) {
              let maxPointIndex = -2;
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl) {
                  if (child.kind === "target")
                    child.pointIndex = routingPoints.length;
                  else if (child.kind === "line" && child.pointIndex >= routingPoints.length)
                    edge.remove(child);
                  else
                    maxPointIndex = Math.max(child.pointIndex, maxPointIndex);
                }
              });
              for (let i2 = maxPointIndex; i2 < routingPoints.length - 1; ++i2)
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i2);
            }
            return true;
          }
          return false;
        }
        applyReconnect(edge, newSourceId, newTargetId) {
          let hasChanged = false;
          if (newSourceId) {
            const newSource = edge.root.index.getById(newSourceId);
            if (newSource instanceof model_2.SConnectableElementImpl) {
              edge.sourceId = newSource.id;
              hasChanged = true;
            }
          }
          if (newTargetId) {
            const newTarget = edge.root.index.getById(newTargetId);
            if (newTarget instanceof model_2.SConnectableElementImpl) {
              edge.targetId = newTarget.id;
              hasChanged = true;
            }
          }
          if (hasChanged) {
            edge.index.remove(edge);
            if (edge.id === model_1.edgeInProgressID) {
              const idGen = (counter) => `${edge.sourceId}_to_${edge.targetId}_${counter}`;
              let idx = 0;
              let newId = idGen(idx);
              while (edge.index.getById(newId) !== void 0) {
                newId = idGen(++idx);
              }
              edge.id = newId;
              const progressTargetHandle = edge.children.find((child) => child.id === model_1.edgeInProgressTargetHandleID);
              if (progressTargetHandle instanceof model_1.SRoutingHandleImpl) {
                edge.remove(progressTargetHandle);
                if (progressTargetHandle.danglingAnchor) {
                  progressTargetHandle.danglingAnchor.parent.remove(progressTargetHandle.danglingAnchor);
                }
              }
            }
            edge.index.add(edge);
            if (this.getSelfEdgeIndex(edge) > -1) {
              edge.routingPoints = [];
              this.cleanupRoutingPoints(edge, edge.routingPoints, true, true);
            }
          }
        }
        takeSnapshot(edge) {
          return {
            routingPoints: edge.routingPoints.slice(),
            routingHandles: edge.children.filter((child) => child instanceof model_1.SRoutingHandleImpl).map((child) => child),
            routedPoints: this.route(edge),
            router: this,
            source: edge.source,
            target: edge.target
          };
        }
        applySnapshot(edge, snapshot) {
          edge.routingPoints = snapshot.routingPoints;
          edge.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
          edge.routerKind = snapshot.router.kind;
          snapshot.routingHandles.forEach((handle) => edge.add(handle));
          if (snapshot.source)
            edge.sourceId = snapshot.source.id;
          if (snapshot.target)
            edge.targetId = snapshot.target.id;
          edge.root.index.remove(edge);
          edge.root.index.add(edge);
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdgeIndex = this.getSelfEdgeIndex(edge);
          if (selfEdgeIndex >= 0) {
            const standardDist = options.standardDistance;
            const delta = options.selfEdgeOffset * Math.min(sourceAnchors.bounds.width, sourceAnchors.bounds.height);
            switch (selfEdgeIndex % 4) {
              case 0:
                return [
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y + delta },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.BOTTOM).x + delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist }
                ];
              case 1:
                return [
                  { x: sourceAnchors.get(Side.BOTTOM).x - delta, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.BOTTOM).y + standardDist },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y + delta }
                ];
              case 2:
                return [
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.LEFT).y - delta },
                  { x: sourceAnchors.get(Side.LEFT).x - standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.TOP).x - delta, y: sourceAnchors.get(Side.TOP).y - standardDist }
                ];
              case 3:
                return [
                  { x: sourceAnchors.get(Side.TOP).x + delta, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.TOP).y - standardDist },
                  { x: sourceAnchors.get(Side.RIGHT).x + standardDist, y: sourceAnchors.get(Side.RIGHT).y - delta }
                ];
            }
          }
          return [];
        }
        getSelfEdgeIndex(edge) {
          if (!edge.source || edge.source !== edge.target)
            return -1;
          return edge.source.outgoingEdges.filter((otherEdge) => otherEdge.target === edge.source).indexOf(edge);
        }
        commitRoute(edge, routedPoints) {
          const newRoutingPoints = [];
          for (let i2 = 1; i2 < routedPoints.length - 1; ++i2)
            newRoutingPoints.push({ x: routedPoints[i2].x, y: routedPoints[i2].y });
          edge.routingPoints = newRoutingPoints;
        }
      };
      exports.AbstractEdgeRouter = AbstractEdgeRouter;
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], AbstractEdgeRouter.prototype, "anchorRegistry", void 0);
      exports.AbstractEdgeRouter = AbstractEdgeRouter = __decorate([
        (0, inversify_1.injectable)()
      ], AbstractEdgeRouter);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/polyline-edge-router.js
  var require_polyline_edge_router = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/polyline-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var PolylineEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PolylineEdgeRouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var anchor_1 = require_anchor();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var PolylineEdgeRouter = PolylineEdgeRouter_1 = class PolylineEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return PolylineEdgeRouter_1.KIND;
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            removeAngleThreshold: 0.1,
            standardDistance: 20,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          const source = edge.source;
          const target = edge.target;
          if (source === void 0 || target === void 0) {
            return [];
          }
          let sourceAnchor;
          let targetAnchor;
          const options = this.getOptions(edge);
          const routingPoints = edge.routingPoints.length > 0 ? edge.routingPoints : [];
          this.cleanupRoutingPoints(edge, routingPoints, false, false);
          const rpCount = routingPoints !== void 0 ? routingPoints.length : 0;
          if (rpCount === 0) {
            const startRef = geometry_1.Bounds.center(target.bounds);
            sourceAnchor = this.getTranslatedAnchor(source, startRef, target.parent, edge, edge.sourceAnchorCorrection);
            const endRef = geometry_1.Bounds.center(source.bounds);
            targetAnchor = this.getTranslatedAnchor(target, endRef, source.parent, edge, edge.targetAnchorCorrection);
          } else {
            const p0 = routingPoints[0];
            sourceAnchor = this.getTranslatedAnchor(source, p0, edge.parent, edge, edge.sourceAnchorCorrection);
            const pn = routingPoints[rpCount - 1];
            targetAnchor = this.getTranslatedAnchor(target, pn, edge.parent, edge, edge.targetAnchorCorrection);
          }
          const result = [];
          result.push({ kind: "source", x: sourceAnchor.x, y: sourceAnchor.y });
          for (let i2 = 0; i2 < rpCount; i2++) {
            const p3 = routingPoints[i2];
            if (i2 > 0 && i2 < rpCount - 1 || i2 === 0 && geometry_1.Point.maxDistance(sourceAnchor, p3) >= options.minimalPointDistance + (edge.sourceAnchorCorrection || 0) || i2 === rpCount - 1 && geometry_1.Point.maxDistance(p3, targetAnchor) >= options.minimalPointDistance + (edge.targetAnchorCorrection || 0)) {
              result.push({ kind: "linear", x: p3.x, y: p3.y, pointIndex: i2 });
            }
          }
          result.push({ kind: "target", x: targetAnchor.x, y: targetAnchor.y });
          return this.filterEditModeHandles(result, edge, options);
        }
        /**
         * Remove routed points that are in edit mode and for which the angle between the preceding and
         * following points falls below a threshold.
         */
        filterEditModeHandles(route, edge, options) {
          if (edge.children.length === 0)
            return route;
          let i2 = 0;
          while (i2 < route.length) {
            const curr = route[i2];
            if (curr.pointIndex !== void 0) {
              const handle = edge.children.find((child) => child instanceof model_1.SRoutingHandleImpl && child.kind === "junction" && child.pointIndex === curr.pointIndex);
              if (handle !== void 0 && handle.editMode && i2 > 0 && i2 < route.length - 1) {
                const prev = route[i2 - 1], next = route[i2 + 1];
                const prevDiff = { x: prev.x - curr.x, y: prev.y - curr.y };
                const nextDiff = { x: next.x - curr.x, y: next.y - curr.y };
                const angle = (0, geometry_1.angleBetweenPoints)(prevDiff, nextDiff);
                if (Math.abs(Math.PI - angle) < options.removeAngleThreshold) {
                  route.splice(i2, 1);
                  continue;
                }
              }
            }
            i2++;
          }
          return route;
        }
        createRoutingHandles(edge) {
          const rpCount = edge.routingPoints.length;
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "line", "volatile-routing-point", -1);
          for (let i2 = 0; i2 < rpCount; i2++) {
            this.addHandle(edge, "junction", "routing-point", i2);
            this.addHandle(edge, "line", "volatile-routing-point", i2);
          }
          this.addHandle(edge, "target", "routing-point", rpCount);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "line") {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return (0, geometry_1.centerOfLine)(start, end);
          }
          return void 0;
        }
        applyInnerHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            const points = edge.routingPoints;
            let index = handle.pointIndex;
            if (handle.kind === "line") {
              handle.kind = "junction";
              handle.type = "routing-point";
              points.splice(index + 1, 0, move.fromPosition || points[Math.max(index, 0)]);
              edge.children.forEach((child) => {
                if (child instanceof model_1.SRoutingHandleImpl && (child === handle || child.pointIndex > index))
                  child.pointIndex++;
              });
              this.addHandle(edge, "line", "volatile-routing-point", index);
              index++;
              this.addHandle(edge, "line", "volatile-routing-point", index);
            }
            if (index >= 0 && index < points.length) {
              points[index] = move.toPosition;
            }
          });
        }
      };
      exports.PolylineEdgeRouter = PolylineEdgeRouter;
      PolylineEdgeRouter.KIND = "polyline";
      __decorate([
        (0, inversify_1.inject)(anchor_1.AnchorComputerRegistry),
        __metadata("design:type", anchor_1.AnchorComputerRegistry)
      ], PolylineEdgeRouter.prototype, "anchorRegistry", void 0);
      exports.PolylineEdgeRouter = PolylineEdgeRouter = PolylineEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeRouter);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/routing.js
  var require_routing = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeRouting = exports.EdgeRouterRegistry = void 0;
      var inversify_1 = require_cjs4();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var view_1 = require_view();
      var registry_1 = require_registry();
      var model_1 = require_model9();
      var polyline_edge_router_1 = require_polyline_edge_router();
      function isMultipleEdgesRouter(router) {
        return router.routeAll !== void 0;
      }
      var EdgeRouterRegistry = class EdgeRouterRegistry extends registry_1.InstanceRegistry {
        constructor(edgeRouters) {
          super();
          edgeRouters.forEach((router) => this.register(router.kind, router));
        }
        get defaultKind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND;
        }
        get(kind) {
          return super.get(kind || this.defaultKind);
        }
        /**
         * Computes the routes of all edges contained by the specified `parent`.
         * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        routeAllChildren(parent) {
          const routing = this.doRouteAllChildren(parent);
          for (const postProcessor of this.postProcessors) {
            postProcessor.apply(routing, parent);
          }
          return routing;
        }
        /**
         * Recursively traverses the children of `parent`, collects children grouped by router kind,
         * and then routes them either.
         * @param parent the parent to traverse for edges
         * @returns the routes of all edges that are children of `parent`
         */
        doRouteAllChildren(parent) {
          const routing = new EdgeRouting();
          const routersEdges = /* @__PURE__ */ new Map();
          const elementsToProcess = [parent];
          while (elementsToProcess.length > 0) {
            const element = elementsToProcess.shift();
            for (const child of element.children) {
              if (child instanceof model_1.SRoutableElementImpl) {
                const routerKind = child.routerKind || this.defaultKind;
                if (routersEdges.has(routerKind)) {
                  routersEdges.get(routerKind).push(child);
                } else {
                  routersEdges.set(routerKind, [child]);
                }
              }
              if (child instanceof smodel_1.SParentElementImpl) {
                elementsToProcess.push(child);
              }
            }
          }
          routersEdges.forEach((edges, routerKind) => {
            const childRouter = this.get(routerKind);
            if (isMultipleEdgesRouter(childRouter)) {
              routing.setAll(childRouter.routeAll(edges, parent));
            } else {
              for (const edge of edges) {
                routing.set(edge.id, this.route(edge));
              }
            }
          });
          return routing;
        }
        /**
         * Computes or obtains the route of a single edge.
         * @param edge the edge to be routed
         * @param args arguments that may contain an `EdgeRouting` already
         * @returns the route of the specified `edge`
         */
        route(edge, args) {
          const edgeRouting = (0, view_1.findArgValue)(args, "edgeRouting");
          if (edgeRouting) {
            const route = edgeRouting.get(edge.id);
            if (route) {
              return route;
            }
          }
          const router = this.get(edge.routerKind);
          return router.route(edge);
        }
      };
      exports.EdgeRouterRegistry = EdgeRouterRegistry;
      __decorate([
        (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRoutePostprocessor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], EdgeRouterRegistry.prototype, "postProcessors", void 0);
      exports.EdgeRouterRegistry = EdgeRouterRegistry = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.multiInject)(types_1.TYPES.IEdgeRouter)),
        __metadata("design:paramtypes", [Array])
      ], EdgeRouterRegistry);
      var EdgeRouting = class {
        constructor() {
          this.routesMap = /* @__PURE__ */ new Map();
        }
        set(routableId, route) {
          this.routesMap.set(routableId, route);
        }
        setAll(otherRoutes) {
          otherRoutes.routes.forEach((route, routableId) => this.set(routableId, route));
        }
        get(routableId) {
          return this.routesMap.get(routableId);
        }
        get routes() {
          return this.routesMap;
        }
      };
      exports.EdgeRouting = EdgeRouting;
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-layout/edge-layout.js
  var require_edge_layout = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-layout/edge-layout.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EdgeLayoutPostprocessor = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var model_1 = require_model2();
      var model_2 = require_model10();
      var routing_1 = require_routing();
      var types_1 = require_types();
      var model_3 = require_model8();
      var EdgeLayoutPostprocessor = class EdgeLayoutPostprocessor {
        /**
         * Decorates the vnode with the appropriate transformation based on the element's placement and bounds.
         * @param vnode - The vnode to decorate.
         * @param element - The SModelElementImpl to decorate.
         * @returns The decorated vnode.
         */
        decorate(vnode, element) {
          var _a4, _b2, _c, _d;
          if ((0, model_2.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            if (element.bounds !== geometry_1.Bounds.EMPTY) {
              const actualBounds = element.bounds;
              const hasOwnPlacement = (0, model_2.checkEdgePlacement)(element);
              const placement = this.getEdgePlacement(element);
              const edge = element.parent;
              const position = Math.min(1, Math.max(0, placement.position));
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const pointOnEdge = router.pointAt(edge, position);
              let transform = "";
              let derivativeOnEdge = router.derivativeAt(edge, position);
              ;
              if (pointOnEdge) {
                if (hasOwnPlacement) {
                  switch (placement.moveMode) {
                    case "edge":
                      const orthogonalPoint = router.findOrthogonalIntersection(edge, geometry_1.Point.add(pointOnEdge, actualBounds));
                      if (orthogonalPoint) {
                        derivativeOnEdge = orthogonalPoint.derivative;
                        transform += `translate(${orthogonalPoint.point.x}, ${orthogonalPoint.point.y})`;
                      }
                      break;
                    case "free":
                      transform += `translate(${((_a4 = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.x) !== null && _a4 !== void 0 ? _a4 : 0) + actualBounds.x}, ${((_b2 = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.y) !== null && _b2 !== void 0 ? _b2 : 0) + actualBounds.y})`;
                      ;
                      break;
                    case "none":
                      transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
                      break;
                    default:
                      this.logger.error({}, "No moveMode set for edge label. Skipping edge placement.");
                      break;
                  }
                  if (derivativeOnEdge) {
                    const angle = (0, geometry_1.toDegrees)(Math.atan2(derivativeOnEdge.y, derivativeOnEdge.x));
                    if (placement.rotate) {
                      let flippedAngle = angle;
                      if (Math.abs(angle) > 90) {
                        if (angle < 0)
                          flippedAngle += 180;
                        else if (angle > 0)
                          flippedAngle -= 180;
                      }
                      transform += ` rotate(${flippedAngle})`;
                      const alignment = this.getRotatedAlignment(element, placement, flippedAngle !== angle);
                      transform += ` translate(${alignment.x}, ${alignment.y})`;
                    } else {
                      const alignment = this.getAlignment(element, placement, angle);
                      transform += ` translate(${alignment.x}, ${alignment.y})`;
                    }
                  }
                } else {
                  if ((0, model_3.isMoveable)(element)) {
                    transform += `translate(${((_c = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.x) !== null && _c !== void 0 ? _c : 0) + actualBounds.x}, ${((_d = pointOnEdge === null || pointOnEdge === void 0 ? void 0 : pointOnEdge.y) !== null && _d !== void 0 ? _d : 0) + actualBounds.y})`;
                    ;
                  } else {
                    transform += `translate(${pointOnEdge.x}, ${pointOnEdge.y})`;
                  }
                }
              }
              (0, vnode_utils_1.setAttr)(vnode, "transform", transform);
            }
          }
          return vnode;
        }
        getRotatedAlignment(element, placement, flip) {
          let x3 = (0, model_1.isAlignable)(element) ? element.alignment.x : 0;
          let y3 = (0, model_1.isAlignable)(element) ? element.alignment.y : 0;
          const bounds = element.bounds;
          if (placement.side === "on")
            return { x: x3 - 0.5 * bounds.height, y: y3 - 0.5 * bounds.height };
          if (flip) {
            if (placement.position < 0.3333333)
              x3 -= bounds.width + placement.offset;
            else if (placement.position < 0.6666666)
              x3 -= 0.5 * bounds.width;
            else
              x3 += placement.offset;
            switch (placement.side) {
              case "left":
              case "bottom":
                y3 -= placement.offset + bounds.height;
                break;
              case "right":
              case "top":
                y3 += placement.offset;
            }
          } else {
            if (placement.position < 0.3333333)
              x3 += placement.offset;
            else if (placement.position < 0.6666666)
              x3 -= 0.5 * bounds.width;
            else
              x3 -= bounds.width + placement.offset;
            switch (placement.side) {
              case "right":
              case "bottom":
                y3 += -placement.offset - bounds.height;
                break;
              case "left":
              case "top":
                y3 += placement.offset;
            }
          }
          return { x: x3, y: y3 };
        }
        getEdgePlacement(element) {
          let current = element;
          const allPlacements = [];
          while (current !== void 0) {
            const placement = current.edgePlacement;
            if (placement !== void 0)
              allPlacements.push(placement);
            if (current instanceof smodel_1.SChildElementImpl)
              current = current.parent;
            else
              break;
          }
          const edgePlacement = allPlacements.reverse().reduce((a3, b3) => {
            return Object.assign(Object.assign({}, a3), b3);
          }, model_2.DEFAULT_EDGE_PLACEMENT);
          if (!edgePlacement.moveMode) {
            edgePlacement.moveMode = (0, model_3.isMoveable)(element) ? "edge" : "none";
          }
          return edgePlacement;
        }
        getAlignment(label, placement, angle) {
          const bounds = label.bounds;
          const x3 = (0, model_1.isAlignable)(label) ? label.alignment.x - bounds.width : 0;
          const y3 = (0, model_1.isAlignable)(label) ? label.alignment.y - bounds.height : 0;
          if (placement.side === "on") {
            return { x: x3 + 0.5 * bounds.width, y: y3 + 0.5 * bounds.height };
          }
          const quadrant = this.getQuadrant(angle);
          const midLeft = { x: placement.offset, y: y3 + 0.5 * bounds.height };
          const topLeft = { x: placement.offset, y: y3 + bounds.height + placement.offset };
          const topRight = { x: -bounds.width - placement.offset, y: y3 + bounds.height + placement.offset };
          const midRight = { x: -bounds.width - placement.offset, y: y3 + 0.5 * bounds.height };
          const bottomRight = { x: -bounds.width - placement.offset, y: y3 - placement.offset };
          const bottomLeft = { x: placement.offset, y: y3 - placement.offset };
          switch (placement.side) {
            case "left":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
              }
              break;
            case "right":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return geometry_1.Point.linear(bottomLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return geometry_1.Point.linear(topRight, bottomRight, quadrant.position);
              }
              break;
            case "top":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "north":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(bottomRight, bottomLeft, quadrant.position);
                case "south":
                  return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
              }
              break;
            case "bottom":
              switch (quadrant.orientation) {
                case "west":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "north":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
                case "east":
                  return geometry_1.Point.linear(topLeft, topRight, quadrant.position);
                case "south":
                  return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
              }
              break;
          }
          return { x: 0, y: 0 };
        }
        getQuadrant(angle) {
          if (Math.abs(angle) > 135)
            return { orientation: "west", position: (angle > 0 ? angle - 135 : angle + 225) / 90 };
          else if (angle < -45)
            return { orientation: "north", position: (angle + 135) / 90 };
          else if (angle < 45)
            return { orientation: "east", position: (angle + 45) / 90 };
          else
            return { orientation: "south", position: (angle - 45) / 90 };
        }
        linearFlip(p0, p1, p22, p3, position) {
          return position < 0.5 ? geometry_1.Point.linear(p0, p1, 2 * position) : geometry_1.Point.linear(p22, p3, 2 * position - 1);
        }
        postUpdate() {
        }
      };
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], EdgeLayoutPostprocessor.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], EdgeLayoutPostprocessor.prototype, "logger", void 0);
      exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], EdgeLayoutPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-layout/di.config.js
  var require_di_config2 = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-layout/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var edge_layout_1 = require_edge_layout();
      var edgeLayoutModule = new inversify_1.ContainerModule((bind) => {
        bind(edge_layout_1.EdgeLayoutPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(edge_layout_1.EdgeLayoutPostprocessor);
      });
      exports.default = edgeLayoutModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/create.js
  var require_create = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/create.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CreateElementCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var CreateElementCommand = class CreateElementCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const container = context.root.index.getById(this.action.containerId);
          if (container instanceof smodel_1.SParentElementImpl) {
            this.container = container;
            this.newElement = context.modelFactory.createElement(this.action.elementSchema);
            this.container.add(this.newElement);
          }
          return context.root;
        }
        undo(context) {
          this.container.remove(this.newElement);
          return context.root;
        }
        redo(context) {
          this.container.add(this.newElement);
          return context.root;
        }
      };
      exports.CreateElementCommand = CreateElementCommand;
      CreateElementCommand.KIND = actions_1.CreateElementAction.KIND;
      exports.CreateElementCommand = CreateElementCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CreateElementCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/create-on-drag.js
  var require_create_on_drag = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/create-on-drag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCreatingOnDrag = exports.creatingOnDragFeature = void 0;
      exports.creatingOnDragFeature = Symbol("creatingOnDragFeature");
      function isCreatingOnDrag(element) {
        return element.hasFeature(exports.creatingOnDragFeature) && element.createAction !== void 0;
      }
      exports.isCreatingOnDrag = isCreatingOnDrag;
    }
  });

  // ../../node_modules/sprotty/lib/lib/svg-views.js
  var require_svg_views = __commonJS({
    "../../node_modules/sprotty/lib/lib/svg-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyGroupView = exports.DiamondNodeView = exports.RectangularNodeView = exports.CircularNodeView = exports.SvgViewportView = void 0;
      var jsx_1 = require_jsx();
      var sgraph_1 = require_sgraph();
      var views_1 = require_views();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_cjs4();
      var SvgViewportView = class SvgViewportView {
        render(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            null,
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model))
          );
        }
      };
      exports.SvgViewportView = SvgViewportView;
      exports.SvgViewportView = SvgViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], SvgViewportView);
      var CircularNodeView = class CircularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const radius = this.getRadius(node);
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("circle", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, r: radius, cx: radius, cy: radius }),
            context.renderChildren(node)
          );
        }
        getRadius(node) {
          const d3 = Math.min(node.size.width, node.size.height);
          return d3 > 0 ? d3 / 2 : 0;
        }
      };
      exports.CircularNodeView = CircularNodeView;
      exports.CircularNodeView = CircularNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], CircularNodeView);
      var RectangularNodeView2 = class RectangularNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("rect", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, x: "0", y: "0", width: Math.max(node.size.width, 0), height: Math.max(node.size.height, 0) }),
            context.renderChildren(node)
          );
        }
      };
      exports.RectangularNodeView = RectangularNodeView2;
      exports.RectangularNodeView = RectangularNodeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], RectangularNodeView2);
      var DiamondNodeView = class DiamondNodeView extends views_1.ShapeView {
        render(node, context, args) {
          if (!this.isVisible(node, context)) {
            return void 0;
          }
          const diamond = new geometry_1.Diamond({ height: Math.max(node.size.height, 0), width: Math.max(node.size.width, 0), x: 0, y: 0 });
          const points = `${svgStr(diamond.topPoint)} ${svgStr(diamond.rightPoint)} ${svgStr(diamond.bottomPoint)} ${svgStr(diamond.leftPoint)}`;
          return (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("polygon", { "class-sprotty-node": node instanceof sgraph_1.SNodeImpl, "class-sprotty-port": node instanceof sgraph_1.SPortImpl, "class-mouseover": node.hoverFeedback, "class-selected": node.selected, points }),
            context.renderChildren(node)
          );
        }
      };
      exports.DiamondNodeView = DiamondNodeView;
      exports.DiamondNodeView = DiamondNodeView = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondNodeView);
      function svgStr(point) {
        return `${point.x},${point.y}`;
      }
      var EmptyGroupView = class EmptyGroupView {
        render(model, context) {
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.EmptyGroupView = EmptyGroupView;
      exports.EmptyGroupView = EmptyGroupView = __decorate([
        (0, inversify_1.injectable)()
      ], EmptyGroupView);
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/edit-label.js
  var require_edit_label = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/edit-label.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEditableLabel = exports.EditLabelKeyListener = exports.EditLabelMouseListener = exports.ApplyLabelEditCommand = exports.ResolvedLabelEdit = exports.isApplyLabelEditAction = exports.isEditLabelAction = exports.EditLabelAction = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model6();
      var iterable_1 = require_iterable();
      var model_2 = require_model11();
      var EditLabelAction;
      (function(EditLabelAction2) {
        EditLabelAction2.KIND = "EditLabel";
        function create(labelId) {
          return {
            kind: EditLabelAction2.KIND,
            labelId
          };
        }
        EditLabelAction2.create = create;
      })(EditLabelAction || (exports.EditLabelAction = EditLabelAction = {}));
      function isEditLabelAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === EditLabelAction.KIND && "labelId" in element;
      }
      exports.isEditLabelAction = isEditLabelAction;
      function isApplyLabelEditAction(element) {
        return (0, actions_1.isAction)(element) && element.kind === actions_1.ApplyLabelEditAction.KIND && "labelId" in element && "text" in element;
      }
      exports.isApplyLabelEditAction = isApplyLabelEditAction;
      var ResolvedLabelEdit = class {
      };
      exports.ResolvedLabelEdit = ResolvedLabelEdit;
      var ApplyLabelEditCommand = class ApplyLabelEditCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const index = context.root.index;
          const label = index.getById(this.action.labelId);
          if (label && (0, model_2.isEditableLabel)(label)) {
            this.resolvedLabelEdit = { label, oldLabel: label.text, newLabel: this.action.text };
            label.text = this.action.text;
          }
          return context.root;
        }
        undo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.oldLabel;
          }
          return context.root;
        }
        redo(context) {
          if (this.resolvedLabelEdit) {
            this.resolvedLabelEdit.label.text = this.resolvedLabelEdit.newLabel;
          }
          return context.root;
        }
      };
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand;
      ApplyLabelEditCommand.KIND = actions_1.ApplyLabelEditAction.KIND;
      exports.ApplyLabelEditCommand = ApplyLabelEditCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ApplyLabelEditCommand);
      var EditLabelMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const editableLabel = getEditableLabel(target);
          if (editableLabel) {
            return [EditLabelAction.create(editableLabel.id)];
          }
          return [];
        }
      };
      exports.EditLabelMouseListener = EditLabelMouseListener;
      var EditLabelKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "F2")) {
            const editableLabels = (0, iterable_1.toArray)(element.index.all().filter((e2) => (0, model_1.isSelectable)(e2) && e2.selected)).map(getEditableLabel).filter((e2) => e2 !== void 0);
            if (editableLabels.length === 1) {
              return [EditLabelAction.create(editableLabels[0].id)];
            }
          }
          return [];
        }
      };
      exports.EditLabelKeyListener = EditLabelKeyListener;
      function getEditableLabel(element) {
        if ((0, model_2.isEditableLabel)(element)) {
          return element;
        } else if ((0, model_2.isWithEditableLabel)(element) && element.editableLabel) {
          return element.editableLabel;
        }
        return void 0;
      }
      exports.getEditableLabel = getEditableLabel;
    }
  });

  // ../../node_modules/sprotty/lib/model-source/model-source.js
  var require_model_source = __commonJS({
    "../../node_modules/sprotty/lib/model-source/model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ComputedBoundsApplicator = exports.ModelSource = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var ModelSource = class ModelSource {
        initialize(registry) {
          registry.register(actions_1.RequestModelAction.KIND, this);
          registry.register(actions_1.ExportSvgAction.KIND, this);
        }
      };
      exports.ModelSource = ModelSource;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelSource.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ModelSource.prototype, "viewerOptions", void 0);
      exports.ModelSource = ModelSource = __decorate([
        (0, inversify_1.injectable)()
      ], ModelSource);
      var ComputedBoundsApplicator = class ComputedBoundsApplicator {
        apply(root, action) {
          const index = new model_utils_1.SModelIndex();
          index.add(root);
          for (const b3 of action.bounds) {
            const element = index.getById(b3.elementId);
            if (element !== void 0)
              this.applyBounds(element, b3.newPosition, b3.newSize);
          }
          if (action.alignments !== void 0) {
            for (const a3 of action.alignments) {
              const element = index.getById(a3.elementId);
              if (element !== void 0)
                this.applyAlignment(element, a3.newAlignment);
            }
          }
          return index;
        }
        applyAlignment(element, newAlignment) {
          const e2 = element;
          e2.alignment = { x: newAlignment.x, y: newAlignment.y };
        }
        applyBounds(element, newPosition, newSize) {
          const e2 = element;
          if (newPosition)
            e2.position = Object.assign({}, newPosition);
          e2.size = Object.assign({}, newSize);
        }
      };
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator;
      exports.ComputedBoundsApplicator = ComputedBoundsApplicator = __decorate([
        (0, inversify_1.injectable)()
      ], ComputedBoundsApplicator);
    }
  });

  // ../../node_modules/sprotty/lib/model-source/commit-model.js
  var require_commit_model = __commonJS({
    "../../node_modules/sprotty/lib/model-source/commit-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommitModelCommand = exports.CommitModelAction = void 0;
      var inversify_1 = require_cjs4();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_source_1 = require_model_source();
      var CommitModelAction;
      (function(CommitModelAction2) {
        CommitModelAction2.KIND = "commitModel";
        function create() {
          return {
            kind: CommitModelAction2.KIND
          };
        }
        CommitModelAction2.create = create;
      })(CommitModelAction || (exports.CommitModelAction = CommitModelAction = {}));
      var CommitModelCommand = class CommitModelCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.newModel = context.modelFactory.createSchema(context.root);
          return this.doCommit(this.newModel, context.root, true);
        }
        doCommit(model, result, doSetOriginal) {
          const commitResult = this.modelSource.commitModel(model);
          if (commitResult instanceof Promise) {
            return commitResult.then((originalModel) => {
              if (doSetOriginal)
                this.originalModel = originalModel;
              return result;
            });
          } else {
            if (doSetOriginal)
              this.originalModel = commitResult;
            return result;
          }
        }
        undo(context) {
          return this.doCommit(this.originalModel, context.root, false);
        }
        redo(context) {
          return this.doCommit(this.newModel, context.root, false);
        }
      };
      exports.CommitModelCommand = CommitModelCommand;
      CommitModelCommand.KIND = CommitModelAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSource),
        __metadata("design:type", model_source_1.ModelSource)
      ], CommitModelCommand.prototype, "modelSource", void 0);
      exports.CommitModelCommand = CommitModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CommitModelCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/zoom.js
  var require_zoom = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/zoom.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ZoomMouseListener = exports.getZoom = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var browser_1 = require_browser();
      var model_1 = require_model12();
      var geometry_2 = require_geometry2();
      function getZoom(label) {
        let zoom = 1;
        const viewport = (0, smodel_utils_1.findParentByFeature)(label, model_1.isViewport);
        if (viewport) {
          zoom = viewport.zoom;
        }
        return zoom;
      }
      exports.getZoom = getZoom;
      var ZoomMouseListener = class extends mouse_tool_1.MouseListener {
        wheel(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (!viewport) {
            return [];
          }
          const newViewport = this.isScrollMode(event) ? this.processScroll(viewport, event) : this.processZoom(viewport, target, event);
          if (newViewport) {
            return [actions_1.SetViewportAction.create(viewport.id, newViewport, { animate: false })];
          }
          return [];
        }
        isScrollMode(event) {
          return event.altKey;
        }
        processScroll(viewport, event) {
          return {
            scroll: {
              x: viewport.scroll.x + event.deltaX,
              y: viewport.scroll.y + event.deltaY
            },
            zoom: viewport.zoom
          };
        }
        processZoom(viewport, target, event) {
          const zoomFactor = this.getZoomFactor(event);
          if (zoomFactor > 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.max) || zoomFactor < 1 && (0, geometry_1.almostEquals)(viewport.zoom, this.viewerOptions.zoomLimits.min)) {
            return;
          }
          const zoom = (0, geometry_2.limit)(viewport.zoom * zoomFactor, this.viewerOptions.zoomLimits);
          const viewportOffset = this.getViewportOffset(target.root, event);
          const offsetFactor = 1 / zoom - 1 / viewport.zoom;
          return {
            scroll: {
              x: viewport.scroll.x - offsetFactor * viewportOffset.x,
              y: viewport.scroll.y - offsetFactor * viewportOffset.y
            },
            zoom
          };
        }
        getViewportOffset(root, event) {
          const canvasBounds = root.canvasBounds;
          const windowScroll = (0, browser_1.getWindowScroll)();
          return {
            x: event.clientX + windowScroll.x - canvasBounds.x,
            y: event.clientY + windowScroll.y - canvasBounds.y
          };
        }
        getZoomFactor(event) {
          if (event.deltaMode === event.DOM_DELTA_PAGE)
            return Math.exp(-event.deltaY * 0.5);
          else if (event.deltaMode === event.DOM_DELTA_LINE)
            return Math.exp(-event.deltaY * 0.05);
          else
            return Math.exp(-event.deltaY * 5e-3);
        }
      };
      exports.ZoomMouseListener = ZoomMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ZoomMouseListener.prototype, "viewerOptions", void 0);
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/edit-label-ui.js
  var require_edit_label_ui = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/edit-label-ui.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var EditLabelUI_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EditLabelUI = exports.EditLabelActionHandler = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var ui_extension_1 = require_ui_extension();
      var ui_extension_registry_1 = require_ui_extension_registry();
      var dom_helper_1 = require_dom_helper();
      var commit_model_1 = require_commit_model();
      var keyboard_1 = require_keyboard();
      var model_1 = require_model2();
      var zoom_1 = require_zoom();
      var edit_label_1 = require_edit_label();
      var model_2 = require_model11();
      var EditLabelActionHandler = class EditLabelActionHandler {
        handle(action) {
          if ((0, edit_label_1.isEditLabelAction)(action)) {
            return ui_extension_registry_1.SetUIExtensionVisibilityAction.create({ extensionId: EditLabelUI.ID, visible: true, contextElementsId: [action.labelId] });
          }
        }
      };
      exports.EditLabelActionHandler = EditLabelActionHandler;
      exports.EditLabelActionHandler = EditLabelActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelActionHandler);
      var EditLabelUI = EditLabelUI_1 = class EditLabelUI extends ui_extension_1.AbstractUIExtension {
        constructor() {
          super(...arguments);
          this.validationTimeout = void 0;
          this.isActive = false;
          this.blockApplyEditOnInvalidInput = true;
          this.isCurrentLabelValid = true;
        }
        id() {
          return EditLabelUI_1.ID;
        }
        containerClass() {
          return "label-edit";
        }
        get labelId() {
          return this.label ? this.label.id : "unknown";
        }
        initializeContents(containerElement) {
          containerElement.style.position = "absolute";
          this.inputElement = document.createElement("input");
          this.textAreaElement = document.createElement("textarea");
          [this.inputElement, this.textAreaElement].forEach((element) => {
            element.onkeydown = (event) => this.applyLabelEditOnEvent(event, "Enter");
            this.configureAndAdd(element, containerElement);
          });
        }
        configureAndAdd(element, containerElement) {
          element.style.visibility = "hidden";
          element.style.position = "absolute";
          element.style.top = "0px";
          element.style.left = "0px";
          element.addEventListener("keydown", (event) => this.hideIfEscapeEvent(event));
          element.addEventListener("keyup", (event) => this.validateLabelIfContentChange(event, element.value));
          element.addEventListener("blur", () => window.setTimeout(() => this.applyLabelEdit(), 200));
          containerElement.appendChild(element);
        }
        get editControl() {
          if (this.label && this.label.isMultiLine) {
            return this.textAreaElement;
          }
          return this.inputElement;
        }
        hideIfEscapeEvent(event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            this.hide();
          }
        }
        applyLabelEditOnEvent(event, code, ...modifiers) {
          if ((0, keyboard_1.matchesKeystroke)(event, code ? code : "Enter", ...modifiers)) {
            event.preventDefault();
            this.applyLabelEdit();
          }
        }
        validateLabelIfContentChange(event, value) {
          if (this.previousLabelContent === void 0 || this.previousLabelContent !== value) {
            this.previousLabelContent = value;
            this.performLabelValidation(event, this.editControl.value);
          }
        }
        async applyLabelEdit() {
          var _a4;
          if (!this.isActive) {
            return;
          }
          if (((_a4 = this.label) === null || _a4 === void 0 ? void 0 : _a4.text) === this.editControl.value) {
            this.hide();
            return;
          }
          if (this.blockApplyEditOnInvalidInput) {
            const result = await this.validateLabel(this.editControl.value);
            if ("error" === result.severity) {
              this.editControl.focus();
              return;
            }
          }
          this.actionDispatcherProvider().then((actionDispatcher) => actionDispatcher.dispatchAll([actions_1.ApplyLabelEditAction.create(this.labelId, this.editControl.value), commit_model_1.CommitModelAction.create()])).catch((reason) => this.logger.error(this, "No action dispatcher available to execute apply label edit action", reason));
          this.hide();
        }
        performLabelValidation(event, value) {
          if (this.validationTimeout) {
            window.clearTimeout(this.validationTimeout);
          }
          this.validationTimeout = window.setTimeout(() => this.validateLabel(value), 200);
        }
        async validateLabel(value) {
          if (this.labelValidator && this.label) {
            try {
              const result = await this.labelValidator.validate(value, this.label);
              this.isCurrentLabelValid = "error" !== result.severity;
              this.showValidationResult(result);
              return result;
            } catch (reason) {
              this.logger.error(this, "Error validating edited label", reason);
            }
          }
          this.isCurrentLabelValid = true;
          return { severity: "ok", message: void 0 };
        }
        showValidationResult(result) {
          this.clearValidationResult();
          if (this.validationDecorator) {
            this.validationDecorator.decorate(this.editControl, result);
          }
        }
        clearValidationResult() {
          if (this.validationDecorator) {
            this.validationDecorator.dispose(this.editControl);
          }
        }
        show(root, ...contextElementIds) {
          if (!hasEditableLabel(contextElementIds, root) || this.isActive) {
            return;
          }
          super.show(root, ...contextElementIds);
          this.isActive = true;
        }
        hide() {
          this.editControl.style.visibility = "hidden";
          super.hide();
          this.clearValidationResult();
          this.isActive = false;
          this.isCurrentLabelValid = true;
          this.previousLabelContent = void 0;
          if (this.labelElement) {
            this.labelElement.style.visibility = "visible";
          }
        }
        onBeforeShow(containerElement, root, ...contextElementIds) {
          this.label = getEditableLabels(contextElementIds, root)[0];
          this.previousLabelContent = this.label.text;
          this.setPosition(containerElement);
          this.applyTextContents();
          this.applyFontStyling();
          this.editControl.style.visibility = "visible";
          this.editControl.focus();
        }
        setPosition(containerElement) {
          let x3 = 0;
          let y3 = 0;
          let width = 100;
          let height = 20;
          if (this.label) {
            const zoom = (0, zoom_1.getZoom)(this.label);
            const bounds = (0, model_1.getAbsoluteClientBounds)(this.label, this.domHelper, this.viewerOptions);
            x3 = bounds.x + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.x : 0) * zoom;
            y3 = bounds.y + (this.label.editControlPositionCorrection ? this.label.editControlPositionCorrection.y : 0) * zoom;
            height = (this.label.editControlDimension ? this.label.editControlDimension.height : height) * zoom;
            width = (this.label.editControlDimension ? this.label.editControlDimension.width : width) * zoom;
          }
          containerElement.style.left = `${x3}px`;
          containerElement.style.top = `${y3}px`;
          containerElement.style.width = `${width}px`;
          this.editControl.style.width = `${width}px`;
          containerElement.style.height = `${height}px`;
          this.editControl.style.height = `${height}px`;
        }
        applyTextContents() {
          if (this.label) {
            this.editControl.value = this.label.text;
            if (this.editControl instanceof HTMLTextAreaElement) {
              this.editControl.selectionStart = 0;
              this.editControl.selectionEnd = 0;
              this.editControl.scrollTop = 0;
              this.editControl.scrollLeft = 0;
            } else {
              this.editControl.setSelectionRange(0, this.editControl.value.length);
            }
          }
        }
        applyFontStyling() {
          if (this.label) {
            this.labelElement = document.getElementById(this.domHelper.createUniqueDOMElementId(this.label));
            if (this.labelElement) {
              this.labelElement.style.visibility = "hidden";
              const style = window.getComputedStyle(this.labelElement);
              this.editControl.style.font = style.font;
              this.editControl.style.fontStyle = style.fontStyle;
              this.editControl.style.fontFamily = style.fontFamily;
              this.editControl.style.fontSize = scaledFont(style.fontSize, (0, zoom_1.getZoom)(this.label));
              this.editControl.style.fontWeight = style.fontWeight;
              this.editControl.style.lineHeight = style.lineHeight;
            }
          }
        }
      };
      exports.EditLabelUI = EditLabelUI;
      EditLabelUI.ID = "editLabelUi";
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcherProvider),
        __metadata("design:type", Function)
      ], EditLabelUI.prototype, "actionDispatcherProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.DOMHelper),
        __metadata("design:type", dom_helper_1.DOMHelper)
      ], EditLabelUI.prototype, "domHelper", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "labelValidator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IEditLabelValidationDecorator),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], EditLabelUI.prototype, "validationDecorator", void 0);
      exports.EditLabelUI = EditLabelUI = EditLabelUI_1 = __decorate([
        (0, inversify_1.injectable)()
      ], EditLabelUI);
      function hasEditableLabel(contextElementIds, root) {
        return getEditableLabels(contextElementIds, root).length === 1;
      }
      function getEditableLabels(contextElementIds, root) {
        return contextElementIds.map((id) => root.index.getById(id)).filter(model_2.isEditableLabel);
      }
      function scaledFont(font, zoom) {
        return font.replace(/\d+(\.\d+)?/, (match) => {
          return String(Number.parseInt(match, 10) * zoom);
        });
      }
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/edit-routing.js
  var require_edit_routing = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/edit-routing.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SwitchEditModeCommand = exports.SwitchEditModeAction = void 0;
      var inversify_1 = require_cjs4();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var model_2 = require_model11();
      var SwitchEditModeAction;
      (function(SwitchEditModeAction2) {
        SwitchEditModeAction2.KIND = "switchEditMode";
        function create(options) {
          var _a4, _b2;
          return {
            kind: SwitchEditModeAction2.KIND,
            elementsToActivate: (_a4 = options.elementsToActivate) !== null && _a4 !== void 0 ? _a4 : [],
            elementsToDeactivate: (_b2 = options.elementsToDeactivate) !== null && _b2 !== void 0 ? _b2 : []
          };
        }
        SwitchEditModeAction2.create = create;
      })(SwitchEditModeAction || (exports.SwitchEditModeAction = SwitchEditModeAction = {}));
      var SwitchEditModeCommand = class SwitchEditModeCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.elementsToActivate = [];
          this.elementsToDeactivate = [];
          this.handlesToRemove = [];
        }
        execute(context) {
          const index = context.root.index;
          this.action.elementsToActivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToActivate.push(element);
          });
          this.action.elementsToDeactivate.forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0)
              this.elementsToDeactivate.push(element);
            if (element instanceof model_1.SRoutingHandleImpl && element.parent instanceof model_1.SRoutableElementImpl) {
              const parent = element.parent;
              if (this.shouldRemoveHandle(element, parent)) {
                this.handlesToRemove.push({ handle: element, parent });
                this.elementsToDeactivate.push(parent);
                this.elementsToActivate.push(parent);
              }
            }
          });
          return this.doExecute(context);
        }
        doExecute(context) {
          this.handlesToRemove.forEach((entry) => {
            entry.point = entry.parent.routingPoints.splice(entry.handle.pointIndex, 1)[0];
          });
          this.elementsToDeactivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl) {
              element.editMode = false;
              if (element.danglingAnchor) {
                if (element.parent instanceof model_1.SRoutableElementImpl && element.danglingAnchor.original) {
                  if (element.parent.source === element.danglingAnchor)
                    element.parent.sourceId = element.danglingAnchor.original.id;
                  else if (element.parent.target === element.danglingAnchor)
                    element.parent.targetId = element.danglingAnchor.original.id;
                  element.danglingAnchor.parent.remove(element.danglingAnchor);
                  element.danglingAnchor = void 0;
                }
              }
            }
          });
          this.elementsToActivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element) && element instanceof smodel_1.SParentElementImpl) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        shouldRemoveHandle(handle, parent) {
          if (handle.kind === "junction") {
            const route = this.edgeRouterRegistry.route(parent);
            return route.find((rp) => rp.pointIndex === handle.pointIndex) === void 0;
          }
          return false;
        }
        undo(context) {
          this.handlesToRemove.forEach((entry) => {
            if (entry.point !== void 0)
              entry.parent.routingPoints.splice(entry.handle.pointIndex, 0, entry.point);
          });
          this.elementsToActivate.forEach((element) => {
            if (element instanceof model_1.SRoutableElementImpl)
              element.removeAll((child) => child instanceof model_1.SRoutingHandleImpl);
            else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = false;
          });
          this.elementsToDeactivate.forEach((element) => {
            if ((0, model_2.canEditRouting)(element)) {
              const router = this.edgeRouterRegistry.get(element.routerKind);
              router.createRoutingHandles(element);
            } else if (element instanceof model_1.SRoutingHandleImpl)
              element.editMode = true;
          });
          return context.root;
        }
        redo(context) {
          return this.doExecute(context);
        }
      };
      exports.SwitchEditModeCommand = SwitchEditModeCommand;
      SwitchEditModeCommand.KIND = SwitchEditModeAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SwitchEditModeCommand.prototype, "edgeRouterRegistry", void 0);
      exports.SwitchEditModeCommand = SwitchEditModeCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SwitchEditModeCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/reconnect.js
  var require_reconnect = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/reconnect.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReconnectCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var types_1 = require_types();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var ReconnectCommand = class ReconnectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.doExecute(context);
          return context.root;
        }
        doExecute(context) {
          const index = context.root.index;
          const edge = index.getById(this.action.routableId);
          if (edge instanceof model_1.SRoutableElementImpl) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyReconnect(edge, this.action.newSourceId, this.action.newTargetId);
            const after = router.takeSnapshot(edge);
            this.memento = {
              edge,
              before,
              after
            };
          }
        }
        undo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.before);
          }
          return context.root;
        }
        redo(context) {
          if (this.memento) {
            const router = this.edgeRouterRegistry.get(this.memento.edge.routerKind);
            router.applySnapshot(this.memento.edge, this.memento.after);
          }
          return context.root;
        }
      };
      exports.ReconnectCommand = ReconnectCommand;
      ReconnectCommand.KIND = actions_1.ReconnectAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], ReconnectCommand.prototype, "edgeRouterRegistry", void 0);
      exports.ReconnectCommand = ReconnectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ReconnectCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/edit/di.config.js
  var require_di_config3 = __commonJS({
    "../../node_modules/sprotty/lib/features/edit/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.labelEditUiModule = exports.labelEditModule = exports.edgeEditModule = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var view_1 = require_view();
      var model_1 = require_model9();
      var svg_views_1 = require_svg_views();
      var delete_1 = require_delete();
      var edit_label_1 = require_edit_label();
      var edit_label_ui_1 = require_edit_label_ui();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      exports.edgeEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, edit_routing_1.SwitchEditModeCommand);
        (0, command_registration_1.configureCommand)(context, reconnect_1.ReconnectCommand);
        (0, command_registration_1.configureCommand)(context, delete_1.DeleteElementCommand);
        (0, view_1.configureModelElement)(context, "dangling-anchor", model_1.SDanglingAnchorImpl, svg_views_1.EmptyGroupView);
      });
      exports.labelEditModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(edit_label_1.EditLabelMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(edit_label_1.EditLabelMouseListener);
        bind(edit_label_1.EditLabelKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(edit_label_1.EditLabelKeyListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, edit_label_1.ApplyLabelEditCommand);
      });
      exports.labelEditUiModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        const context = { bind, isBound };
        (0, action_handler_1.configureActionHandler)(context, edit_label_1.EditLabelAction.KIND, edit_label_ui_1.EditLabelActionHandler);
        bind(edit_label_ui_1.EditLabelUI).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(edit_label_ui_1.EditLabelUI);
      });
    }
  });

  // ../../node_modules/sprotty/lib/features/expand/model.js
  var require_model14 = __commonJS({
    "../../node_modules/sprotty/lib/features/expand/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isExpandable = exports.expandFeature = void 0;
      exports.expandFeature = Symbol("expandFeature");
      function isExpandable(element) {
        return element.hasFeature(exports.expandFeature) && "expanded" in element;
      }
      exports.isExpandable = isExpandable;
    }
  });

  // ../../node_modules/sprotty/lib/features/expand/expand.js
  var require_expand = __commonJS({
    "../../node_modules/sprotty/lib/features/expand/expand.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonHandler = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model14();
      var ExpandButtonHandler = class ExpandButtonHandler {
        buttonPressed(button) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          if (expandable !== void 0) {
            return [actions_1.CollapseExpandAction.create({
              expandIds: expandable.expanded ? [] : [expandable.id],
              collapseIds: expandable.expanded ? [expandable.id] : []
            })];
          } else {
            return [];
          }
        }
      };
      exports.ExpandButtonHandler = ExpandButtonHandler;
      ExpandButtonHandler.TYPE = "button:expand";
      exports.ExpandButtonHandler = ExpandButtonHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonHandler);
    }
  });

  // ../../node_modules/sprotty/lib/features/expand/views.js
  var require_views2 = __commonJS({
    "../../node_modules/sprotty/lib/features/expand/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExpandButtonView = void 0;
      var jsx_1 = require_jsx();
      var model_1 = require_model14();
      var smodel_utils_1 = require_smodel_utils();
      var inversify_1 = require_cjs4();
      var ExpandButtonView = class ExpandButtonView {
        render(button, context) {
          const expandable = (0, smodel_utils_1.findParentByFeature)(button, model_1.isExpandable);
          const path = expandable !== void 0 && expandable.expanded ? "M 1,5 L 8,12 L 15,5 Z" : "M 1,8 L 8,15 L 8,1 Z";
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-button": "{true}", "class-enabled": "{button.enabled}" },
            (0, jsx_1.svg)("rect", { x: 0, y: 0, width: 16, height: 16, opacity: 0 }),
            (0, jsx_1.svg)("path", { d: path })
          );
        }
      };
      exports.ExpandButtonView = ExpandButtonView;
      exports.ExpandButtonView = ExpandButtonView = __decorate([
        (0, inversify_1.injectable)()
      ], ExpandButtonView);
    }
  });

  // ../../node_modules/sprotty/lib/features/export/svg-exporter.js
  var require_svg_exporter = __commonJS({
    "../../node_modules/sprotty/lib/features/export/svg-exporter.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SvgExporter = exports.ExportSvgAction = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var action_dispatcher_1 = require_action_dispatcher();
      var types_1 = require_types();
      var model_1 = require_model2();
      var ExportSvgAction;
      (function(ExportSvgAction2) {
        ExportSvgAction2.KIND = "exportSvg";
        function create(svg, requestId, options) {
          return {
            kind: ExportSvgAction2.KIND,
            svg,
            responseId: requestId,
            options
          };
        }
        ExportSvgAction2.create = create;
      })(ExportSvgAction || (exports.ExportSvgAction = ExportSvgAction = {}));
      var SvgExporter = class SvgExporter {
        constructor() {
          this.postprocessors = [];
        }
        export(root, request) {
          var _a4;
          if (typeof document !== "undefined") {
            const hiddenDiv = document.getElementById(this.options.hiddenDiv);
            if (hiddenDiv === null) {
              this.log.warn(this, `Element with id ${this.options.hiddenDiv} not found. Nothing to export.`);
              return;
            }
            const svgElement = hiddenDiv.querySelector("svg");
            if (svgElement === null) {
              this.log.warn(this, `No svg element found in ${this.options.hiddenDiv} div. Nothing to export.`);
              return;
            }
            const svg = this.createSvg(svgElement, root, (_a4 = request === null || request === void 0 ? void 0 : request.options) !== null && _a4 !== void 0 ? _a4 : {}, request);
            this.actionDispatcher.dispatch(ExportSvgAction.create(svg, request ? request.requestId : "", request === null || request === void 0 ? void 0 : request.options));
          }
        }
        createSvg(svgElementOrig, root, options, cause) {
          const serializer = new XMLSerializer();
          const svgCopy = serializer.serializeToString(svgElementOrig);
          const iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          if (!iframe.contentWindow)
            throw new Error("IFrame has no contentWindow");
          const docCopy = iframe.contentWindow.document;
          docCopy.open();
          docCopy.write(svgCopy);
          docCopy.close();
          const svgElementNew = docCopy.querySelector("svg");
          svgElementNew.removeAttribute("opacity");
          if (!(options === null || options === void 0 ? void 0 : options.skipCopyStyles)) {
            this.copyStyles(svgElementOrig, svgElementNew, ["width", "height", "opacity", "inline-size"]);
          }
          svgElementNew.setAttribute("version", "1.1");
          const bounds = this.getBounds(root, docCopy);
          svgElementNew.setAttribute("viewBox", `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
          svgElementNew.setAttribute("width", `${bounds.width}`);
          svgElementNew.setAttribute("height", `${bounds.height}`);
          this.postprocessors.forEach((postprocessor) => {
            postprocessor.postUpdate(svgElementNew, cause);
          });
          const svgCode = serializer.serializeToString(svgElementNew);
          document.body.removeChild(iframe);
          return svgCode;
        }
        copyStyles(source, target, skippedProperties) {
          const sourceStyle = getComputedStyle(source);
          const targetStyle = getComputedStyle(target);
          let diffStyle = "";
          for (let i2 = 0; i2 < sourceStyle.length; i2++) {
            const key = sourceStyle[i2];
            if (skippedProperties.indexOf(key) === -1) {
              const value = sourceStyle.getPropertyValue(key);
              if (targetStyle.getPropertyValue(key) !== value) {
                diffStyle += key + ":" + value + ";";
              }
            }
          }
          if (diffStyle !== "")
            target.setAttribute("style", diffStyle);
          for (let i2 = 0; i2 < source.childNodes.length; ++i2) {
            const sourceChild = source.childNodes[i2];
            const targetChild = target.childNodes[i2];
            if (sourceChild instanceof Element)
              this.copyStyles(sourceChild, targetChild, []);
          }
        }
        getBounds(root, document2) {
          const svgElement = document2.querySelector("svg");
          if (svgElement) {
            return svgElement.getBBox();
          }
          const allBounds = [geometry_1.Bounds.EMPTY];
          root.children.forEach((element) => {
            if ((0, model_1.isBoundsAware)(element)) {
              allBounds.push(element.bounds);
            }
          });
          return allBounds.reduce((one, two) => geometry_1.Bounds.combine(one, two));
        }
      };
      exports.SvgExporter = SvgExporter;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", action_dispatcher_1.ActionDispatcher)
      ], SvgExporter.prototype, "actionDispatcher", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], SvgExporter.prototype, "log", void 0);
      __decorate([
        (0, inversify_1.multiInject)(types_1.TYPES.ISvgExportPostprocessor),
        (0, inversify_1.optional)(),
        __metadata("design:type", Array)
      ], SvgExporter.prototype, "postprocessors", void 0);
      exports.SvgExporter = SvgExporter = __decorate([
        (0, inversify_1.injectable)()
      ], SvgExporter);
    }
  });

  // ../../node_modules/sprotty/lib/features/export/export.js
  var require_export = __commonJS({
    "../../node_modules/sprotty/lib/features/export/export.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExportSvgPostprocessor = exports.ExportSvgCommand = exports.RequestExportSvgAction = exports.ExportSvgKeyListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var model_1 = require_model6();
      var smodel_1 = require_smodel();
      var key_tool_1 = require_key_tool();
      var keyboard_1 = require_keyboard();
      var model_2 = require_model13();
      var svg_exporter_1 = require_svg_exporter();
      var model_3 = require_model12();
      var model_4 = require_model7();
      var types_1 = require_types();
      var ExportSvgKeyListener = class ExportSvgKeyListener extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyE", "ctrlCmd", "shift"))
            return [RequestExportSvgAction.create()];
          else
            return [];
        }
      };
      exports.ExportSvgKeyListener = ExportSvgKeyListener;
      exports.ExportSvgKeyListener = ExportSvgKeyListener = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgKeyListener);
      var RequestExportSvgAction;
      (function(RequestExportSvgAction2) {
        RequestExportSvgAction2.KIND = "requestExportSvg";
        function create(options = {}) {
          return {
            kind: RequestExportSvgAction2.KIND,
            requestId: (0, actions_1.generateRequestId)(),
            options
          };
        }
        RequestExportSvgAction2.create = create;
      })(RequestExportSvgAction || (exports.RequestExportSvgAction = RequestExportSvgAction = {}));
      var ExportSvgCommand = class ExportSvgCommand extends command_1.HiddenCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          if ((0, model_2.isExportable)(context.root)) {
            const root = context.modelFactory.createRoot(context.root);
            if ((0, model_2.isExportable)(root)) {
              if ((0, model_3.isViewport)(root)) {
                root.zoom = 1;
                root.scroll = { x: 0, y: 0 };
              }
              root.index.all().forEach((element) => {
                if ((0, model_1.isSelectable)(element) && element.selected)
                  element.selected = false;
                if ((0, model_4.isHoverable)(element) && element.hoverFeedback)
                  element.hoverFeedback = false;
              });
              return {
                model: root,
                modelChanged: true,
                cause: this.action
              };
            }
          }
          return {
            model: context.root,
            modelChanged: false
          };
        }
      };
      exports.ExportSvgCommand = ExportSvgCommand;
      ExportSvgCommand.KIND = RequestExportSvgAction.KIND;
      exports.ExportSvgCommand = ExportSvgCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], ExportSvgCommand);
      var ExportSvgPostprocessor = class ExportSvgPostprocessor {
        decorate(vnode, element) {
          if (element instanceof smodel_1.SModelRootImpl)
            this.root = element;
          return vnode;
        }
        postUpdate(cause) {
          if (this.root && cause !== void 0 && cause.kind === RequestExportSvgAction.KIND) {
            this.svgExporter.export(this.root, cause);
          }
        }
      };
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.SvgExporter),
        __metadata("design:type", svg_exporter_1.SvgExporter)
      ], ExportSvgPostprocessor.prototype, "svgExporter", void 0);
      exports.ExportSvgPostprocessor = ExportSvgPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], ExportSvgPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/features/export/svg-export-postprocessor.js
  var require_svg_export_postprocessor = __commonJS({
    "../../node_modules/sprotty/lib/features/export/svg-export-postprocessor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/sprotty/lib/features/fade/fade.js
  var require_fade = __commonJS({
    "../../node_modules/sprotty/lib/features/fade/fade.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementFader = exports.FadeAnimation = void 0;
      var inversify_1 = require_cjs4();
      var animation_1 = require_animation();
      var smodel_1 = require_smodel();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model3();
      var FadeAnimation = class extends animation_1.Animation {
        constructor(model, elementFades, context, removeAfterFadeOut = false) {
          super(context);
          this.model = model;
          this.elementFades = elementFades;
          this.removeAfterFadeOut = removeAfterFadeOut;
        }
        tween(t3, context) {
          for (const elementFade of this.elementFades) {
            const element = elementFade.element;
            if (elementFade.type === "in") {
              element.opacity = t3;
            } else if (elementFade.type === "out") {
              element.opacity = 1 - t3;
              if (t3 === 1 && this.removeAfterFadeOut && element instanceof smodel_1.SChildElementImpl) {
                element.parent.remove(element);
              }
            }
          }
          return this.model;
        }
      };
      exports.FadeAnimation = FadeAnimation;
      var ElementFader = class ElementFader {
        decorate(vnode, element) {
          if ((0, model_1.isFadeable)(element) && element.opacity !== 1) {
            (0, vnode_utils_1.setAttr)(vnode, "opacity", element.opacity);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.ElementFader = ElementFader;
      exports.ElementFader = ElementFader = __decorate([
        (0, inversify_1.injectable)()
      ], ElementFader);
    }
  });

  // ../../node_modules/sprotty/lib/features/hover/hover.js
  var require_hover = __commonJS({
    "../../node_modules/sprotty/lib/features/hover/hover.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClosePopupActionHandler = exports.HoverKeyListener = exports.PopupHoverMouseListener = exports.HoverMouseListener = exports.AbstractHoverMouseListener = exports.SetPopupModelCommand = exports.HoverFeedbackCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var smodel_factory_1 = require_smodel_factory();
      var key_tool_1 = require_key_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      var model_2 = require_model7();
      var HoverFeedbackCommand = class HoverFeedbackCommand extends command_1.SystemCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          const model = context.root;
          const modelElement = model.index.getById(this.action.mouseoverElement);
          if (modelElement) {
            if ((0, model_2.isHoverable)(modelElement)) {
              modelElement.hoverFeedback = this.action.mouseIsOver;
            }
          }
          return this.redo(context);
        }
        undo(context) {
          return context.root;
        }
        redo(context) {
          return context.root;
        }
      };
      exports.HoverFeedbackCommand = HoverFeedbackCommand;
      HoverFeedbackCommand.KIND = actions_1.HoverFeedbackAction.KIND;
      exports.HoverFeedbackCommand = HoverFeedbackCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], HoverFeedbackCommand);
      var SetPopupModelCommand = class SetPopupModelCommand extends command_1.PopupCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          this.oldRoot = context.root;
          this.newRoot = context.modelFactory.createRoot(this.action.newRoot);
          return this.newRoot;
        }
        undo(context) {
          return this.oldRoot;
        }
        redo(context) {
          return this.newRoot;
        }
      };
      exports.SetPopupModelCommand = SetPopupModelCommand;
      SetPopupModelCommand.KIND = actions_1.SetPopupModelAction.KIND;
      exports.SetPopupModelCommand = SetPopupModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetPopupModelCommand);
      var AbstractHoverMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          this.mouseIsDown = true;
          return [];
        }
        mouseUp(target, event) {
          this.mouseIsDown = false;
          return [];
        }
        stopMouseOutTimer() {
          if (this.state.mouseOutTimer !== void 0) {
            window.clearTimeout(this.state.mouseOutTimer);
            this.state.mouseOutTimer = void 0;
          }
        }
        startMouseOutTimer() {
          this.stopMouseOutTimer();
          return new Promise((resolve) => {
            this.state.mouseOutTimer = window.setTimeout(() => {
              this.state.popupOpen = false;
              this.state.previousPopupElement = void 0;
              resolve(actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id }));
            }, this.options.popupCloseDelay);
          });
        }
        stopMouseOverTimer() {
          if (this.state.mouseOverTimer !== void 0) {
            window.clearTimeout(this.state.mouseOverTimer);
            this.state.mouseOverTimer = void 0;
          }
        }
      };
      exports.AbstractHoverMouseListener = AbstractHoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "options", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.HoverState),
        __metadata("design:type", Object)
      ], AbstractHoverMouseListener.prototype, "state", void 0);
      var HoverMouseListener = class HoverMouseListener extends AbstractHoverMouseListener {
        computePopupBounds(target, mousePosition) {
          let offset = { x: -5, y: 20 };
          const targetBounds = (0, model_1.getAbsoluteBounds)(target);
          const canvasBounds = target.root.canvasBounds;
          const boundsInWindow = geometry_1.Bounds.translate(targetBounds, canvasBounds);
          const distRight = boundsInWindow.x + boundsInWindow.width - mousePosition.x;
          const distBottom = boundsInWindow.y + boundsInWindow.height - mousePosition.y;
          if (distBottom <= distRight && this.allowSidePosition(target, "below", distBottom)) {
            offset = { x: -5, y: Math.round(distBottom + 5) };
          } else if (distRight <= distBottom && this.allowSidePosition(target, "right", distRight)) {
            offset = { x: Math.round(distRight + 5), y: -5 };
          }
          let leftPopupPosition = mousePosition.x + offset.x;
          const canvasRightBorderPosition = canvasBounds.x + canvasBounds.width;
          if (leftPopupPosition > canvasRightBorderPosition) {
            leftPopupPosition = canvasRightBorderPosition;
          }
          let topPopupPosition = mousePosition.y + offset.y;
          const canvasBottomBorderPosition = canvasBounds.y + canvasBounds.height;
          if (topPopupPosition > canvasBottomBorderPosition) {
            topPopupPosition = canvasBottomBorderPosition;
          }
          return { x: leftPopupPosition, y: topPopupPosition, width: -1, height: -1 };
        }
        allowSidePosition(target, side, distance) {
          return !(target instanceof smodel_1.SModelRootImpl) && distance <= 150;
        }
        startMouseOverTimer(target, event) {
          this.stopMouseOverTimer();
          return new Promise((resolve) => {
            this.state.mouseOverTimer = window.setTimeout(() => {
              const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
              resolve(actions_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
              this.state.popupOpen = true;
              this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
          });
        }
        mouseOver(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (this.state.popupOpen && (popupTarget === void 0 || this.state.previousPopupElement !== void 0 && this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOutTimer());
            } else {
              this.stopMouseOverTimer();
              this.stopMouseOutTimer();
            }
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
            if (this.lastHoverFeedbackElementId) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
              this.lastHoverFeedbackElementId = void 0;
            }
            const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
            if (hoverTarget !== void 0) {
              result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: true }));
              this.lastHoverFeedbackElementId = hoverTarget.id;
            }
          }
          return result;
        }
        mouseOut(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            const elementUnderMouse = this.getElementFromEventPosition(event);
            if (!this.isSprottyPopup(elementUnderMouse)) {
              if (this.state.popupOpen) {
                const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
                if (this.state.previousPopupElement !== void 0 && popupTarget !== void 0 && this.state.previousPopupElement.id === popupTarget.id)
                  result.push(this.startMouseOutTimer());
              }
              this.stopMouseOverTimer();
              const hoverTarget = (0, smodel_utils_1.findParentByFeature)(target, model_2.isHoverable);
              if (hoverTarget !== void 0) {
                result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: hoverTarget.id, mouseIsOver: false }));
                if (this.lastHoverFeedbackElementId && this.lastHoverFeedbackElementId !== hoverTarget.id) {
                  result.push(actions_1.HoverFeedbackAction.create({ mouseoverElement: this.lastHoverFeedbackElementId, mouseIsOver: false }));
                }
                this.lastHoverFeedbackElementId = void 0;
              }
            }
          }
          return result;
        }
        getElementFromEventPosition(event) {
          return document.elementFromPoint(event.x, event.y);
        }
        isSprottyPopup(element) {
          return element ? element.id === this.options.popupDiv || !!element.parentElement && this.isSprottyPopup(element.parentElement) : false;
        }
        mouseMove(target, event) {
          const result = [];
          if (!this.mouseIsDown) {
            if (this.state.previousPopupElement !== void 0 && this.closeOnMouseMove(this.state.previousPopupElement, event)) {
              result.push(this.startMouseOutTimer());
            }
            const popupTarget = (0, smodel_utils_1.findParent)(target, model_2.hasPopupFeature);
            if (popupTarget !== void 0 && (this.state.previousPopupElement === void 0 || this.state.previousPopupElement.id !== popupTarget.id)) {
              result.push(this.startMouseOverTimer(popupTarget, event));
            }
          }
          return result;
        }
        closeOnMouseMove(target, event) {
          return target instanceof smodel_1.SModelRootImpl;
        }
      };
      exports.HoverMouseListener = HoverMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], HoverMouseListener.prototype, "options", void 0);
      exports.HoverMouseListener = HoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], HoverMouseListener);
      var PopupHoverMouseListener = class PopupHoverMouseListener extends AbstractHoverMouseListener {
        mouseOut(target, event) {
          return [this.startMouseOutTimer()];
        }
        mouseOver(target, event) {
          this.stopMouseOutTimer();
          this.stopMouseOverTimer();
          return [];
        }
      };
      exports.PopupHoverMouseListener = PopupHoverMouseListener;
      exports.PopupHoverMouseListener = PopupHoverMouseListener = __decorate([
        (0, inversify_1.injectable)()
      ], PopupHoverMouseListener);
      var HoverKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "Escape")) {
            return [actions_1.SetPopupModelAction.create({ type: smodel_factory_1.EMPTY_ROOT.type, id: smodel_factory_1.EMPTY_ROOT.id })];
          }
          return [];
        }
      };
      exports.HoverKeyListener = HoverKeyListener;
      var ClosePopupActionHandler = class ClosePopupActionHandler {
        constructor() {
          this.popupOpen = false;
        }
        handle(action) {
          if (action.kind === SetPopupModelCommand.KIND) {
            this.popupOpen = action.newRoot.type !== smodel_factory_1.EMPTY_ROOT.type;
          } else if (this.popupOpen) {
            return actions_1.SetPopupModelAction.create({ id: smodel_factory_1.EMPTY_ROOT.id, type: smodel_factory_1.EMPTY_ROOT.type });
          }
        }
      };
      exports.ClosePopupActionHandler = ClosePopupActionHandler;
      exports.ClosePopupActionHandler = ClosePopupActionHandler = __decorate([
        (0, inversify_1.injectable)()
      ], ClosePopupActionHandler);
    }
  });

  // ../../node_modules/sprotty/lib/features/decoration/model.js
  var require_model15 = __commonJS({
    "../../node_modules/sprotty/lib/features/decoration/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SIssue = exports.SIssueMarker = exports.SIssueMarkerImpl = exports.SDecoration = exports.isDecoration = exports.decorationFeature = void 0;
      var model_1 = require_model2();
      var model_2 = require_model7();
      exports.decorationFeature = Symbol("decorationFeature");
      function isDecoration(e2) {
        return e2.hasFeature(exports.decorationFeature);
      }
      exports.isDecoration = isDecoration;
      var SDecoration = class extends model_1.SShapeElementImpl {
      };
      exports.SDecoration = SDecoration;
      SDecoration.DEFAULT_FEATURES = [exports.decorationFeature, model_1.boundsFeature, model_2.hoverFeedbackFeature, model_2.popupFeature];
      var SIssueMarkerImpl = class extends SDecoration {
      };
      exports.SIssueMarkerImpl = SIssueMarkerImpl;
      exports.SIssueMarker = SIssueMarkerImpl;
      var SIssue = class {
      };
      exports.SIssue = SIssue;
    }
  });

  // ../../node_modules/sprotty/lib/features/decoration/views.js
  var require_views3 = __commonJS({
    "../../node_modules/sprotty/lib/features/decoration/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IssueMarkerView = void 0;
      var jsx_1 = require_jsx();
      var vnode_utils_1 = require_vnode_utils();
      var inversify_1 = require_cjs4();
      var IssueMarkerView = class IssueMarkerView {
        render(marker, context) {
          const scale = 16 / 1792;
          const trafo = `scale(${scale}, ${scale})`;
          const maxSeverity = this.getMaxSeverity(marker);
          const group = (0, jsx_1.svg)(
            "g",
            { "class-sprotty-issue": true },
            (0, jsx_1.svg)(
              "g",
              { transform: trafo },
              (0, jsx_1.svg)("path", { d: this.getPath(maxSeverity) })
            )
          );
          (0, vnode_utils_1.setClass)(group, "sprotty-" + maxSeverity, true);
          return group;
        }
        getMaxSeverity(marker) {
          let currentSeverity = "info";
          for (const severity of marker.issues.map((s3) => s3.severity)) {
            if (severity === "error" || severity === "warning" && currentSeverity === "info")
              currentSeverity = severity;
          }
          return currentSeverity;
        }
        getPath(severity) {
          switch (severity) {
            case "error":
            case "warning":
              return "M768 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zm128 1247v-190q0-14-9-23.5t-22-9.5h-192q-13 0-23 10t-10 23v190q0 13 10 23t23 10h192q13 0 22-9.5t9-23.5zm-2-344l18-621q0-12-10-18-10-8-24-8h-220q-14 0-24 8-10 6-10 18l17 621q0 10 10 17.5t24 7.5h185q14 0 23.5-7.5t10.5-17.5z";
            case "info":
              return "M1024 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zm-128-896v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zm640 416q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z";
          }
        }
      };
      exports.IssueMarkerView = IssueMarkerView;
      exports.IssueMarkerView = IssueMarkerView = __decorate([
        (0, inversify_1.injectable)()
      ], IssueMarkerView);
    }
  });

  // ../../node_modules/sprotty/lib/features/decoration/decoration-placer.js
  var require_decoration_placer = __commonJS({
    "../../node_modules/sprotty/lib/features/decoration/decoration-placer.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DecorationPlacer = void 0;
      var inversify_1 = require_cjs4();
      var smodel_1 = require_smodel();
      var model_1 = require_model15();
      var vnode_utils_1 = require_vnode_utils();
      var model_2 = require_model2();
      var model_3 = require_model9();
      var routing_1 = require_routing();
      var sprotty_protocol_1 = require_lib();
      var DecorationPlacer = class DecorationPlacer {
        decorate(vnode, element) {
          if ((0, model_1.isDecoration)(element)) {
            const position = this.getPosition(element);
            const translate = "translate(" + position.x + ", " + position.y + ")";
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        getPosition(element) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent instanceof model_3.SRoutableElementImpl) {
            const route = this.edgeRouterRegistry.route(element.parent);
            if (route.length > 1) {
              const index = Math.floor(0.5 * (route.length - 1));
              const offset = (0, model_2.isSizeable)(element) ? {
                x: -0.5 * element.bounds.width,
                y: -0.5 * element.bounds.width
              } : sprotty_protocol_1.Point.ORIGIN;
              return {
                x: 0.5 * (route[index].x + route[index + 1].x) + offset.x,
                y: 0.5 * (route[index].y + route[index + 1].y) + offset.y
              };
            }
          }
          if ((0, model_2.isSizeable)(element))
            return {
              x: -0.666 * element.bounds.width,
              y: -0.666 * element.bounds.height
            };
          return sprotty_protocol_1.Point.ORIGIN;
        }
        postUpdate() {
        }
      };
      exports.DecorationPlacer = DecorationPlacer;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], DecorationPlacer.prototype, "edgeRouterRegistry", void 0);
      exports.DecorationPlacer = DecorationPlacer = __decorate([
        (0, inversify_1.injectable)()
      ], DecorationPlacer);
    }
  });

  // ../../node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "../../node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0) data = [];
          if (compare === void 0) compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i2 = (this.length >> 1) - 1; i2 >= 0; i2--) {
              this._down(i2);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a3, b3) {
          return a3 < b3 ? -1 : a3 > b3 ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-intersection/sweepline.js
  var require_sweepline = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-intersection/sweepline.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intersectionOfSegments = exports.getSegmentIndex = exports.checkWhichSegmentHasRightEndpointFirst = exports.runSweep = exports.Segment = exports.SweepEvent = exports.checkWhichEventIsLeft = exports.addRoute = void 0;
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var geometry_1 = require_geometry2();
      function addRoute(routeId, route, queue) {
        if (route.length < 1)
          return;
        let currentPoint = route[0];
        let nextPoint = void 0;
        for (let i2 = 0; i2 < route.length - 1; i2++) {
          nextPoint = route[i2 + 1];
          const e1 = new SweepEvent(routeId, currentPoint, i2);
          const e2 = new SweepEvent(routeId, nextPoint, i2 + 1);
          e1.otherEvent = e2;
          e2.otherEvent = e1;
          if (checkWhichEventIsLeft(e1, e2) > 0) {
            e2.isLeftEndpoint = true;
            e1.isLeftEndpoint = false;
          } else {
            e1.isLeftEndpoint = true;
            e2.isLeftEndpoint = false;
          }
          queue.push(e1);
          queue.push(e2);
          currentPoint = nextPoint;
        }
      }
      exports.addRoute = addRoute;
      function checkWhichEventIsLeft(e1, e2) {
        if (e1.point.x > e2.point.x)
          return 1;
        if (e1.point.x < e2.point.x)
          return -1;
        if (e1.point.y !== e2.point.y)
          return e1.point.y > e2.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichEventIsLeft = checkWhichEventIsLeft;
      var SweepEvent = class {
        constructor(edgeId, point, segmentIndex) {
          this.edgeId = edgeId;
          this.point = point;
          this.segmentIndex = segmentIndex;
        }
      };
      exports.SweepEvent = SweepEvent;
      var Segment = class {
        constructor(event) {
          this.leftSweepEvent = event;
          this.rightSweepEvent = event.otherEvent;
        }
      };
      exports.Segment = Segment;
      function runSweep(eventQueue) {
        const intersectionPoints = [];
        const outQueue = new tinyqueue_1.default([], checkWhichSegmentHasRightEndpointFirst);
        while (eventQueue.length) {
          const event = eventQueue.pop();
          if (event === null || event === void 0 ? void 0 : event.isLeftEndpoint) {
            const segment = new Segment(event);
            for (let i2 = 0; i2 < outQueue.data.length; i2++) {
              const otherSegment = outQueue.data[i2];
              const intersection = intersectionOfSegments(segment, otherSegment);
              if (intersection) {
                intersectionPoints.push({
                  routable1: event.edgeId,
                  routable2: otherSegment.leftSweepEvent.edgeId,
                  segmentIndex1: getSegmentIndex(segment),
                  segmentIndex2: getSegmentIndex(otherSegment),
                  intersectionPoint: intersection
                });
              }
            }
            outQueue.push(segment);
          } else if ((event === null || event === void 0 ? void 0 : event.isLeftEndpoint) === false) {
            outQueue.pop();
          }
        }
        return intersectionPoints;
      }
      exports.runSweep = runSweep;
      function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
        if (seg1.rightSweepEvent.point.x > seg2.rightSweepEvent.point.x)
          return 1;
        if (seg1.rightSweepEvent.point.x < seg2.rightSweepEvent.point.x)
          return -1;
        if (seg1.rightSweepEvent.point.y !== seg2.rightSweepEvent.point.y)
          return seg1.rightSweepEvent.point.y < seg2.rightSweepEvent.point.y ? 1 : -1;
        return 1;
      }
      exports.checkWhichSegmentHasRightEndpointFirst = checkWhichSegmentHasRightEndpointFirst;
      function getSegmentIndex(segment) {
        return Math.min(segment.leftSweepEvent.segmentIndex, segment.rightSweepEvent.segmentIndex);
      }
      exports.getSegmentIndex = getSegmentIndex;
      function intersectionOfSegments(seg1, seg2) {
        if (seg1.leftSweepEvent.edgeId === seg2.leftSweepEvent.edgeId) {
          return void 0;
        }
        const seg1Line = new geometry_1.PointToPointLine(seg1.leftSweepEvent.point, seg1.rightSweepEvent.point);
        const seg2Line = new geometry_1.PointToPointLine(seg2.leftSweepEvent.point, seg2.rightSweepEvent.point);
        return seg1Line.intersection(seg2Line);
      }
      exports.intersectionOfSegments = intersectionOfSegments;
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js
  var require_intersection_finder = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-intersection/intersection-finder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IntersectionFinder = exports.BY_DESCENDING_X_THEN_DESCENDING_Y = exports.BY_X_THEN_DESCENDING_Y = exports.BY_DESCENDING_X_THEN_Y = exports.BY_X_THEN_Y = exports.isIntersectingRoutedPoint = void 0;
      var inversify_1 = require_cjs4();
      var tinyqueue_1 = __importDefault(require_tinyqueue());
      var sweepline_1 = require_sweepline();
      function isIntersectingRoutedPoint(routedPoint) {
        return routedPoint !== void 0 && "intersections" in routedPoint && "kind" in routedPoint;
      }
      exports.isIntersectingRoutedPoint = isIntersectingRoutedPoint;
      var BY_X_THEN_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return a3.intersectionPoint.y - b3.intersectionPoint.y;
        }
        return a3.intersectionPoint.x - b3.intersectionPoint.x;
      };
      exports.BY_X_THEN_Y = BY_X_THEN_Y;
      var BY_DESCENDING_X_THEN_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return a3.intersectionPoint.y - b3.intersectionPoint.y;
        }
        return b3.intersectionPoint.x - a3.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_Y = BY_DESCENDING_X_THEN_Y;
      var BY_X_THEN_DESCENDING_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return b3.intersectionPoint.y - a3.intersectionPoint.y;
        }
        return a3.intersectionPoint.x - b3.intersectionPoint.x;
      };
      exports.BY_X_THEN_DESCENDING_Y = BY_X_THEN_DESCENDING_Y;
      var BY_DESCENDING_X_THEN_DESCENDING_Y = (a3, b3) => {
        if (a3.intersectionPoint.x === b3.intersectionPoint.x) {
          return b3.intersectionPoint.y - a3.intersectionPoint.y;
        }
        return b3.intersectionPoint.x - a3.intersectionPoint.x;
      };
      exports.BY_DESCENDING_X_THEN_DESCENDING_Y = BY_DESCENDING_X_THEN_DESCENDING_Y;
      var IntersectionFinder = class IntersectionFinder {
        /**
         * Finds all intersections in the specified `routing` and replaces the `RoutedPoints` that are
         * intersecting by adding intersection information to routing points (@see `IntersectingRoutedPoints`).
         * @param routing the edge routing to find intersections for and update.
         */
        apply(routing) {
          const intersections = this.find(routing);
          this.addToRouting(intersections, routing);
        }
        /**
         * Finds the intersections in the specified `routing` and returns them.
         * @param routing the edge routing to find intersections for and update.
         * @returns the identified intersections.
         */
        find(routing) {
          const eventQueue = new tinyqueue_1.default(void 0, sweepline_1.checkWhichEventIsLeft);
          routing.routes.forEach((route, routeId) => {
            if (this.isSupportedRoute(route)) {
              (0, sweepline_1.addRoute)(routeId, route, eventQueue);
            }
          });
          return (0, sweepline_1.runSweep)(eventQueue);
        }
        /**
         * Specifies whether or not a specific route should be included in this intersection search or not.
         *
         * As this intersection finder only supports linear line segments, this method only returns `true`
         * for routes that only contain routed points, which are either 'source', 'target' or 'linear'.
         */
        isSupportedRoute(route) {
          return route.find((point) => point.kind !== "source" && point.kind !== "target" && point.kind !== "linear") === void 0;
        }
        addToRouting(intersections, routing) {
          for (const intersection of intersections) {
            const routable1 = routing.get(intersection.routable1);
            const routable2 = routing.get(intersection.routable2);
            this.addIntersectionToRoutedPoint(intersection, routable1, intersection.segmentIndex1);
            this.addIntersectionToRoutedPoint(intersection, routable2, intersection.segmentIndex2);
          }
        }
        addIntersectionToRoutedPoint(intersection, routedPoint, segmentIndex) {
          if (routedPoint && routedPoint.length > segmentIndex) {
            const segment = routedPoint[segmentIndex + 1];
            if (isIntersectingRoutedPoint(segment)) {
              segment.intersections.push(intersection);
            } else {
              const intersectingRoutedPoint = Object.assign(Object.assign({}, segment), { intersections: [intersection] });
              routedPoint[segmentIndex + 1] = intersectingRoutedPoint;
            }
          }
        }
      };
      exports.IntersectionFinder = IntersectionFinder;
      exports.IntersectionFinder = IntersectionFinder = __decorate([
        (0, inversify_1.injectable)()
      ], IntersectionFinder);
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-junction/junction-finder.js
  var require_junction_finder = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-junction/junction-finder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JunctionFinder = void 0;
      var inversify_1 = require_cjs4();
      var sgraph_1 = require_sgraph();
      var JunctionFinder = class JunctionFinder {
        constructor() {
          this.edgesMap = /* @__PURE__ */ new Map();
          this.sourcesMap = /* @__PURE__ */ new Map();
          this.targetsMap = /* @__PURE__ */ new Map();
        }
        apply(routing, parent) {
          this.findJunctions(routing, parent);
        }
        findJunctions(routing, parent) {
          const edges = Array.from(parent.index.all().filter((child) => child instanceof sgraph_1.SEdgeImpl));
          edges.forEach((edge) => {
            this.edgesMap.set(edge.id, edge);
            const sameSources = this.sourcesMap.get(edge.sourceId);
            if (sameSources) {
              sameSources.add(edge.id);
            } else {
              this.sourcesMap.set(edge.sourceId, /* @__PURE__ */ new Set([edge.id]));
            }
            const sameTargets = this.targetsMap.get(edge.targetId);
            if (sameTargets) {
              sameTargets.add(edge.id);
            } else {
              this.targetsMap.set(edge.targetId, /* @__PURE__ */ new Set([edge.id]));
            }
          });
          routing.routes.forEach((route, routeId) => {
            const edge = this.edgesMap.get(routeId);
            if (!edge) {
              return;
            }
            this.findJunctionPointsWithSameSource(edge, route, routing);
            this.findJunctionPointsWithSameTarget(edge, route, routing);
          });
        }
        /**
         * Finds the junction points of routes with the same source
         */
        findJunctionPointsWithSameSource(edge, route, routing) {
          const sourcesSet = this.sourcesMap.get(edge.sourceId);
          if (!sourcesSet) {
            return;
          }
          const otherRoutesIds = Array.from(sourcesSet).filter((id) => id !== edge.id);
          const otherRoutes = otherRoutesIds.map((id) => routing.get(id)).filter((r3) => r3 !== void 0);
          for (const otherRoute of otherRoutes) {
            const junctionIndex = this.getJunctionIndex(route, otherRoute);
            if (junctionIndex === -1 || junctionIndex === 0) {
              continue;
            }
            this.setJunctionPoints(route, otherRoute, junctionIndex);
          }
        }
        /**
         * Finds the junction points of routes with the same target
         */
        findJunctionPointsWithSameTarget(edge, route, routing) {
          const targetsSet = this.targetsMap.get(edge.targetId);
          if (!targetsSet) {
            return;
          }
          const otherRoutesIds = Array.from(targetsSet).filter((id) => id !== edge.id);
          const otherRoutes = otherRoutesIds.map((id) => routing.get(id)).filter((r3) => r3 !== void 0);
          route.reverse();
          for (const otherRoute of otherRoutes) {
            otherRoute.reverse();
            const junctionIndex = this.getJunctionIndex(route, otherRoute);
            if (junctionIndex === -1 || junctionIndex === 0) {
              continue;
            }
            this.setJunctionPoints(route, otherRoute, junctionIndex);
            otherRoute.reverse();
          }
          route.reverse();
        }
        /**
         * Set the junction points of two routes according to the segments direction.
         * If the segments have different directions, the junction point is the previous common point.
         * If the segments have the same direction, the junction point is the point with the greatest or lowest value axis value depending on the direction.
         */
        setJunctionPoints(route, otherRoute, junctionIndex) {
          const firstSegmentDirection = this.getSegmentDirection(route[junctionIndex - 1], route[junctionIndex]);
          const secondSegmentDirection = this.getSegmentDirection(otherRoute[junctionIndex - 1], otherRoute[junctionIndex]);
          if (firstSegmentDirection !== secondSegmentDirection) {
            this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
          } else {
            if (firstSegmentDirection === "left" || firstSegmentDirection === "right") {
              if (route[junctionIndex].y !== otherRoute[junctionIndex].y) {
                this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
                return;
              }
              route[junctionIndex].isJunction = firstSegmentDirection === "left" ? route[junctionIndex].x > otherRoute[junctionIndex].x : route[junctionIndex].x < otherRoute[junctionIndex].x;
              otherRoute[junctionIndex].isJunction = firstSegmentDirection === "left" ? otherRoute[junctionIndex].x > route[junctionIndex].x : otherRoute[junctionIndex].x < route[junctionIndex].x;
            } else {
              if (route[junctionIndex].x !== otherRoute[junctionIndex].x) {
                this.setPreviousPointAsJunction(route, otherRoute, junctionIndex);
                return;
              }
              route[junctionIndex].isJunction = firstSegmentDirection === "up" ? route[junctionIndex].y > otherRoute[junctionIndex].y : route[junctionIndex].y < otherRoute[junctionIndex].y;
              otherRoute[junctionIndex].isJunction = firstSegmentDirection === "up" ? otherRoute[junctionIndex].y > route[junctionIndex].y : otherRoute[junctionIndex].y < route[junctionIndex].y;
            }
          }
        }
        /**
         * Set the previous point as a junction point.
         * This is used when two segments have the same direction but the other axis is different.
         * For example if the routes are going in opposite directions, or if the route don't split orthogonally.
         */
        setPreviousPointAsJunction(route, sameSourceRoute, junctionIndex) {
          route[junctionIndex - 1].isJunction = true;
          sameSourceRoute[junctionIndex - 1].isJunction = true;
        }
        /**
         * Get the main direction of a segment.
         * The main direction is the axis with the greatest difference between the two points.
         */
        getSegmentDirection(firstPoint, secondPoint) {
          const dX = secondPoint.x - firstPoint.x;
          const dY = secondPoint.y - firstPoint.y;
          let mainDirection = "horizontal";
          if (Math.abs(dX) < Math.abs(dY)) {
            mainDirection = "vertical";
          }
          if (mainDirection === "horizontal") {
            if (dX > 0) {
              return "right";
            } else {
              return "left";
            }
          } else {
            if (dY > 0) {
              return "down";
            } else {
              return "up";
            }
          }
        }
        /**
         * Finds the index where two routes diverge.
         * Returns -1 if no divergence can be found.
         */
        getJunctionIndex(firstRoute, secondRoute) {
          let idx = 0;
          while (idx < firstRoute.length && idx < secondRoute.length) {
            if (firstRoute[idx].x !== secondRoute[idx].x || firstRoute[idx].y !== secondRoute[idx].y) {
              return idx;
            }
            idx++;
          }
          return -1;
        }
      };
      exports.JunctionFinder = JunctionFinder;
      exports.JunctionFinder = JunctionFinder = __decorate([
        (0, inversify_1.injectable)()
      ], JunctionFinder);
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-junction/junction-postprocessor.js
  var require_junction_postprocessor = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-junction/junction-postprocessor.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JunctionPostProcessor = void 0;
      var inversify_1 = require_cjs4();
      var sprotty_protocol_1 = require_lib();
      var types_1 = require_types();
      var model_source_1 = require_model_source();
      var JunctionPostProcessor = class JunctionPostProcessor {
        constructor() {
          this.isFirstRender = true;
        }
        decorate(vnode, element) {
          return vnode;
        }
        postUpdate(cause) {
          if (this.currentModel !== this.modelSource.model) {
            this.isFirstRender = true;
          }
          if ((cause === null || cause === void 0 ? void 0 : cause.kind) === sprotty_protocol_1.RequestBoundsAction.KIND && this.isFirstRender) {
            const junctionPointsInHiddenDiv = document.querySelectorAll(`#${this.viewerOptions.hiddenDiv} > svg > g > g.sprotty-junction`);
            junctionPointsInHiddenDiv.forEach((e2) => e2.remove());
            const junctionPointsInBaseDiv = document.querySelectorAll(`#${this.viewerOptions.baseDiv} > svg > g > g.sprotty-junction`);
            junctionPointsInBaseDiv.forEach((e2) => e2.remove());
          }
          const hiddenSvg = document.querySelector(`#${this.viewerOptions.hiddenDiv} > svg > g`);
          const baseSvg = document.querySelector(`#${this.viewerOptions.baseDiv} > svg > g`);
          if (hiddenSvg) {
            const junctionGroups = Array.from(document.querySelectorAll(`#${this.viewerOptions.hiddenDiv} > svg > g > g > g.sprotty-junction`));
            junctionGroups.forEach((junctionGroup) => {
              junctionGroup.remove();
            });
            hiddenSvg.append(...junctionGroups);
          }
          if (baseSvg) {
            const junctionGroups = Array.from(document.querySelectorAll(`#${this.viewerOptions.baseDiv} > svg > g > g > g.sprotty-junction`));
            junctionGroups.forEach((junctionGroup) => {
              junctionGroup.remove();
            });
            baseSvg.append(...junctionGroups);
          }
          this.currentModel = this.modelSource.model;
          this.isFirstRender = false;
        }
      };
      exports.JunctionPostProcessor = JunctionPostProcessor;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], JunctionPostProcessor.prototype, "viewerOptions", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSource),
        __metadata("design:type", model_source_1.ModelSource)
      ], JunctionPostProcessor.prototype, "modelSource", void 0);
      exports.JunctionPostProcessor = JunctionPostProcessor = __decorate([
        (0, inversify_1.injectable)()
      ], JunctionPostProcessor);
    }
  });

  // ../../node_modules/sprotty/lib/features/move/move.js
  var require_move = __commonJS({
    "../../node_modules/sprotty/lib/features/move/move.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var MoveCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocationPostprocessor = exports.MoveMouseListener = exports.MorphEdgesAnimation = exports.MoveAnimation = exports.MoveCommand = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var actions_1 = require_actions();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var sgraph_1 = require_sgraph();
      var commit_model_1 = require_commit_model();
      var model_1 = require_model2();
      var create_on_drag_1 = require_create_on_drag();
      var edit_routing_1 = require_edit_routing();
      var reconnect_1 = require_reconnect();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var model_3 = require_model10();
      var model_4 = require_model6();
      var model_5 = require_model12();
      var model_6 = require_model8();
      var MoveCommand = MoveCommand_1 = class MoveCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.resolvedMoves = /* @__PURE__ */ new Map();
          this.edgeMementi = [];
          this.stoppableCommandKey = MoveCommand_1.KIND;
        }
        // stop the execution of the CompoundAnimation started below
        stopExecution() {
          if (this.animation) {
            this.animation.stop();
            this.animation = void 0;
          }
        }
        execute(context) {
          const index = context.root.index;
          const edge2handleMoves = /* @__PURE__ */ new Map();
          const attachedEdgeShifts = /* @__PURE__ */ new Map();
          this.action.moves.forEach((move) => {
            const element = index.getById(move.elementId);
            if (element instanceof model_2.SRoutingHandleImpl && this.edgeRouterRegistry) {
              const edge = element.parent;
              if (edge instanceof model_2.SRoutableElementImpl) {
                const resolvedMove = this.resolveHandleMove(element, edge, move);
                if (resolvedMove) {
                  let movesByEdge = edge2handleMoves.get(edge);
                  if (!movesByEdge) {
                    movesByEdge = [];
                    edge2handleMoves.set(edge, movesByEdge);
                  }
                  movesByEdge.push(resolvedMove);
                }
              }
            } else if (element && (0, model_6.isLocateable)(element)) {
              const resolvedMove = this.resolveElementMove(element, move);
              if (resolvedMove) {
                this.resolvedMoves.set(resolvedMove.element.id, resolvedMove);
                if (this.edgeRouterRegistry) {
                  const handleEdges = (el) => {
                    index.getAttachedElements(el).forEach((edge) => {
                      if (edge instanceof model_2.SRoutableElementImpl && !this.isChildOfMovedElements(edge)) {
                        const existingDelta = attachedEdgeShifts.get(edge);
                        const newDelta = geometry_1.Point.subtract(resolvedMove.toPosition, resolvedMove.fromPosition);
                        const delta = existingDelta ? geometry_1.Point.linear(existingDelta, newDelta, 0.5) : newDelta;
                        attachedEdgeShifts.set(edge, delta);
                      }
                    });
                  };
                  const handleEdgesForChildren = (el) => {
                    if ((0, smodel_1.isParent)(el)) {
                      el.children.forEach((childEl) => {
                        if (childEl instanceof smodel_1.SModelElementImpl) {
                          if (childEl instanceof model_2.SConnectableElementImpl) {
                            handleEdges(childEl);
                          }
                          handleEdgesForChildren(childEl);
                        }
                      });
                    }
                  };
                  handleEdgesForChildren(element);
                  handleEdges(element);
                }
              }
            }
          });
          this.doMove(edge2handleMoves, attachedEdgeShifts);
          if (this.action.animate) {
            this.undoMove();
            return (this.animation = new animation_1.CompoundAnimation(context.root, context, [
              new MoveAnimation(context.root, this.resolvedMoves, context, false),
              new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
            ])).start();
          }
          return context.root;
        }
        resolveHandleMove(handle, edge, move) {
          let fromPosition = move.fromPosition;
          if (!fromPosition) {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            fromPosition = router.getHandlePosition(edge, router.route(edge), handle);
          }
          if (fromPosition)
            return {
              handle,
              fromPosition,
              toPosition: move.toPosition
            };
          return void 0;
        }
        resolveElementMove(element, move) {
          const fromPosition = move.fromPosition || { x: element.position.x, y: element.position.y };
          return {
            element,
            fromPosition,
            toPosition: move.toPosition
          };
        }
        doMove(edge2move, attachedEdgeShifts) {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.toPosition;
          });
          edge2move.forEach((moves, edge) => {
            const router = this.edgeRouterRegistry.get(edge.routerKind);
            const before = router.takeSnapshot(edge);
            router.applyHandleMoves(edge, moves);
            const after = router.takeSnapshot(edge);
            this.edgeMementi.push({ edge, before, after });
          });
          attachedEdgeShifts.forEach((delta, edge) => {
            if (!edge2move.get(edge)) {
              const router = this.edgeRouterRegistry.get(edge.routerKind);
              const before = router.takeSnapshot(edge);
              if (this.isAttachedEdge(edge)) {
                edge.routingPoints = edge.routingPoints.map((rp) => geometry_1.Point.add(rp, delta));
              } else {
                const updateHandles = (0, model_4.isSelectable)(edge) && edge.selected;
                router.cleanupRoutingPoints(edge, edge.routingPoints, updateHandles, this.action.finished);
              }
              const after = router.takeSnapshot(edge);
              this.edgeMementi.push({ edge, before, after });
            }
          });
        }
        isChildOfMovedElements(el) {
          const parent = el.parent;
          if (Array.from(this.resolvedMoves.values()).map((rm) => rm.element.id).includes(parent.id)) {
            return true;
          }
          if (parent instanceof smodel_1.SChildElementImpl) {
            return this.isChildOfMovedElements(parent);
          }
          return false;
        }
        // tests if the edge is attached to the moved element directly or to on of their children
        isAttachedEdge(edge) {
          const source = edge.source;
          const target = edge.target;
          const checkMovedElementsAndChildren = (sourceOrTarget) => {
            return Boolean(this.resolvedMoves.get(sourceOrTarget.id)) || this.isChildOfMovedElements(sourceOrTarget);
          };
          return Boolean(source && target && checkMovedElementsAndChildren(source) && checkMovedElementsAndChildren(target));
        }
        undoMove() {
          this.resolvedMoves.forEach((res) => {
            res.element.position = res.fromPosition;
          });
          this.edgeMementi.forEach((memento) => {
            const router = this.edgeRouterRegistry.get(memento.edge.routerKind);
            router.applySnapshot(memento.edge, memento.before);
          });
        }
        undo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, true),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, true)
          ]).start();
        }
        redo(context) {
          return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, false),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
          ]).start();
        }
        merge(other, context) {
          if (!this.action.animate && other instanceof MoveCommand_1) {
            other.resolvedMoves.forEach((otherMove, otherElementId) => {
              const existingMove = this.resolvedMoves.get(otherElementId);
              if (existingMove) {
                existingMove.toPosition = otherMove.toPosition;
              } else {
                this.resolvedMoves.set(otherElementId, otherMove);
              }
            });
            other.edgeMementi.forEach((otherMemento) => {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            });
            return true;
          } else if (other instanceof reconnect_1.ReconnectCommand) {
            const otherMemento = other.memento;
            if (otherMemento) {
              const existingMemento = this.edgeMementi.find((edgeMemento) => edgeMemento.edge.id === otherMemento.edge.id);
              if (existingMemento) {
                existingMemento.after = otherMemento.after;
              } else {
                this.edgeMementi.push(otherMemento);
              }
            }
            return true;
          }
          return false;
        }
      };
      exports.MoveCommand = MoveCommand;
      MoveCommand.KIND = actions_1.MoveAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveCommand.prototype, "edgeRouterRegistry", void 0);
      exports.MoveCommand = MoveCommand = MoveCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], MoveCommand);
      var MoveAnimation = class extends animation_1.Animation {
        constructor(model, elementMoves, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementMoves = elementMoves;
          this.reverse = reverse;
        }
        tween(t3) {
          this.elementMoves.forEach((elementMove) => {
            if (this.reverse) {
              elementMove.element.position = {
                x: (1 - t3) * elementMove.toPosition.x + t3 * elementMove.fromPosition.x,
                y: (1 - t3) * elementMove.toPosition.y + t3 * elementMove.fromPosition.y
              };
            } else {
              elementMove.element.position = {
                x: (1 - t3) * elementMove.fromPosition.x + t3 * elementMove.toPosition.x,
                y: (1 - t3) * elementMove.fromPosition.y + t3 * elementMove.toPosition.y
              };
            }
          });
          return this.model;
        }
      };
      exports.MoveAnimation = MoveAnimation;
      var MorphEdgesAnimation = class extends animation_1.Animation {
        constructor(model, originalMementi, context, reverse = false) {
          super(context);
          this.model = model;
          this.reverse = reverse;
          this.expanded = [];
          originalMementi.forEach((edgeMemento) => {
            const start = this.reverse ? edgeMemento.after : edgeMemento.before;
            const end = this.reverse ? edgeMemento.before : edgeMemento.after;
            const startRoute = start.routedPoints;
            const endRoute = end.routedPoints;
            const maxRoutingPoints = Math.max(startRoute.length, endRoute.length);
            this.expanded.push({
              startExpandedRoute: this.growToSize(startRoute, maxRoutingPoints),
              endExpandedRoute: this.growToSize(endRoute, maxRoutingPoints),
              memento: edgeMemento
            });
          });
        }
        midPoint(edgeMemento) {
          const edge = edgeMemento.edge;
          const source = edgeMemento.edge.source;
          const target = edgeMemento.edge.target;
          return geometry_1.Point.linear((0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(source.bounds), source.parent, edge.parent), (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(target.bounds), target.parent, edge.parent), 0.5);
        }
        start() {
          this.expanded.forEach((morph) => {
            morph.memento.edge.removeAll((e2) => e2 instanceof model_2.SRoutingHandleImpl);
          });
          return super.start();
        }
        tween(t3) {
          if (t3 === 1) {
            this.expanded.forEach((morph) => {
              const memento = morph.memento;
              if (this.reverse)
                memento.before.router.applySnapshot(memento.edge, memento.before);
              else
                memento.after.router.applySnapshot(memento.edge, memento.after);
            });
          } else {
            this.expanded.forEach((morph) => {
              const newRoutingPoints = [];
              for (let i2 = 1; i2 < morph.startExpandedRoute.length - 1; ++i2)
                newRoutingPoints.push(geometry_1.Point.linear(morph.startExpandedRoute[i2], morph.endExpandedRoute[i2], t3));
              const closestSnapshot = t3 < 0.5 ? morph.memento.before : morph.memento.after;
              const newSnapshot = Object.assign(Object.assign({}, closestSnapshot), { routingPoints: newRoutingPoints, routingHandles: [] });
              closestSnapshot.router.applySnapshot(morph.memento.edge, newSnapshot);
            });
          }
          return this.model;
        }
        growToSize(route, targetSize) {
          const diff = targetSize - route.length;
          if (diff <= 0)
            return route;
          const result = [];
          result.push(route[0]);
          const deltaDiff = 1 / (diff + 1);
          const deltaSmaller = 1 / (route.length - 1);
          let nextInsertion = 1;
          for (let i2 = 1; i2 < route.length; ++i2) {
            const pos = deltaSmaller * i2;
            let insertions = 0;
            while (pos > (nextInsertion + insertions) * deltaDiff)
              ++insertions;
            nextInsertion += insertions;
            for (let j3 = 0; j3 < insertions; ++j3) {
              const p3 = geometry_1.Point.linear(route[i2 - 1], route[i2], (j3 + 1) / (insertions + 1));
              result.push(p3);
            }
            result.push(route[i2]);
          }
          return result;
        }
      };
      exports.MorphEdgesAnimation = MorphEdgesAnimation;
      var MoveMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.hasDragged = false;
          this.elementId2startPos = /* @__PURE__ */ new Map();
        }
        mouseDown(target, event) {
          if (event.button === 0) {
            const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_6.isMoveable);
            const isRoutingHandle = target instanceof model_2.SRoutingHandleImpl;
            if (moveable !== void 0 || isRoutingHandle || (0, create_on_drag_1.isCreatingOnDrag)(target)) {
              this.startDragPosition = { x: event.pageX, y: event.pageY };
            } else {
              this.startDragPosition = void 0;
            }
            this.hasDragged = false;
            if ((0, create_on_drag_1.isCreatingOnDrag)(target)) {
              return this.startCreatingOnDrag(target, event);
            } else if (isRoutingHandle) {
              return this.activateRoutingHandle(target, event);
            }
          }
          return [];
        }
        startCreatingOnDrag(target, event) {
          const result = [];
          result.push(actions_1.SelectAllAction.create({ select: false }));
          result.push(target.createAction(model_2.edgeInProgressID));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressID] }));
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [model_2.edgeInProgressTargetHandleID] }));
          result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [model_2.edgeInProgressTargetHandleID] }));
          return result;
        }
        activateRoutingHandle(target, event) {
          return [edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [target.id] })];
        }
        mouseMove(target, event) {
          const result = [];
          if (event.buttons === 0)
            this.mouseUp(target, event);
          else if (this.startDragPosition) {
            if (this.elementId2startPos.size === 0) {
              this.collectStartPositions(target.root);
            }
            this.hasDragged = true;
            const moveAction = this.getElementMoves(target, event, false);
            if (moveAction)
              result.push(moveAction);
          }
          return result;
        }
        collectStartPositions(root) {
          const selectedElements = new Set(root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected));
          selectedElements.forEach((element) => {
            if (!this.isChildOfSelected(selectedElements, element)) {
              if ((0, model_6.isMoveable)(element))
                this.elementId2startPos.set(element.id, element.position);
              else if (element instanceof model_2.SRoutingHandleImpl) {
                const position = this.getHandlePosition(element);
                if (position)
                  this.elementId2startPos.set(element.id, position);
              }
            }
          });
        }
        isChildOfSelected(selectedElements, element) {
          while (element instanceof smodel_1.SChildElementImpl) {
            element = element.parent;
            if ((0, model_6.isMoveable)(element) && selectedElements.has(element)) {
              return true;
            }
          }
          return false;
        }
        getElementMoves(target, event, isFinished) {
          if (!this.startDragPosition)
            return void 0;
          const elementMoves = [];
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_5.isViewport);
          const zoom = viewport ? viewport.zoom : 1;
          const delta = {
            x: (event.pageX - this.startDragPosition.x) / zoom,
            y: (event.pageY - this.startDragPosition.y) / zoom
          };
          this.elementId2startPos.forEach((startPosition, elementId) => {
            const element = target.root.index.getById(elementId);
            if (element) {
              const move = this.createElementMove(element, startPosition, delta, event);
              if (move) {
                elementMoves.push(move);
              }
            }
          });
          if (elementMoves.length > 0)
            return actions_1.MoveAction.create(elementMoves, { animate: false, finished: isFinished });
          else
            return void 0;
        }
        createElementMove(element, startPosition, delta, event) {
          const toPosition = this.snap({
            x: startPosition.x + delta.x,
            y: startPosition.y + delta.y
          }, element, !event.shiftKey);
          if ((0, model_6.isMoveable)(element)) {
            return {
              elementId: element.id,
              elementType: element.type,
              fromPosition: {
                x: element.position.x,
                y: element.position.y
              },
              toPosition
            };
          } else if (element instanceof model_2.SRoutingHandleImpl) {
            const point = this.getHandlePosition(element);
            if (point !== void 0) {
              return {
                elementId: element.id,
                elementType: element.type,
                fromPosition: point,
                toPosition
              };
            }
          }
          return void 0;
        }
        snap(position, element, isSnap) {
          if (isSnap && this.snapper)
            return this.snapper.snap(position, element);
          else
            return position;
        }
        getHandlePosition(handle) {
          if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(parent instanceof model_2.SRoutableElementImpl))
              return void 0;
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
          }
          return void 0;
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0 && !this.startDragPosition)
            this.mouseUp(target, event);
          return [];
        }
        mouseUp(target, event) {
          const result = [];
          if (this.startDragPosition) {
            const moveAction = this.getElementMoves(target, event, true);
            if (moveAction) {
              result.push(moveAction);
            }
            target.root.index.all().forEach((element) => {
              if (element instanceof model_2.SRoutingHandleImpl) {
                result.push(...this.deactivateRoutingHandle(element, target, event));
              }
            });
          }
          if (!result.some((a3) => a3.kind === actions_1.ReconnectAction.KIND)) {
            const edgeInProgress = target.root.index.getById(model_2.edgeInProgressID);
            if (edgeInProgress instanceof smodel_1.SChildElementImpl) {
              result.push(this.deleteEdgeInProgress(edgeInProgress));
            }
          }
          if (this.hasDragged) {
            result.push(commit_model_1.CommitModelAction.create());
          }
          this.hasDragged = false;
          this.startDragPosition = void 0;
          this.elementId2startPos.clear();
          return result;
        }
        deactivateRoutingHandle(element, target, event) {
          const result = [];
          const parent = element.parent;
          if (parent instanceof model_2.SRoutableElementImpl && element.danglingAnchor) {
            const handlePos = this.getHandlePosition(element);
            if (handlePos) {
              const handlePosAbs = (0, smodel_utils_1.translatePoint)(handlePos, element.parent, element.root);
              const newEnd = (0, model_1.findChildrenAtPosition)(target.root, handlePosAbs).find((e2) => (0, model_2.isConnectable)(e2) && e2.canConnect(parent, element.kind));
              if (newEnd && this.hasDragged) {
                result.push(actions_1.ReconnectAction.create({
                  routableId: element.parent.id,
                  newSourceId: element.kind === "source" ? newEnd.id : parent.sourceId,
                  newTargetId: element.kind === "target" ? newEnd.id : parent.targetId
                }));
              }
            }
          }
          if (element.editMode) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [element.id] }));
          }
          return result;
        }
        deleteEdgeInProgress(edgeInProgress) {
          const deleteIds = [];
          deleteIds.push(model_2.edgeInProgressID);
          edgeInProgress.children.forEach((c3) => {
            if (c3 instanceof model_2.SRoutingHandleImpl && c3.danglingAnchor)
              deleteIds.push(c3.danglingAnchor.id);
          });
          return actions_1.DeleteElementAction.create(deleteIds);
        }
        decorate(vnode, element) {
          return vnode;
        }
      };
      exports.MoveMouseListener = MoveMouseListener;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], MoveMouseListener.prototype, "edgeRouterRegistry", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ISnapper),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], MoveMouseListener.prototype, "snapper", void 0);
      var LocationPostprocessor = class LocationPostprocessor {
        decorate(vnode, element) {
          if ((0, model_3.isEdgeLayoutable)(element) && element.parent instanceof sgraph_1.SEdgeImpl) {
            return vnode;
          }
          let translate = "";
          if ((0, model_6.isLocateable)(element) && element instanceof smodel_1.SChildElementImpl && element.parent !== void 0) {
            const pos = element.position;
            if (pos.x !== 0 || pos.y !== 0) {
              translate = "translate(" + pos.x + ", " + pos.y + ")";
            }
          }
          if ((0, model_1.isAlignable)(element)) {
            const ali = element.alignment;
            if (ali.x !== 0 || ali.y !== 0) {
              if (translate.length > 0) {
                translate += " ";
              }
              translate += "translate(" + ali.x + ", " + ali.y + ")";
            }
          }
          if (translate.length > 0) {
            (0, vnode_utils_1.setAttr)(vnode, "transform", translate);
          }
          return vnode;
        }
        postUpdate() {
        }
      };
      exports.LocationPostprocessor = LocationPostprocessor;
      exports.LocationPostprocessor = LocationPostprocessor = __decorate([
        (0, inversify_1.injectable)()
      ], LocationPostprocessor);
    }
  });

  // ../../node_modules/sprotty/lib/features/move/snap.js
  var require_snap = __commonJS({
    "../../node_modules/sprotty/lib/features/move/snap.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterGridSnapper = void 0;
      var inversify_1 = require_cjs4();
      var model_1 = require_model2();
      var CenterGridSnapper = class CenterGridSnapper {
        get gridX() {
          return 10;
        }
        get gridY() {
          return 10;
        }
        snap(position, element) {
          if (element && (0, model_1.isBoundsAware)(element))
            return {
              x: Math.round((position.x + 0.5 * element.bounds.width) / this.gridX) * this.gridX - 0.5 * element.bounds.width,
              y: Math.round((position.y + 0.5 * element.bounds.height) / this.gridY) * this.gridY - 0.5 * element.bounds.height
            };
          else
            return {
              x: Math.round(position.x / this.gridX) * this.gridX,
              y: Math.round(position.y / this.gridY) * this.gridY
            };
        }
      };
      exports.CenterGridSnapper = CenterGridSnapper;
      exports.CenterGridSnapper = CenterGridSnapper = __decorate([
        (0, inversify_1.injectable)()
      ], CenterGridSnapper);
    }
  });

  // ../../node_modules/sprotty/lib/features/open/model.js
  var require_model16 = __commonJS({
    "../../node_modules/sprotty/lib/features/open/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isOpenable = exports.openFeature = void 0;
      exports.openFeature = Symbol("openFeature");
      function isOpenable(element) {
        return element.hasFeature(exports.openFeature);
      }
      exports.isOpenable = isOpenable;
    }
  });

  // ../../node_modules/sprotty/lib/features/open/open.js
  var require_open = __commonJS({
    "../../node_modules/sprotty/lib/features/open/open.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OpenMouseListener = void 0;
      var actions_1 = require_actions();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model16();
      var OpenMouseListener = class extends mouse_tool_1.MouseListener {
        doubleClick(target, event) {
          const openableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_1.isOpenable);
          if (openableTarget !== void 0) {
            return [actions_1.OpenAction.create(openableTarget.id)];
          }
          return [];
        }
      };
      exports.OpenMouseListener = OpenMouseListener;
    }
  });

  // ../../node_modules/sprotty/lib/features/projection/model.js
  var require_model17 = __commonJS({
    "../../node_modules/sprotty/lib/features/projection/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getModelBounds = exports.getProjectedBounds = exports.getProjections = exports.isProjectable = void 0;
      var geometry_1 = require_geometry();
      var object_1 = require_object();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model2();
      function isProjectable(arg) {
        return (0, object_1.hasOwnProperty)(arg, "projectionCssClasses");
      }
      exports.isProjectable = isProjectable;
      function getProjections(parent) {
        let result;
        for (const child of parent.children) {
          if (isProjectable(child) && child.projectionCssClasses.length > 0) {
            const projectedBounds = getProjectedBounds(child);
            if (projectedBounds) {
              const projection = {
                elementId: child.id,
                projectedBounds,
                cssClasses: child.projectionCssClasses
              };
              if (result) {
                result.push(projection);
              } else {
                result = [projection];
              }
            }
          }
          if (child.children.length > 0) {
            const childProj = getProjections(child);
            if (childProj) {
              if (result) {
                result.push(...childProj);
              } else {
                result = childProj;
              }
            }
          }
        }
        return result;
      }
      exports.getProjections = getProjections;
      function getProjectedBounds(model) {
        const parent = model.parent;
        if (model.projectedBounds) {
          let bounds = model.projectedBounds;
          if ((0, model_1.isBoundsAware)(parent)) {
            bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          }
          return bounds;
        } else if ((0, model_1.isBoundsAware)(model)) {
          let bounds = model.bounds;
          bounds = (0, smodel_utils_1.transformToRootBounds)(parent, bounds);
          return bounds;
        }
        return void 0;
      }
      exports.getProjectedBounds = getProjectedBounds;
      var MAX_COORD = 1e9;
      function getModelBounds(model) {
        let minX = MAX_COORD;
        let minY = MAX_COORD;
        let maxX = -MAX_COORD;
        let maxY = -MAX_COORD;
        const bounds = (0, model_1.isBoundsAware)(model) ? model.bounds : void 0;
        if (bounds && geometry_1.Dimension.isValid(bounds)) {
          minX = bounds.x;
          minY = bounds.y;
          maxX = minX + bounds.width;
          maxY = minY + bounds.height;
        } else {
          for (const element of model.children) {
            if ((0, model_1.isBoundsAware)(element)) {
              const b3 = element.bounds;
              minX = Math.min(minX, b3.x);
              minY = Math.min(minY, b3.y);
              maxX = Math.max(maxX, b3.x + b3.width);
              maxY = Math.max(maxY, b3.y + b3.height);
            }
          }
        }
        minX = Math.min(minX, model.scroll.x);
        minY = Math.min(minY, model.scroll.y);
        maxX = Math.max(maxX, model.scroll.x + model.canvasBounds.width / model.zoom);
        maxY = Math.max(maxY, model.scroll.y + model.canvasBounds.height / model.zoom);
        if (minX < maxX && minY < maxY) {
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        return void 0;
      }
      exports.getModelBounds = getModelBounds;
    }
  });

  // ../../node_modules/sprotty/lib/features/projection/views.js
  var require_views4 = __commonJS({
    "../../node_modules/sprotty/lib/features/projection/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProjectedViewportView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var snabbdom_1 = require_snabbdom_cjs();
      var vnode_utils_1 = require_vnode_utils();
      var model_1 = require_model17();
      var ProjectedViewportView = class ProjectedViewportView {
        render(model, context, args) {
          const rootNode = (0, jsx_1.html)(
            "div",
            { "class-sprotty-root": true },
            this.renderSvg(model, context, args),
            this.renderProjections(model, context, args)
          );
          (0, vnode_utils_1.setAttr)(rootNode, "tabindex", 0);
          return rootNode;
        }
        renderSvg(model, context, args) {
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          const ns = "http://www.w3.org/2000/svg";
          return (0, snabbdom_1.h)("svg", { ns }, (0, snabbdom_1.h)("g", { ns, attrs: { transform } }, context.renderChildren(model)));
        }
        renderProjections(model, context, args) {
          var _a4;
          if (model.zoom <= 0) {
            return [];
          }
          const modelBounds = (0, model_1.getModelBounds)(model);
          if (!modelBounds) {
            return [];
          }
          const projections = (_a4 = (0, model_1.getProjections)(model)) !== null && _a4 !== void 0 ? _a4 : [];
          return [
            this.renderProjectionBar(projections, model, modelBounds, "vertical"),
            this.renderProjectionBar(projections, model, modelBounds, "horizontal")
          ];
        }
        renderProjectionBar(projections, model, modelBounds, orientation) {
          const params = { modelBounds, orientation };
          params.factor = orientation === "horizontal" ? model.canvasBounds.width / modelBounds.width : model.canvasBounds.height / modelBounds.height;
          params.zoomedFactor = params.factor / model.zoom;
          return (0, jsx_1.html)(
            "div",
            { "class-sprotty-projection-bar": true, "class-horizontal": orientation === "horizontal", "class-vertical": orientation === "vertical" },
            this.renderViewport(model, params),
            projections.map((p3) => this.renderProjection(p3, model, params))
          );
        }
        renderViewport(model, params) {
          let canvasSize, viewportPos;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            viewportPos = (model.scroll.x - params.modelBounds.x) * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            viewportPos = (model.scroll.y - params.modelBounds.y) * params.factor;
          }
          let viewportSize = canvasSize * params.zoomedFactor;
          if (viewportPos < 0) {
            viewportSize += viewportPos;
            viewportPos = 0;
          } else if (viewportPos > canvasSize) {
            viewportPos = canvasSize;
          }
          if (viewportSize < 0) {
            viewportSize = 0;
          } else if (viewportPos + viewportSize > canvasSize) {
            viewportSize = canvasSize - viewportPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${viewportPos}px`,
            width: `${viewportSize}px`
          } : {
            top: `${viewportPos}px`,
            height: `${viewportSize}px`
          };
          return (0, jsx_1.html)("div", { "class-sprotty-viewport": true, style });
        }
        renderProjection(projection, model, params) {
          let canvasSize, projPos, projSize;
          if (params.orientation === "horizontal") {
            canvasSize = model.canvasBounds.width;
            projPos = (projection.projectedBounds.x - params.modelBounds.x) * params.factor;
            projSize = projection.projectedBounds.width * params.factor;
          } else {
            canvasSize = model.canvasBounds.height;
            projPos = (projection.projectedBounds.y - params.modelBounds.y) * params.factor;
            projSize = projection.projectedBounds.height * params.factor;
          }
          if (projPos < 0) {
            projSize += projPos;
            projPos = 0;
          } else if (projPos > canvasSize) {
            projPos = canvasSize;
          }
          if (projSize < 0) {
            projSize = 0;
          } else if (projPos + projSize > canvasSize) {
            projSize = canvasSize - projPos;
          }
          const style = params.orientation === "horizontal" ? {
            left: `${projPos}px`,
            width: `${projSize}px`
          } : {
            top: `${projPos}px`,
            height: `${projSize}px`
          };
          const result = (0, jsx_1.html)("div", { id: `${params.orientation}-projection:${projection.elementId}`, "class-sprotty-projection": true, style });
          projection.cssClasses.forEach((cl) => (0, vnode_utils_1.setClass)(result, cl, true));
          return result;
        }
      };
      exports.ProjectedViewportView = ProjectedViewportView;
      exports.ProjectedViewportView = ProjectedViewportView = __decorate([
        (0, inversify_1.injectable)()
      ], ProjectedViewportView);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/polyline-anchors.js
  var require_polyline_anchors = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/polyline-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiamondAnchor = exports.RectangleAnchor = exports.EllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var geometry_1 = require_geometry2();
      var inversify_1 = require_cjs4();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var geometry_2 = require_geometry();
      var EllipseAnchor = class EllipseAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c3 = geometry_2.Bounds.center(bounds);
          const dx = c3.x - refPoint.x;
          const dy = c3.y - refPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const normX = dx / distance || 0;
          const normY = dy / distance || 0;
          return {
            x: c3.x - normX * (0.5 * bounds.width + offset),
            y: c3.y - normY * (0.5 * bounds.height + offset)
          };
        }
      };
      exports.EllipseAnchor = EllipseAnchor;
      exports.EllipseAnchor = EllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], EllipseAnchor);
      var RectangleAnchor = class RectangleAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const bounds = connectable.bounds;
          const c3 = geometry_2.Bounds.center(bounds);
          const finder = new NearestPointFinder(c3, refPoint);
          if (!(0, geometry_2.almostEquals)(c3.y, refPoint.y)) {
            const xTop = this.getXIntersection(bounds.y, c3, refPoint);
            if (xTop >= bounds.x && xTop <= bounds.x + bounds.width)
              finder.addCandidate(xTop, bounds.y - offset);
            const xBottom = this.getXIntersection(bounds.y + bounds.height, c3, refPoint);
            if (xBottom >= bounds.x && xBottom <= bounds.x + bounds.width)
              finder.addCandidate(xBottom, bounds.y + bounds.height + offset);
          }
          if (!(0, geometry_2.almostEquals)(c3.x, refPoint.x)) {
            const yLeft = this.getYIntersection(bounds.x, c3, refPoint);
            if (yLeft >= bounds.y && yLeft <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x - offset, yLeft);
            const yRight = this.getYIntersection(bounds.x + bounds.width, c3, refPoint);
            if (yRight >= bounds.y && yRight <= bounds.y + bounds.height)
              finder.addCandidate(bounds.x + bounds.width + offset, yRight);
          }
          return finder.best;
        }
        getXIntersection(yIntersection, centerPoint, point) {
          const t3 = (yIntersection - centerPoint.y) / (point.y - centerPoint.y);
          return (point.x - centerPoint.x) * t3 + centerPoint.x;
        }
        getYIntersection(xIntersection, centerPoint, point) {
          const t3 = (xIntersection - centerPoint.x) / (point.x - centerPoint.x);
          return (point.y - centerPoint.y) * t3 + centerPoint.y;
        }
      };
      exports.RectangleAnchor = RectangleAnchor;
      exports.RectangleAnchor = RectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], RectangleAnchor);
      var NearestPointFinder = class {
        constructor(centerPoint, refPoint) {
          this.centerPoint = centerPoint;
          this.refPoint = refPoint;
          this.currentDist = -1;
        }
        addCandidate(x3, y3) {
          const dx = this.refPoint.x - x3;
          const dy = this.refPoint.y - y3;
          const dist = dx * dx + dy * dy;
          if (this.currentDist < 0 || dist < this.currentDist) {
            this.currentBest = {
              x: x3,
              y: y3
            };
            this.currentDist = dist;
          }
        }
        get best() {
          if (this.currentBest === void 0)
            return this.centerPoint;
          else
            return this.currentBest;
        }
      };
      var DiamondAnchor = class DiamondAnchor {
        get kind() {
          return polyline_edge_router_1.PolylineEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const bounds = connectable.bounds;
          const referenceLine = new geometry_1.PointToPointLine(geometry_2.Bounds.center(bounds), refPoint);
          const closestDiamondSide = new geometry_1.Diamond(bounds).closestSideLine(refPoint);
          const anchorPoint = (0, geometry_1.intersection)(closestDiamondSide, referenceLine);
          return geometry_2.Point.shiftTowards(anchorPoint, refPoint, offset);
        }
      };
      exports.DiamondAnchor = DiamondAnchor;
      exports.DiamondAnchor = DiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], DiamondAnchor);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/bezier-edge-router.js
  var require_bezier_edge_router = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/bezier-edge-router.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var BezierEdgeRouter_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddRemoveBezierSegmentCommand = exports.AddRemoveBezierSegmentAction = exports.BezierMouseListener = exports.BezierEdgeRouter = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_1 = require_model9();
      var routing_1 = require_routing();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var mouse_tool_1 = require_mouse_tool();
      var command_1 = require_command();
      var types_1 = require_types();
      var BezierEdgeRouter = BezierEdgeRouter_1 = class BezierEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return BezierEdgeRouter_1.KIND;
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const rpCount = edge.routingPoints.length;
          const source = edge.source;
          const target = edge.target;
          const result = [];
          result.push({ kind: "source", x: 0, y: 0 });
          if (rpCount === 0) {
            const [h1, h22] = this.createDefaultBezierHandles(source.position, target.position);
            result.push({ kind: "bezier-control-after", x: h1.x, y: h1.y, pointIndex: 0 });
            result.push({ kind: "bezier-control-before", x: h22.x, y: h22.y, pointIndex: 1 });
            edge.routingPoints.push(h1);
            edge.routingPoints.push(h22);
          } else if (rpCount >= 2) {
            for (let i2 = 0; i2 < rpCount; i2++) {
              const p3 = edge.routingPoints[i2];
              if (i2 % 3 === 0) {
                result.push({ kind: "bezier-control-after", x: p3.x, y: p3.y, pointIndex: i2 });
              }
              if ((i2 + 1) % 3 === 0) {
                result.push({ kind: "bezier-junction", x: p3.x, y: p3.y, pointIndex: i2 });
              } else if ((i2 + 2) % 3 === 0) {
                result.push({ kind: "bezier-control-before", x: p3.x, y: p3.y, pointIndex: i2 });
              }
            }
          }
          result.push({ kind: "target", x: 0, y: 0 });
          const p0 = rpCount > 2 ? edge.routingPoints[2] : target.position;
          const pn = rpCount > 2 ? edge.routingPoints[edge.routingPoints.length - 3] : source.position;
          const sourceAnchor = this.getTranslatedAnchor(source, p0, target.parent, edge, edge.sourceAnchorCorrection);
          const targetAnchor = this.getTranslatedAnchor(target, pn, source.parent, edge, edge.targetAnchorCorrection);
          result[0] = { kind: "source", x: sourceAnchor.x, y: sourceAnchor.y };
          result[result.length - 1] = { kind: "target", x: targetAnchor.x, y: targetAnchor.y };
          return result;
        }
        createDefaultBezierHandles(relH1, relH2) {
          const h1 = {
            x: relH1.x - BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH1.y
          };
          const h22 = {
            x: relH2.x + BezierEdgeRouter_1.DEFAULT_BEZIER_HANDLE_OFFSET,
            y: relH2.y
          };
          return [h1, h22];
        }
        createRoutingHandles(edge) {
          this.route(edge);
          this.rebuildHandles(edge);
        }
        rebuildHandles(edge) {
          this.addHandle(edge, "source", "routing-point", -2);
          this.addHandle(edge, "bezier-control-after", "bezier-routing-point", 0);
          this.addHandle(edge, "bezier-add", "bezier-create-routing-point", 0);
          const rpCount = edge.routingPoints.length;
          if (rpCount > 2) {
            for (let i2 = 1; i2 < rpCount - 1; i2 += 3) {
              this.addHandle(edge, "bezier-control-before", "bezier-routing-point", i2);
              this.addHandle(edge, "bezier-add", "bezier-create-routing-point", i2 + 1);
              this.addHandle(edge, "bezier-junction", "routing-point", i2 + 1);
              this.addHandle(edge, "bezier-remove", "bezier-remove-routing-point", i2 + 1);
              this.addHandle(edge, "bezier-control-after", "bezier-routing-point", i2 + 2);
              this.moveBezierControlPair(edge.routingPoints[i2], i2, edge);
            }
          }
          this.addHandle(edge, "bezier-control-before", "bezier-routing-point", rpCount - 1);
          this.addHandle(edge, "target", "routing-point", -1);
        }
        getInnerHandlePosition(edge, route, handle) {
          if (handle.kind === "bezier-control-before" || handle.kind === "bezier-junction" || handle.kind === "bezier-control-after") {
            for (let i2 = 0; i2 < route.length; i2++) {
              const p3 = route[i2];
              if (p3.pointIndex === handle.pointIndex && p3.kind === handle.kind)
                return p3;
            }
          } else if (handle.kind === "bezier-add") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y + 12.5 };
          } else if (handle.kind === "bezier-remove") {
            const ctrlPoint = this.findBezierControl(edge, route, handle.pointIndex);
            return { x: ctrlPoint.x, y: ctrlPoint.y - 12.5 };
          }
          return void 0;
        }
        findBezierControl(edge, route, handleIndex) {
          let result = { x: route[0].x, y: route[0].y };
          if (handleIndex > 0) {
            for (const rp of route) {
              if (rp.pointIndex !== void 0 && rp.pointIndex === handleIndex && rp.kind === "bezier-junction") {
                result = { x: rp.x, y: rp.y };
                break;
              }
            }
          }
          return result;
        }
        applyHandleMoves(edge, moves) {
          moves.forEach((move) => {
            const handle = move.handle;
            let orgPosition = { x: 0, y: 0 };
            let relativePos, newControlPos, ctrlPointIndex;
            const moveToPos = move.toPosition;
            switch (handle.kind) {
              case "bezier-control-before":
              case "bezier-control-after":
                this.moveBezierControlPair(moveToPos, move.handle.pointIndex, edge);
                break;
              case "bezier-junction":
                const index = handle.pointIndex;
                if (index >= 0 && index < edge.routingPoints.length) {
                  ctrlPointIndex = index - 1;
                  orgPosition = edge.routingPoints[index];
                  relativePos = edge.routingPoints[ctrlPointIndex];
                  newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                  edge.routingPoints[index] = moveToPos;
                  this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                }
                break;
              case "source":
                ctrlPointIndex = 0;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.source instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-source";
                  anchor.original = edge.source;
                  anchor.position = move.toPosition;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.sourceId = anchor.id;
                  if (edge.source)
                    orgPosition = edge.source.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              case "target":
                ctrlPointIndex = edge.routingPoints.length - 1;
                relativePos = edge.routingPoints[ctrlPointIndex];
                if (!(edge.target instanceof model_1.SDanglingAnchorImpl)) {
                  const anchor = new model_1.SDanglingAnchorImpl();
                  anchor.id = edge.id + "_dangling-target";
                  anchor.original = edge.target;
                  anchor.position = moveToPos;
                  handle.root.add(anchor);
                  handle.danglingAnchor = anchor;
                  edge.targetId = anchor.id;
                  if (edge.target)
                    orgPosition = edge.target.position;
                } else if (handle.danglingAnchor) {
                  orgPosition = handle.danglingAnchor.position;
                  handle.danglingAnchor.position = moveToPos;
                }
                newControlPos = this.calcRelativeMove(orgPosition, moveToPos, relativePos);
                this.moveBezierControlPair(newControlPos, ctrlPointIndex, edge);
                break;
              default:
                break;
            }
          });
        }
        applyInnerHandleMoves(edge, moves) {
        }
        getOptions(edge) {
          return {
            minimalPointDistance: 2,
            standardDistance: 0.1,
            selfEdgeOffset: 20
          };
        }
        calcRelativeMove(oldPos, newPos, relativePoint) {
          return {
            x: relativePoint.x - (oldPos.x - newPos.x),
            y: relativePoint.y - (oldPos.y - newPos.y)
          };
        }
        createNewBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          let bezierJunctionPos, start, end;
          if (routingPoints.length === 2) {
            start = routingPoints[index < 0 ? 0 : index];
            end = routingPoints[routingPoints.length - 1];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          } else {
            start = routingPoints[index];
            end = routingPoints[index + 2];
            bezierJunctionPos = (0, geometry_1.centerOfLine)(start, end);
          }
          const [h1, h22] = this.createDefaultBezierHandles(bezierJunctionPos, bezierJunctionPos);
          routingPoints.splice(index + 1, 0, h1);
          routingPoints.splice(index + 2, 0, bezierJunctionPos);
          routingPoints.splice(index + 3, 0, h22);
          this.moveBezierControlPair(h1, index + 1, edge);
          edge.removeAll((c3) => c3 instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        removeBezierSegment(index, edge) {
          const routingPoints = edge.routingPoints;
          routingPoints.splice(index - 1, 3);
          edge.removeAll((c3) => c3 instanceof model_1.SRoutingHandleImpl);
          this.rebuildHandles(edge);
        }
        moveBezierControlPair(newPos, ctrlPointIndex, edge) {
          if (ctrlPointIndex >= 0 && ctrlPointIndex < edge.routingPoints.length) {
            const before = ctrlPointIndex - 1;
            const after = ctrlPointIndex + 1;
            if (before < 0 || after === edge.routingPoints.length) {
              edge.routingPoints[ctrlPointIndex] = newPos;
            } else {
              if (ctrlPointIndex % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, false);
              } else if ((ctrlPointIndex + 2) % 3 === 0) {
                this.setBezierMirror(edge, newPos, ctrlPointIndex, true);
              }
            }
          }
        }
        setBezierMirror(edge, newPos, pointIndex, before) {
          edge.routingPoints[pointIndex] = newPos;
          const jct = edge.routingPoints[before ? pointIndex + 1 : pointIndex - 1];
          edge.routingPoints[before ? pointIndex + 2 : pointIndex - 2] = {
            x: jct.x - (newPos.x - jct.x),
            y: jct.y - (newPos.y - jct.y)
          };
        }
      };
      exports.BezierEdgeRouter = BezierEdgeRouter;
      BezierEdgeRouter.KIND = "bezier";
      BezierEdgeRouter.DEFAULT_BEZIER_HANDLE_OFFSET = 25;
      exports.BezierEdgeRouter = BezierEdgeRouter = BezierEdgeRouter_1 = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEdgeRouter);
      var BezierMouseListener = class extends mouse_tool_1.MouseListener {
        mouseDown(target, event) {
          const result = [];
          if (target instanceof model_1.SRoutingHandleImpl && (target.kind === "bezier-add" || target.kind === "bezier-remove")) {
            if (target.type === "bezier-create-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("add", target.id));
            } else if (target.type === "bezier-remove-routing-point") {
              result.push(AddRemoveBezierSegmentAction.create("remove", target.id));
            }
          }
          return result;
        }
      };
      exports.BezierMouseListener = BezierMouseListener;
      var AddRemoveBezierSegmentAction;
      (function(AddRemoveBezierSegmentAction2) {
        AddRemoveBezierSegmentAction2.KIND = "addRemoveBezierSegment";
        function create(actionTask, targetId) {
          return {
            kind: AddRemoveBezierSegmentAction2.KIND,
            actionTask,
            targetId
          };
        }
        AddRemoveBezierSegmentAction2.create = create;
      })(AddRemoveBezierSegmentAction || (exports.AddRemoveBezierSegmentAction = AddRemoveBezierSegmentAction = {}));
      var AddRemoveBezierSegmentCommand = class AddRemoveBezierSegmentCommand extends command_1.Command {
        constructor(action, edgeRouterRegistry) {
          super();
          this.action = action;
          this.edgeRouterRegistry = edgeRouterRegistry;
        }
        execute(context) {
          const index = context.root.index;
          const target = index.getById(this.action.targetId);
          if (this.edgeRouterRegistry && target instanceof model_1.SRoutingHandleImpl) {
            const raw = this.edgeRouterRegistry.get(target.parent.routerKind);
            if (raw instanceof BezierEdgeRouter) {
              const router = raw;
              for (const child of context.root.children) {
                if (child.id === target.parent.id) {
                  if (this.action.actionTask === "add") {
                    router.createNewBezierSegment(target.pointIndex, child);
                  } else if (this.action.actionTask === "remove") {
                    router.removeBezierSegment(target.pointIndex, child);
                  }
                  break;
                }
              }
            }
          }
          return context.root;
        }
        undo(context) {
          throw new Error("Method not implemented.");
        }
        redo(context) {
          throw new Error("Method not implemented.");
        }
      };
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand;
      AddRemoveBezierSegmentCommand.KIND = AddRemoveBezierSegmentAction.KIND;
      exports.AddRemoveBezierSegmentCommand = AddRemoveBezierSegmentCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __param(1, (0, inversify_1.inject)(routing_1.EdgeRouterRegistry)),
        __metadata("design:paramtypes", [Object, routing_1.EdgeRouterRegistry])
      ], AddRemoveBezierSegmentCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/bezier-anchors.js
  var require_bezier_anchors = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/bezier-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BezierDiamondAnchor = exports.BezierRectangleAnchor = exports.BezierEllipseAnchor = void 0;
      var anchor_1 = require_anchor();
      var inversify_1 = require_cjs4();
      var polyline_anchors_1 = require_polyline_anchors();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var BezierEllipseAnchor = class BezierEllipseAnchor extends polyline_anchors_1.EllipseAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.BezierEllipseAnchor = BezierEllipseAnchor;
      exports.BezierEllipseAnchor = BezierEllipseAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierEllipseAnchor);
      var BezierRectangleAnchor = class BezierRectangleAnchor extends polyline_anchors_1.RectangleAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.BezierRectangleAnchor = BezierRectangleAnchor;
      exports.BezierRectangleAnchor = BezierRectangleAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierRectangleAnchor);
      var BezierDiamondAnchor = class BezierDiamondAnchor extends polyline_anchors_1.DiamondAnchor {
        get kind() {
          return bezier_edge_router_1.BezierEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.BezierDiamondAnchor = BezierDiamondAnchor;
      exports.BezierDiamondAnchor = BezierDiamondAnchor = __decorate([
        (0, inversify_1.injectable)()
      ], BezierDiamondAnchor);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/manhattan-edge-router.js
  var require_manhattan_edge_router = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/manhattan-edge-router.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEdgeRouter = void 0;
      var geometry_1 = require_geometry();
      var smodel_utils_1 = require_smodel_utils();
      var abstract_edge_router_1 = require_abstract_edge_router();
      var model_1 = require_model9();
      var ManhattanEdgeRouter = class _ManhattanEdgeRouter extends abstract_edge_router_1.AbstractEdgeRouter {
        get kind() {
          return _ManhattanEdgeRouter.KIND;
        }
        getOptions(edge) {
          return {
            standardDistance: 20,
            minimalPointDistance: 3,
            selfEdgeOffset: 0.25
          };
        }
        route(edge) {
          if (!edge.source || !edge.target)
            return [];
          const routedCorners = this.createRoutedCorners(edge);
          const sourceRefPoint = routedCorners[0] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.target.bounds), edge.target.parent, edge.parent);
          const sourceAnchor = this.getTranslatedAnchor(edge.source, sourceRefPoint, edge.parent, edge, edge.sourceAnchorCorrection);
          const targetRefPoint = routedCorners[routedCorners.length - 1] || (0, smodel_utils_1.translatePoint)(geometry_1.Bounds.center(edge.source.bounds), edge.source.parent, edge.parent);
          const targetAnchor = this.getTranslatedAnchor(edge.target, targetRefPoint, edge.parent, edge, edge.targetAnchorCorrection);
          if (!sourceAnchor || !targetAnchor)
            return [];
          const routedPoints = [];
          routedPoints.push(Object.assign({ kind: "source" }, sourceAnchor));
          routedCorners.forEach((corner) => routedPoints.push(corner));
          routedPoints.push(Object.assign({ kind: "target" }, targetAnchor));
          return routedPoints;
        }
        createRoutedCorners(edge) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (edge.routingPoints.length > 0) {
            const routingPointsCopy = edge.routingPoints.slice();
            this.cleanupRoutingPoints(edge, routingPointsCopy, false, true);
            if (routingPointsCopy.length > 0)
              return routingPointsCopy.map((routingPoint, index) => {
                return Object.assign({ kind: "linear", pointIndex: index }, routingPoint);
              });
          }
          const options = this.getOptions(edge);
          const corners = this.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          return corners.map((corner) => {
            return Object.assign({ kind: "linear" }, corner);
          });
        }
        createRoutingHandles(edge) {
          const routedPoints = this.route(edge);
          this.commitRoute(edge, routedPoints);
          if (routedPoints.length > 0) {
            this.addHandle(edge, "source", "routing-point", -2);
            for (let i2 = 0; i2 < routedPoints.length - 1; ++i2)
              this.addHandle(edge, "manhattan-50%", "volatile-routing-point", i2 - 1);
            this.addHandle(edge, "target", "routing-point", routedPoints.length - 2);
          }
        }
        getInnerHandlePosition(edge, route, handle) {
          const fraction = this.getFraction(handle.kind);
          if (fraction !== void 0) {
            const { start, end } = this.findRouteSegment(edge, route, handle.pointIndex);
            if (start !== void 0 && end !== void 0)
              return geometry_1.Point.linear(start, end, fraction);
          }
          return void 0;
        }
        getFraction(kind) {
          switch (kind) {
            case "manhattan-50%":
              return 0.5;
            default:
              return void 0;
          }
        }
        applyInnerHandleMoves(edge, moves) {
          const route = this.route(edge);
          const routingPoints = edge.routingPoints;
          const minimalPointDistance = this.getOptions(edge).minimalPointDistance;
          moves.forEach((move) => {
            const handle = move.handle;
            const index = handle.pointIndex;
            const correctedX = this.correctX(routingPoints, index, move.toPosition.x, minimalPointDistance);
            const correctedY = this.correctY(routingPoints, index, move.toPosition.y, minimalPointDistance);
            switch (handle.kind) {
              case "manhattan-50%":
                if (index < 0) {
                  if (routingPoints.length === 0) {
                    routingPoints.push({ x: correctedX, y: correctedY });
                    handle.pointIndex = 0;
                  } else if ((0, geometry_1.almostEquals)(route[0].x, route[1].x)) {
                    this.alignX(routingPoints, 0, correctedX);
                  } else {
                    this.alignY(routingPoints, 0, correctedY);
                  }
                } else if (index < routingPoints.length - 1) {
                  if ((0, geometry_1.almostEquals)(routingPoints[index].x, routingPoints[index + 1].x)) {
                    this.alignX(routingPoints, index, correctedX);
                    this.alignX(routingPoints, index + 1, correctedX);
                  } else {
                    this.alignY(routingPoints, index, correctedY);
                    this.alignY(routingPoints, index + 1, correctedY);
                  }
                } else {
                  if ((0, geometry_1.almostEquals)(route[route.length - 2].x, route[route.length - 1].x)) {
                    this.alignX(routingPoints, routingPoints.length - 1, correctedX);
                  } else {
                    this.alignY(routingPoints, routingPoints.length - 1, correctedY);
                  }
                }
                break;
            }
          });
        }
        correctX(routingPoints, index, x3, minimalPointDistance) {
          if (index > 0 && Math.abs(x3 - routingPoints[index - 1].x) < minimalPointDistance)
            return routingPoints[index - 1].x;
          else if (index < routingPoints.length - 2 && Math.abs(x3 - routingPoints[index + 2].x) < minimalPointDistance)
            return routingPoints[index + 2].x;
          else
            return x3;
        }
        alignX(routingPoints, index, x3) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x: x3,
              y: routingPoints[index].y
            };
        }
        correctY(routingPoints, index, y3, minimalPointDistance) {
          if (index > 0 && Math.abs(y3 - routingPoints[index - 1].y) < minimalPointDistance)
            return routingPoints[index - 1].y;
          else if (index < routingPoints.length - 2 && Math.abs(y3 - routingPoints[index + 2].y) < minimalPointDistance)
            return routingPoints[index + 2].y;
          else
            return y3;
        }
        alignY(routingPoints, index, y3) {
          if (index >= 0 && index < routingPoints.length)
            routingPoints[index] = {
              x: routingPoints[index].x,
              y: y3
            };
        }
        cleanupRoutingPoints(edge, routingPoints, updateHandles, addRoutingPoints) {
          const sourceAnchors = new abstract_edge_router_1.DefaultAnchors(edge.source, edge.parent, "source");
          const targetAnchors = new abstract_edge_router_1.DefaultAnchors(edge.target, edge.parent, "target");
          if (this.resetRoutingPointsOnReconnect(edge, routingPoints, updateHandles, sourceAnchors, targetAnchors))
            return;
          for (let i2 = 0; i2 < routingPoints.length; ++i2)
            if (geometry_1.Bounds.includes(sourceAnchors.bounds, routingPoints[i2])) {
              routingPoints.splice(0, 1);
              if (updateHandles) {
                this.removeHandle(edge, -1);
              }
            } else {
              break;
            }
          for (let i2 = routingPoints.length - 1; i2 >= 0; --i2)
            if (geometry_1.Bounds.includes(targetAnchors.bounds, routingPoints[i2])) {
              routingPoints.splice(i2, 1);
              if (updateHandles) {
                this.removeHandle(edge, i2);
              }
            } else {
              break;
            }
          if (routingPoints.length >= 2) {
            const options = this.getOptions(edge);
            for (let i2 = routingPoints.length - 2; i2 >= 0; --i2) {
              if (geometry_1.Point.manhattanDistance(routingPoints[i2], routingPoints[i2 + 1]) < options.minimalPointDistance) {
                routingPoints.splice(i2, 2);
                --i2;
                if (updateHandles) {
                  this.removeHandle(edge, i2 - 1);
                  this.removeHandle(edge, i2);
                }
              }
            }
          }
          if (addRoutingPoints) {
            this.addAdditionalCorner(edge, routingPoints, sourceAnchors, targetAnchors, updateHandles);
            this.addAdditionalCorner(edge, routingPoints, targetAnchors, sourceAnchors, updateHandles);
            this.manhattanify(edge, routingPoints);
          }
        }
        removeHandle(edge, pointIndex) {
          const toBeRemoved = [];
          edge.children.forEach((child) => {
            if (child instanceof model_1.SRoutingHandleImpl) {
              if (child.pointIndex > pointIndex)
                --child.pointIndex;
              else if (child.pointIndex === pointIndex)
                toBeRemoved.push(child);
            }
          });
          toBeRemoved.forEach((child) => edge.remove(child));
        }
        addAdditionalCorner(edge, routingPoints, currentAnchors, otherAnchors, updateHandles) {
          if (routingPoints.length === 0)
            return;
          const refPoint = currentAnchors.kind === "source" ? routingPoints[0] : routingPoints[routingPoints.length - 1];
          const index = currentAnchors.kind === "source" ? 0 : routingPoints.length;
          const shiftIndex = index - (currentAnchors.kind === "source" ? 1 : 0);
          let isHorizontal;
          if (routingPoints.length > 1) {
            isHorizontal = index === 0 ? (0, geometry_1.almostEquals)(routingPoints[0].x, routingPoints[1].x) : (0, geometry_1.almostEquals)(routingPoints[routingPoints.length - 1].x, routingPoints[routingPoints.length - 2].x);
          } else {
            const nearestSide = otherAnchors.getNearestSide(refPoint);
            isHorizontal = nearestSide === abstract_edge_router_1.Side.TOP || nearestSide === abstract_edge_router_1.Side.BOTTOM;
          }
          if (isHorizontal) {
            if (refPoint.y < currentAnchors.get(abstract_edge_router_1.Side.TOP).y || refPoint.y > currentAnchors.get(abstract_edge_router_1.Side.BOTTOM).y) {
              const newPoint = { x: currentAnchors.get(abstract_edge_router_1.Side.TOP).x, y: refPoint.y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          } else {
            if (refPoint.x < currentAnchors.get(abstract_edge_router_1.Side.LEFT).x || refPoint.x > currentAnchors.get(abstract_edge_router_1.Side.RIGHT).x) {
              const newPoint = { x: refPoint.x, y: currentAnchors.get(abstract_edge_router_1.Side.LEFT).y };
              routingPoints.splice(index, 0, newPoint);
              if (updateHandles) {
                edge.children.forEach((child) => {
                  if (child instanceof model_1.SRoutingHandleImpl && child.pointIndex >= shiftIndex)
                    ++child.pointIndex;
                });
                this.addHandle(edge, "manhattan-50%", "volatile-routing-point", shiftIndex);
              }
            }
          }
        }
        /**
         * Add artificial routing points to keep all angles rectilinear.
         *
         * This makes edge morphing look a lot smoother, where RP positions are interpolated
         * linearly probably resulting in non-rectilinear angles. We don't add handles for
         * these additional RPs.
         */
        manhattanify(edge, routingPoints) {
          for (let i2 = 1; i2 < routingPoints.length; ++i2) {
            const isVertical = Math.abs(routingPoints[i2 - 1].x - routingPoints[i2].x) < 1;
            const isHorizontal = Math.abs(routingPoints[i2 - 1].y - routingPoints[i2].y) < 1;
            if (!isVertical && !isHorizontal) {
              routingPoints.splice(i2, 0, {
                x: routingPoints[i2 - 1].x,
                y: routingPoints[i2].y
              });
              ++i2;
            }
          }
        }
        calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options) {
          const selfEdge = super.calculateDefaultCorners(edge, sourceAnchors, targetAnchors, options);
          if (selfEdge.length > 0)
            return selfEdge;
          const bestAnchors = this.getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options);
          const sourceSide = bestAnchors.source;
          const targetSide = bestAnchors.target;
          const corners = [];
          const startPoint = sourceAnchors.get(sourceSide);
          let endPoint = targetAnchors.get(targetSide);
          switch (sourceSide) {
            case abstract_edge_router_1.Side.RIGHT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.RIGHT:
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: startPoint.y });
                  corners.push({ x: Math.max(startPoint.x, endPoint.x) + 1.5 * options.standardDistance, y: endPoint.y });
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.LEFT:
              switch (targetSide) {
                case abstract_edge_router_1.Side.BOTTOM:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: endPoint.x, y: startPoint.y });
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
                  if (endPoint.y !== startPoint.y) {
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: startPoint.y });
                    corners.push({ x: (startPoint.x + endPoint.x) / 2, y: endPoint.y });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.TOP:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y - options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.TOP:
                  corners.push({ x: startPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  corners.push({ x: endPoint.x, y: Math.min(startPoint.y, endPoint.y) - 1.5 * options.standardDistance });
                  break;
                case abstract_edge_router_1.Side.BOTTOM:
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
            case abstract_edge_router_1.Side.BOTTOM:
              switch (targetSide) {
                case abstract_edge_router_1.Side.RIGHT:
                  if (endPoint.x - startPoint.x > 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x + 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                case abstract_edge_router_1.Side.LEFT:
                  if (endPoint.x - startPoint.x < 0) {
                    corners.push({ x: startPoint.x, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: startPoint.y + options.standardDistance });
                    corners.push({ x: endPoint.x - 1.5 * options.standardDistance, y: endPoint.y });
                  } else {
                    corners.push({ x: startPoint.x, y: endPoint.y });
                  }
                  break;
                default:
                  endPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
                  if (endPoint.x !== startPoint.x) {
                    corners.push({ x: startPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                    corners.push({ x: endPoint.x, y: (startPoint.y + endPoint.y) / 2 });
                  }
                  break;
              }
              break;
          }
          return corners;
        }
        getBestConnectionAnchors(edge, sourceAnchors, targetAnchors, options) {
          let sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          let targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.RIGHT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.TOP };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (targetPoint.x - sourcePoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.LEFT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && sourcePoint.y - targetPoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.BOTTOM };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (sourcePoint.x - targetPoint.x > 0.5 * options.standardDistance && targetPoint.y - sourcePoint.y > options.standardDistance)
            return { source: abstract_edge_router_1.Side.LEFT, target: abstract_edge_router_1.Side.TOP };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (sourcePoint.y - targetPoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && sourcePoint.x - targetPoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (targetPoint.y - sourcePoint.y > 0.5 * options.standardDistance && targetPoint.x - sourcePoint.x > options.standardDistance)
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.TOP);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.y - targetPoint.y < 0) {
              if (Math.abs(sourcePoint.x - targetPoint.x) > (sourceAnchors.bounds.width + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            } else {
              if (Math.abs(sourcePoint.x - targetPoint.x) > targetAnchors.bounds.width / 2)
                return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.TOP };
            }
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.RIGHT);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint)) {
            if (sourcePoint.x - targetPoint.x > 0) {
              if (Math.abs(sourcePoint.y - targetPoint.y) > (sourceAnchors.bounds.height + options.standardDistance) / 2)
                return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
            } else if (Math.abs(sourcePoint.y - targetPoint.y) > targetAnchors.bounds.height / 2)
              return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.RIGHT };
          }
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.TOP);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.TOP, target: abstract_edge_router_1.Side.LEFT };
          sourcePoint = sourceAnchors.get(abstract_edge_router_1.Side.BOTTOM);
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.RIGHT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.RIGHT };
          targetPoint = targetAnchors.get(abstract_edge_router_1.Side.LEFT);
          if (!geometry_1.Bounds.includes(targetAnchors.bounds, sourcePoint) && !geometry_1.Bounds.includes(sourceAnchors.bounds, targetPoint))
            return { source: abstract_edge_router_1.Side.BOTTOM, target: abstract_edge_router_1.Side.LEFT };
          return { source: abstract_edge_router_1.Side.RIGHT, target: abstract_edge_router_1.Side.BOTTOM };
        }
      };
      exports.ManhattanEdgeRouter = ManhattanEdgeRouter;
      ManhattanEdgeRouter.KIND = "manhattan";
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/manhattan-anchors.js
  var require_manhattan_anchors = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/manhattan-anchors.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var ManhattanRectangularAnchor_1;
      var ManhattanDiamondAnchor_1;
      var ManhattanEllipticAnchor_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ManhattanEllipticAnchor = exports.ManhattanDiamondAnchor = exports.ManhattanRectangularAnchor = void 0;
      var geometry_1 = require_geometry();
      var geometry_2 = require_geometry2();
      var anchor_1 = require_anchor();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var inversify_1 = require_cjs4();
      var ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = class ManhattanRectangularAnchor {
        get kind() {
          return ManhattanRectangularAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            if (refPoint.y < bounds.y + 0.5 * bounds.height)
              return { x: refPoint.x, y: bounds.y };
            else
              return { x: refPoint.x, y: bounds.y + bounds.height };
          }
          if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            if (refPoint.x < bounds.x + 0.5 * bounds.width)
              return { x: bounds.x, y: refPoint.y };
            else
              return { x: bounds.x + bounds.width, y: refPoint.y };
          }
          return geometry_1.Bounds.center(bounds);
        }
      };
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor;
      ManhattanRectangularAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.RECTANGULAR_ANCHOR_KIND;
      exports.ManhattanRectangularAnchor = ManhattanRectangularAnchor = ManhattanRectangularAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanRectangularAnchor);
      var ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = class ManhattanDiamondAnchor {
        get kind() {
          return ManhattanDiamondAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          const c3 = geometry_1.Bounds.center(bounds);
          let outline = void 0;
          let refLine = void 0;
          if (refPoint.x >= bounds.x && refPoint.x <= bounds.x + bounds.width) {
            if (bounds.x + 0.5 * bounds.width >= refPoint.x) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c3.y });
              if (refPoint.y < c3.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: refPoint.x, y: c3.y });
              if (refPoint.y < c3.y)
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            }
          } else if (refPoint.y >= bounds.y && refPoint.y <= bounds.y + bounds.height) {
            if (bounds.y + 0.5 * bounds.height >= refPoint.y) {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c3.x, y: refPoint.y });
              if (refPoint.x < c3.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y });
            } else {
              refLine = new geometry_2.PointToPointLine(refPoint, { x: c3.x, y: refPoint.y });
              if (refPoint.x < c3.x)
                outline = new geometry_2.PointToPointLine({ x: bounds.x, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
              else
                outline = new geometry_2.PointToPointLine({ x: bounds.x + bounds.width, y: c3.y }, { x: c3.x, y: bounds.y + bounds.height });
            }
          }
          if (!!refLine && !!outline)
            return (0, geometry_2.intersection)(outline, refLine);
          else
            return c3;
        }
      };
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor;
      ManhattanDiamondAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.DIAMOND_ANCHOR_KIND;
      exports.ManhattanDiamondAnchor = ManhattanDiamondAnchor = ManhattanDiamondAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanDiamondAnchor);
      var ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = class ManhattanEllipticAnchor {
        get kind() {
          return ManhattanEllipticAnchor_1.KIND;
        }
        getAnchor(connectable, refPoint, offset = 0) {
          const b3 = connectable.bounds;
          if (b3.width <= 0 || b3.height <= 0) {
            return b3;
          }
          const bounds = {
            x: b3.x - offset,
            y: b3.y - offset,
            width: b3.width + 2 * offset,
            height: b3.height + 2 * offset
          };
          const c3 = geometry_1.Bounds.center(bounds);
          const refRelative = geometry_1.Point.subtract(refPoint, c3);
          let x3 = c3.x;
          let y3 = c3.y;
          if (refPoint.x >= bounds.x && bounds.x + bounds.width >= refPoint.x) {
            x3 += refRelative.x;
            const dy = 0.5 * bounds.height * Math.sqrt(1 - refRelative.x * refRelative.x / (0.25 * bounds.width * bounds.width));
            if (refRelative.y < 0)
              y3 -= dy;
            else
              y3 += dy;
          } else if (refPoint.y >= bounds.y && bounds.y + bounds.height >= refPoint.y) {
            y3 += refRelative.y;
            const dx = 0.5 * bounds.width * Math.sqrt(1 - refRelative.y * refRelative.y / (0.25 * bounds.height * bounds.height));
            if (refRelative.x < 0)
              x3 -= dx;
            else
              x3 += dx;
          }
          return { x: x3, y: y3 };
        }
      };
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor;
      ManhattanEllipticAnchor.KIND = manhattan_edge_router_1.ManhattanEdgeRouter.KIND + ":" + anchor_1.ELLIPTIC_ANCHOR_KIND;
      exports.ManhattanEllipticAnchor = ManhattanEllipticAnchor = ManhattanEllipticAnchor_1 = __decorate([
        (0, inversify_1.injectable)()
      ], ManhattanEllipticAnchor);
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/views.js
  var require_views5 = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RoutableView = void 0;
      var inversify_1 = require_cjs4();
      var model_1 = require_model9();
      var RoutableView = class RoutableView {
        /**
         * Check whether the given model element is in the current viewport. Use this method
         * in your `render` implementation to skip rendering in case the element is not visible.
         * This can greatly enhance performance for large models.
         */
        isVisible(model, route, context) {
          if (context.targetKind === "hidden") {
            return true;
          }
          if (route.length === 0) {
            return true;
          }
          const ab = (0, model_1.getAbsoluteRouteBounds)(model, route);
          const canvasBounds = model.root.canvasBounds;
          return ab.x <= canvasBounds.width && ab.x + ab.width >= 0 && ab.y <= canvasBounds.height && ab.y + ab.height >= 0;
        }
      };
      exports.RoutableView = RoutableView;
      exports.RoutableView = RoutableView = __decorate([
        (0, inversify_1.injectable)()
      ], RoutableView);
    }
  });

  // ../../node_modules/sprotty/lib/base/commands/request-command.js
  var require_request_command = __commonJS({
    "../../node_modules/sprotty/lib/base/commands/request-command.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ModelRequestCommand = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var command_1 = require_command();
      var ModelRequestCommand = class ModelRequestCommand extends command_1.SystemCommand {
        execute(context) {
          const result = this.retrieveResult(context);
          this.actionDispatcher.dispatch(result);
          return { model: context.root, modelChanged: false };
        }
        undo(context) {
          return { model: context.root, modelChanged: false };
        }
        redo(context) {
          return { model: context.root, modelChanged: false };
        }
      };
      exports.ModelRequestCommand = ModelRequestCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
      ], ModelRequestCommand.prototype, "actionDispatcher", void 0);
      exports.ModelRequestCommand = ModelRequestCommand = __decorate([
        (0, inversify_1.injectable)()
      ], ModelRequestCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/scroll.js
  var require_scroll = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/scroll.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findViewportScrollbar = exports.ScrollMouseListener = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var mouse_tool_1 = require_mouse_tool();
      var smodel_utils_1 = require_smodel_utils();
      var model_1 = require_model12();
      var model_2 = require_model8();
      var model_3 = require_model9();
      var model_4 = require_model17();
      var browser_1 = require_browser();
      var types_1 = require_types();
      var ScrollMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.scrollbarMouseDownDelay = 200;
        }
        mouseDown(target, event) {
          const moveable = (0, smodel_utils_1.findParentByFeature)(target, model_2.isMoveable);
          if (moveable === void 0 && !(target instanceof model_3.SRoutingHandleImpl)) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              this.lastScrollPosition = { x: event.pageX, y: event.pageY };
              this.scrollbar = this.getScrollbar(event);
              if (this.scrollbar) {
                window.clearTimeout(this.scrollbarMouseDownTimeout);
                return this.moveScrollBar(viewport, event, this.scrollbar, true).map((action) => new Promise((resolve) => {
                  this.scrollbarMouseDownTimeout = window.setTimeout(() => resolve(action), this.scrollbarMouseDownDelay);
                }));
              }
            } else {
              this.lastScrollPosition = void 0;
              this.scrollbar = void 0;
            }
          }
          return [];
        }
        mouseMove(target, event) {
          if (event.buttons === 0) {
            return this.mouseUp(target, event);
          }
          if (this.scrollbar) {
            window.clearTimeout(this.scrollbarMouseDownTimeout);
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.moveScrollBar(viewport, event, this.scrollbar);
            }
          }
          if (this.lastScrollPosition) {
            const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
            if (viewport) {
              return this.dragCanvas(viewport, event, this.lastScrollPosition);
            }
          }
          return [];
        }
        mouseEnter(target, event) {
          if (target instanceof smodel_1.SModelRootImpl && event.buttons === 0) {
            this.mouseUp(target, event);
          }
          return [];
        }
        mouseUp(target, event) {
          this.lastScrollPosition = void 0;
          this.scrollbar = void 0;
          return [];
        }
        doubleClick(target, event) {
          const viewport = (0, smodel_utils_1.findParentByFeature)(target, model_1.isViewport);
          if (viewport) {
            const scrollbar = this.getScrollbar(event);
            if (scrollbar) {
              window.clearTimeout(this.scrollbarMouseDownTimeout);
              const targetElement = this.findClickTarget(scrollbar, event);
              let elementId;
              if (targetElement && targetElement.id.startsWith("horizontal-projection:")) {
                elementId = targetElement.id.substring("horizontal-projection:".length);
              } else if (targetElement && targetElement.id.startsWith("vertical-projection:")) {
                elementId = targetElement.id.substring("vertical-projection:".length);
              }
              if (elementId) {
                return [actions_1.CenterAction.create([elementId], { animate: true, retainZoom: true })];
              }
            }
          }
          return [];
        }
        dragCanvas(model, event, lastScrollPosition) {
          let dx = (event.pageX - lastScrollPosition.x) / model.zoom;
          if (dx > 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.min) || dx < 0 && (0, geometry_1.almostEquals)(model.scroll.x, this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom)) {
            dx = 0;
          }
          let dy = (event.pageY - lastScrollPosition.y) / model.zoom;
          if (dy > 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.min) || dy < 0 && (0, geometry_1.almostEquals)(model.scroll.y, this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom)) {
            dy = 0;
          }
          if (dx === 0 && dy === 0) {
            return [];
          }
          const newViewport = {
            scroll: {
              x: model.scroll.x - dx,
              y: model.scroll.y - dy
            },
            zoom: model.zoom
          };
          this.lastScrollPosition = { x: event.pageX, y: event.pageY };
          return [actions_1.SetViewportAction.create(model.id, newViewport, { animate: false })];
        }
        moveScrollBar(model, event, scrollbar, animate = false) {
          const modelBounds = (0, model_4.getModelBounds)(model);
          if (!modelBounds || model.zoom <= 0) {
            return [];
          }
          const scrollbarRect = scrollbar.getBoundingClientRect();
          let newScroll;
          if (this.getScrollbarOrientation(scrollbar) === "horizontal") {
            if (scrollbarRect.width <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.width / (model.zoom * modelBounds.width) * scrollbarRect.width;
            let position = event.clientX - scrollbarRect.x - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.width - viewportSize) {
              position = scrollbarRect.width - viewportSize;
            }
            newScroll = {
              x: modelBounds.x + position / scrollbarRect.width * modelBounds.width,
              y: model.scroll.y
            };
            if (newScroll.x < this.viewerOptions.horizontalScrollLimits.min) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.min;
            } else if (newScroll.x > this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom) {
              newScroll.x = this.viewerOptions.horizontalScrollLimits.max - model.canvasBounds.width / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.x, model.scroll.x)) {
              return [];
            }
          } else {
            if (scrollbarRect.height <= 0) {
              return [];
            }
            const viewportSize = model.canvasBounds.height / (model.zoom * modelBounds.height) * scrollbarRect.height;
            let position = event.clientY - scrollbarRect.y - viewportSize / 2;
            if (position < 0) {
              position = 0;
            } else if (position > scrollbarRect.height - viewportSize) {
              position = scrollbarRect.height - viewportSize;
            }
            newScroll = {
              x: model.scroll.x,
              y: modelBounds.y + position / scrollbarRect.height * modelBounds.height
            };
            if (newScroll.y < this.viewerOptions.verticalScrollLimits.min) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.min;
            } else if (newScroll.y > this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom) {
              newScroll.y = this.viewerOptions.verticalScrollLimits.max - model.canvasBounds.height / model.zoom;
            }
            if ((0, geometry_1.almostEquals)(newScroll.y, model.scroll.y)) {
              return [];
            }
          }
          return [actions_1.SetViewportAction.create(model.id, { scroll: newScroll, zoom: model.zoom }, { animate })];
        }
        getScrollbar(event) {
          return findViewportScrollbar(event);
        }
        getScrollbarOrientation(scrollbar) {
          if (scrollbar.classList.contains("horizontal")) {
            return "horizontal";
          } else {
            return "vertical";
          }
        }
        findClickTarget(scrollbar, event) {
          const matching = Array.from(scrollbar.children).filter((child) => child.id && child.classList.contains("sprotty-projection") && (0, browser_1.hitsMouseEvent)(child, event));
          if (matching.length > 0) {
            return matching[matching.length - 1];
          }
          return void 0;
        }
      };
      exports.ScrollMouseListener = ScrollMouseListener;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], ScrollMouseListener.prototype, "viewerOptions", void 0);
      function findViewportScrollbar(event) {
        let element = event.target;
        while (element) {
          if (element.classList && element.classList.contains("sprotty-projection-bar")) {
            return element;
          }
          element = element.parentElement;
        }
        return void 0;
      }
      exports.findViewportScrollbar = findViewportScrollbar;
    }
  });

  // ../../node_modules/sprotty/lib/features/select/select.js
  var require_select = __commonJS({
    "../../node_modules/sprotty/lib/features/select/select.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SelectKeyboardListener = exports.GetSelectionCommand = exports.SelectMouseListener = exports.SelectAllCommand = exports.SelectCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var command_1 = require_command();
      var request_command_1 = require_request_command();
      var smodel_1 = require_smodel();
      var smodel_utils_1 = require_smodel_utils();
      var types_1 = require_types();
      var key_tool_1 = require_key_tool();
      var mouse_tool_1 = require_mouse_tool();
      var vnode_utils_1 = require_vnode_utils();
      var browser_1 = require_browser();
      var iterable_1 = require_iterable();
      var keyboard_1 = require_keyboard();
      var button_handler_1 = require_button_handler();
      var model_1 = require_model4();
      var edit_routing_1 = require_edit_routing();
      var model_2 = require_model9();
      var model_3 = require_model9();
      var scroll_1 = require_scroll();
      var model_4 = require_model6();
      var SelectCommand = class SelectCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
          this.deselected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.selectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.selected.push(element);
            }
          });
          this.action.deselectedElementsIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof smodel_1.SChildElementImpl && (0, model_4.isSelectable)(element)) {
              this.deselected.push(element);
            }
          });
          return this.redo(context);
        }
        undo(context) {
          for (const element of this.selected) {
            element.selected = false;
          }
          for (const element of this.deselected) {
            element.selected = true;
          }
          return context.root;
        }
        redo(context) {
          for (const element of this.deselected) {
            element.selected = false;
          }
          for (const element of this.selected) {
            element.selected = true;
          }
          return context.root;
        }
      };
      exports.SelectCommand = SelectCommand;
      SelectCommand.KIND = actions_1.SelectAction.KIND;
      exports.SelectCommand = SelectCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectCommand);
      var SelectAllCommand = class SelectAllCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        execute(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
        selectAll(element, newState) {
          if ((0, model_4.isSelectable)(element)) {
            this.previousSelection[element.id] = element.selected;
            element.selected = newState;
          }
          for (const child of element.children) {
            this.selectAll(child, newState);
          }
        }
        undo(context) {
          const index = context.root.index;
          Object.keys(this.previousSelection).forEach((id) => {
            const element = index.getById(id);
            if (element !== void 0 && (0, model_4.isSelectable)(element))
              element.selected = this.previousSelection[id];
          });
          return context.root;
        }
        redo(context) {
          this.selectAll(context.root, this.action.select);
          return context.root;
        }
      };
      exports.SelectAllCommand = SelectAllCommand;
      SelectAllCommand.KIND = actions_1.SelectAllAction.KIND;
      exports.SelectAllCommand = SelectAllCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SelectAllCommand);
      var SelectMouseListener = class extends mouse_tool_1.MouseListener {
        constructor() {
          super(...arguments);
          this.wasSelected = false;
          this.hasDragged = false;
          this.isMouseDown = false;
        }
        mouseDown(target, event) {
          if (event.button !== 0) {
            return [];
          }
          this.isMouseDown = true;
          const buttonHandled = this.handleButton(target, event);
          if (buttonHandled) {
            return buttonHandled;
          }
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
          if (selectableTarget !== void 0 || target instanceof smodel_1.SModelRootImpl) {
            this.hasDragged = false;
          }
          if (selectableTarget !== void 0) {
            let deselectedElements = [];
            if (!(0, browser_1.isCtrlOrCmd)(event)) {
              deselectedElements = this.collectElementsToDeselect(target, selectableTarget);
            }
            if (!selectableTarget.selected) {
              this.wasSelected = false;
              return this.handleSelectTarget(selectableTarget, deselectedElements, event);
            } else if ((0, browser_1.isCtrlOrCmd)(event)) {
              this.wasSelected = false;
              return this.handleDeselectTarget(selectableTarget, event);
            } else {
              this.wasSelected = true;
            }
          }
          return [];
        }
        collectElementsToDeselect(target, selectableTarget) {
          return (0, iterable_1.toArray)(target.root.index.all().filter((element) => (0, model_4.isSelectable)(element) && element.selected && !(selectableTarget instanceof model_2.SRoutingHandleImpl && element === selectableTarget.parent)));
        }
        handleButton(target, event) {
          if (this.buttonHandlerRegistry !== void 0 && target instanceof model_1.SButtonImpl && target.enabled) {
            const buttonHandler = this.buttonHandlerRegistry.get(target.type);
            if (buttonHandler !== void 0) {
              return buttonHandler.buttonPressed(target);
            }
          }
          return void 0;
        }
        handleSelectTarget(selectableTarget, deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: deselectedElements.map((e2) => e2.id) }));
          result.push(actions_1.BringToFrontAction.create([selectableTarget.id]));
          const routableDeselect = deselectedElements.filter((e2) => e2 instanceof model_3.SRoutableElementImpl).map((e2) => e2.id);
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToActivate: [selectableTarget.id], elementsToDeactivate: routableDeselect }));
          } else if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        handleDeselectTarget(selectableTarget, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: [selectableTarget.id] }));
          if (selectableTarget instanceof model_3.SRoutableElementImpl) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: [selectableTarget.id] }));
          }
          return result;
        }
        handleDeselectAll(deselectedElements, event) {
          const result = [];
          result.push(actions_1.SelectAction.create({ selectedElementsIDs: [], deselectedElementsIDs: deselectedElements.map((e2) => e2.id) }));
          const routableDeselect = deselectedElements.filter((e2) => e2 instanceof model_3.SRoutableElementImpl).map((e2) => e2.id);
          if (routableDeselect.length > 0) {
            result.push(edit_routing_1.SwitchEditModeAction.create({ elementsToDeactivate: routableDeselect }));
          }
          return result;
        }
        mouseMove(target, event) {
          this.hasDragged = this.isMouseDown;
          return [];
        }
        mouseUp(target, event) {
          if (event.button === 0) {
            if (!this.hasDragged) {
              const selectableTarget = (0, smodel_utils_1.findParentByFeature)(target, model_4.isSelectable);
              if (selectableTarget !== void 0) {
                if (this.wasSelected) {
                  return [actions_1.SelectAction.create({ selectedElementsIDs: [selectableTarget.id], deselectedElementsIDs: [] })];
                }
              } else if (target instanceof smodel_1.SModelRootImpl && !(0, scroll_1.findViewportScrollbar)(event) || !(target instanceof smodel_1.SModelRootImpl)) {
                return this.handleDeselectAll(this.collectElementsToDeselect(target, void 0), event);
              }
            }
          }
          this.isMouseDown = false;
          this.hasDragged = false;
          return [];
        }
        decorate(vnode, element) {
          const selectableTarget = (0, smodel_utils_1.findParentByFeature)(element, model_4.isSelectable);
          if (selectableTarget !== void 0) {
            (0, vnode_utils_1.setClass)(vnode, "selected", selectableTarget.selected);
          }
          return vnode;
        }
      };
      exports.SelectMouseListener = SelectMouseListener;
      __decorate([
        (0, inversify_1.inject)(button_handler_1.ButtonHandlerRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", button_handler_1.ButtonHandlerRegistry)
      ], SelectMouseListener.prototype, "buttonHandlerRegistry", void 0);
      var GetSelectionCommand = class GetSelectionCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
          this.previousSelection = {};
        }
        retrieveResult(context) {
          const selection = context.root.index.all().filter((e2) => (0, model_4.isSelectable)(e2) && e2.selected).map((e2) => e2.id);
          return actions_1.SelectionResult.create((0, iterable_1.toArray)(selection), this.action.requestId);
        }
      };
      exports.GetSelectionCommand = GetSelectionCommand;
      GetSelectionCommand.KIND = actions_1.GetSelectionAction.KIND;
      exports.GetSelectionCommand = GetSelectionCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetSelectionCommand);
      var SelectKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyA", "ctrlCmd")) {
            return [actions_1.SelectAllAction.create()];
          }
          return [];
        }
      };
      exports.SelectKeyboardListener = SelectKeyboardListener;
    }
  });

  // ../../node_modules/sprotty/lib/features/undo-redo/undo-redo.js
  var require_undo_redo = __commonJS({
    "../../node_modules/sprotty/lib/features/undo-redo/undo-redo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UndoRedoKeyListener = void 0;
      var actions_1 = require_actions();
      var keyboard_1 = require_keyboard();
      var key_tool_1 = require_key_tool();
      var browser_1 = require_browser();
      var UndoRedoKeyListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd"))
            return [actions_1.UndoAction.create()];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyZ", "ctrlCmd", "shift") || !(0, browser_1.isMac)() && (0, keyboard_1.matchesKeystroke)(event, "KeyY", "ctrlCmd"))
            return [actions_1.RedoAction.create()];
          return [];
        }
      };
      exports.UndoRedoKeyListener = UndoRedoKeyListener;
    }
  });

  // ../../node_modules/sprotty/lib/features/update/model-matching.js
  var require_model_matching = __commonJS({
    "../../node_modules/sprotty/lib/features/update/model-matching.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyMatches = exports.ModelMatcher = exports.forEachMatch = void 0;
      var smodel_1 = require_smodel();
      var sprotty_protocol_1 = require_lib();
      function forEachMatch(matchResult, callback) {
        Object.keys(matchResult).forEach((id) => callback(id, matchResult[id]));
      }
      exports.forEachMatch = forEachMatch;
      var ModelMatcher = class {
        match(left, right) {
          const result = {};
          this.matchLeft(left, result);
          this.matchRight(right, result);
          return result;
        }
        matchLeft(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.left = element;
            match.leftParentId = parentId;
          } else {
            match = {
              left: element,
              leftParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchLeft(child, result, element.id);
            }
          }
        }
        matchRight(element, result, parentId) {
          let match = result[element.id];
          if (match !== void 0) {
            match.right = element;
            match.rightParentId = parentId;
          } else {
            match = {
              right: element,
              rightParentId: parentId
            };
            result[element.id] = match;
          }
          if ((0, smodel_1.isParent)(element)) {
            for (const child of element.children) {
              this.matchRight(child, result, element.id);
            }
          }
        }
      };
      exports.ModelMatcher = ModelMatcher;
      function applyMatches(root, matches, index) {
        if (root instanceof smodel_1.SModelRootImpl) {
          index = root.index;
        } else if (index === void 0) {
          index = new sprotty_protocol_1.SModelIndex();
          index.add(root);
        }
        for (const match of matches) {
          let newElementInserted = false;
          if (match.left !== void 0 && match.leftParentId !== void 0) {
            const parent = index.getById(match.leftParentId);
            if (parent !== void 0 && parent.children !== void 0) {
              const i2 = parent.children.indexOf(match.left);
              if (i2 >= 0) {
                if (match.right !== void 0 && match.leftParentId === match.rightParentId) {
                  parent.children.splice(i2, 1, match.right);
                  newElementInserted = true;
                } else {
                  parent.children.splice(i2, 1);
                }
              }
              index.remove(match.left);
            }
          }
          if (!newElementInserted && match.right !== void 0 && match.rightParentId !== void 0) {
            const parent = index.getById(match.rightParentId);
            if (parent !== void 0) {
              if (parent.children === void 0)
                parent.children = [];
              parent.children.push(match.right);
            }
          }
        }
      }
      exports.applyMatches = applyMatches;
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/resize.js
  var require_resize = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/resize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ResizeAnimation = void 0;
      var animation_1 = require_animation();
      var ResizeAnimation = class extends animation_1.Animation {
        constructor(model, elementResizes, context, reverse = false) {
          super(context);
          this.model = model;
          this.elementResizes = elementResizes;
          this.reverse = reverse;
        }
        tween(t3) {
          this.elementResizes.forEach((elementResize) => {
            const element = elementResize.element;
            const newDimension = this.reverse ? {
              width: (1 - t3) * elementResize.toDimension.width + t3 * elementResize.fromDimension.width,
              height: (1 - t3) * elementResize.toDimension.height + t3 * elementResize.fromDimension.height
            } : {
              width: (1 - t3) * elementResize.fromDimension.width + t3 * elementResize.toDimension.width,
              height: (1 - t3) * elementResize.fromDimension.height + t3 * elementResize.toDimension.height
            };
            element.bounds = {
              x: element.bounds.x,
              y: element.bounds.y,
              width: newDimension.width,
              height: newDimension.height
            };
          });
          return this.model;
        }
      };
      exports.ResizeAnimation = ResizeAnimation;
    }
  });

  // ../../node_modules/sprotty/lib/features/update/update-model.js
  var require_update_model = __commonJS({
    "../../node_modules/sprotty/lib/features/update/update-model.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UpdateModelCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var animation_1 = require_animation();
      var command_1 = require_command();
      var fade_1 = require_fade();
      var smodel_1 = require_smodel();
      var move_1 = require_move();
      var model_1 = require_model3();
      var model_2 = require_model8();
      var model_3 = require_model2();
      var viewport_root_1 = require_viewport_root();
      var model_4 = require_model6();
      var model_matching_1 = require_model_matching();
      var resize_1 = require_resize();
      var types_1 = require_types();
      var model_5 = require_model12();
      var routing_1 = require_routing();
      var model_6 = require_model9();
      var smodel_utils_1 = require_smodel_utils();
      var UpdateModelCommand = class UpdateModelCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
        }
        execute(context) {
          let newRoot;
          if (this.action.newRoot !== void 0) {
            newRoot = context.modelFactory.createRoot(this.action.newRoot);
          } else {
            newRoot = context.modelFactory.createRoot(context.root);
            if (this.action.matches !== void 0)
              this.applyMatches(newRoot, this.action.matches, context);
          }
          this.oldRoot = context.root;
          this.newRoot = newRoot;
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
        performUpdate(oldRoot, newRoot, context) {
          if ((this.action.animate === void 0 || this.action.animate) && oldRoot.id === newRoot.id) {
            let matchResult;
            if (this.action.matches === void 0) {
              const matcher = new model_matching_1.ModelMatcher();
              matchResult = matcher.match(oldRoot, newRoot);
            } else {
              matchResult = this.convertToMatchResult(this.action.matches, oldRoot, newRoot);
            }
            const animationOrRoot = this.computeAnimation(newRoot, matchResult, context);
            if (animationOrRoot instanceof animation_1.Animation)
              return animationOrRoot.start();
            else
              return animationOrRoot;
          } else {
            if (oldRoot.type === newRoot.type && geometry_1.Dimension.isValid(oldRoot.canvasBounds))
              newRoot.canvasBounds = oldRoot.canvasBounds;
            if ((0, model_5.isViewport)(oldRoot) && (0, model_5.isViewport)(newRoot)) {
              newRoot.zoom = oldRoot.zoom;
              newRoot.scroll = oldRoot.scroll;
            }
            return newRoot;
          }
        }
        applyMatches(root, matches, context) {
          const index = root.index;
          for (const match of matches) {
            if (match.left !== void 0) {
              const element = index.getById(match.left.id);
              if (element instanceof smodel_1.SChildElementImpl)
                element.parent.remove(element);
            }
          }
          for (const match of matches) {
            if (match.right !== void 0) {
              const element = context.modelFactory.createElement(match.right);
              let parent;
              if (match.rightParentId !== void 0)
                parent = index.getById(match.rightParentId);
              if (parent instanceof smodel_1.SParentElementImpl)
                parent.add(element);
              else
                root.add(element);
            }
          }
        }
        convertToMatchResult(matches, leftRoot, rightRoot) {
          const result = {};
          for (const match of matches) {
            const converted = {};
            let id = void 0;
            if (match.left !== void 0) {
              id = match.left.id;
              converted.left = leftRoot.index.getById(id);
              converted.leftParentId = match.leftParentId;
            }
            if (match.right !== void 0) {
              id = match.right.id;
              converted.right = rightRoot.index.getById(id);
              converted.rightParentId = match.rightParentId;
            }
            if (id !== void 0)
              result[id] = converted;
          }
          return result;
        }
        computeAnimation(newRoot, matchResult, context) {
          const animationData = {
            fades: []
          };
          (0, model_matching_1.forEachMatch)(matchResult, (id, match) => {
            if (match.left !== void 0 && match.right !== void 0) {
              this.updateElement(match.left, match.right, animationData);
            } else if (match.right !== void 0) {
              const right = match.right;
              if ((0, model_1.isFadeable)(right)) {
                right.opacity = 0;
                animationData.fades.push({
                  element: right,
                  type: "in"
                });
              }
            } else if (match.left instanceof smodel_1.SChildElementImpl) {
              const left = match.left;
              if ((0, model_1.isFadeable)(left) && match.leftParentId !== void 0) {
                if (!(0, smodel_utils_1.containsSome)(newRoot, left)) {
                  const parent = newRoot.index.getById(match.leftParentId);
                  if (parent instanceof smodel_1.SParentElementImpl) {
                    const leftCopy = context.modelFactory.createElement(left);
                    parent.add(leftCopy);
                    animationData.fades.push({
                      element: leftCopy,
                      type: "out"
                    });
                  }
                }
              }
            }
          });
          const animations = this.createAnimations(animationData, newRoot, context);
          if (animations.length >= 2) {
            return new animation_1.CompoundAnimation(newRoot, context, animations);
          } else if (animations.length === 1) {
            return animations[0];
          } else {
            return newRoot;
          }
        }
        updateElement(left, right, animationData) {
          if ((0, model_2.isLocateable)(left) && (0, model_2.isLocateable)(right)) {
            const leftPos = left.position;
            const rightPos = right.position;
            if (!(0, geometry_1.almostEquals)(leftPos.x, rightPos.x) || !(0, geometry_1.almostEquals)(leftPos.y, rightPos.y)) {
              if (animationData.moves === void 0)
                animationData.moves = [];
              animationData.moves.push({
                element: right,
                fromPosition: leftPos,
                toPosition: rightPos
              });
              right.position = leftPos;
            }
          }
          if ((0, model_3.isSizeable)(left) && (0, model_3.isSizeable)(right)) {
            if (!geometry_1.Dimension.isValid(right.bounds)) {
              right.bounds = {
                x: right.bounds.x,
                y: right.bounds.y,
                width: left.bounds.width,
                height: left.bounds.height
              };
            } else if (!(0, geometry_1.almostEquals)(left.bounds.width, right.bounds.width) || !(0, geometry_1.almostEquals)(left.bounds.height, right.bounds.height)) {
              if (animationData.resizes === void 0)
                animationData.resizes = [];
              animationData.resizes.push({
                element: right,
                fromDimension: {
                  width: left.bounds.width,
                  height: left.bounds.height
                },
                toDimension: {
                  width: right.bounds.width,
                  height: right.bounds.height
                }
              });
            }
          }
          if (left instanceof model_6.SRoutableElementImpl && right instanceof model_6.SRoutableElementImpl && this.edgeRouterRegistry) {
            if (animationData.edgeMementi === void 0)
              animationData.edgeMementi = [];
            animationData.edgeMementi.push({
              edge: right,
              before: this.takeSnapshot(left),
              after: this.takeSnapshot(right)
            });
          }
          if ((0, model_4.isSelectable)(left) && (0, model_4.isSelectable)(right)) {
            right.selected = left.selected;
          }
          if (left instanceof smodel_1.SModelRootImpl && right instanceof smodel_1.SModelRootImpl) {
            right.canvasBounds = left.canvasBounds;
          }
          if (left instanceof viewport_root_1.ViewportRootElementImpl && right instanceof viewport_root_1.ViewportRootElementImpl) {
            right.scroll = left.scroll;
            right.zoom = left.zoom;
          }
        }
        takeSnapshot(edge) {
          const router = this.edgeRouterRegistry.get(edge.routerKind);
          return router.takeSnapshot(edge);
        }
        createAnimations(data, root, context) {
          const animations = [];
          if (data.fades.length > 0) {
            animations.push(new fade_1.FadeAnimation(root, data.fades, context, true));
          }
          if (data.moves !== void 0 && data.moves.length > 0) {
            const movesMap = /* @__PURE__ */ new Map();
            for (const move of data.moves) {
              movesMap.set(move.element.id, move);
            }
            animations.push(new move_1.MoveAnimation(root, movesMap, context, false));
          }
          if (data.resizes !== void 0 && data.resizes.length > 0) {
            const resizesMap = /* @__PURE__ */ new Map();
            for (const resize of data.resizes) {
              resizesMap.set(resize.element.id, resize);
            }
            animations.push(new resize_1.ResizeAnimation(root, resizesMap, context, false));
          }
          if (data.edgeMementi !== void 0 && data.edgeMementi.length > 0) {
            animations.push(new move_1.MorphEdgesAnimation(root, data.edgeMementi, context, false));
          }
          return animations;
        }
        undo(context) {
          return this.performUpdate(this.newRoot, this.oldRoot, context);
        }
        redo(context) {
          return this.performUpdate(this.oldRoot, this.newRoot, context);
        }
      };
      exports.UpdateModelCommand = UpdateModelCommand;
      UpdateModelCommand.KIND = actions_1.UpdateModelAction.KIND;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        (0, inversify_1.optional)(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], UpdateModelCommand.prototype, "edgeRouterRegistry", void 0);
      exports.UpdateModelCommand = UpdateModelCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], UpdateModelCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/viewport.js
  var require_viewport = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/viewport.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      var SetViewportCommand_1;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ViewportAnimation = exports.GetViewportCommand = exports.SetViewportCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var command_1 = require_command();
      var animation_1 = require_animation();
      var model_1 = require_model12();
      var types_1 = require_types();
      var request_command_1 = require_request_command();
      var SetViewportCommand = SetViewportCommand_1 = class SetViewportCommand extends command_1.MergeableCommand {
        constructor(action) {
          super();
          this.action = action;
          this.newViewport = action.newViewport;
        }
        execute(context) {
          const model = context.root;
          const element = model.index.getById(this.action.elementId);
          if (element && (0, model_1.isViewport)(element)) {
            this.element = element;
            this.oldViewport = {
              scroll: this.element.scroll,
              zoom: this.element.zoom
            };
            const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
            this.newViewport = (0, model_1.limitViewport)(this.newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
            return this.setViewport(element, this.oldViewport, this.newViewport, context);
          }
          return context.root;
        }
        setViewport(element, oldViewport, newViewport, context) {
          if (element && (0, model_1.isViewport)(element)) {
            if (this.action.animate) {
              return new ViewportAnimation(element, oldViewport, newViewport, context).start();
            } else {
              element.scroll = newViewport.scroll;
              element.zoom = newViewport.zoom;
            }
          }
          return context.root;
        }
        undo(context) {
          return this.setViewport(this.element, this.newViewport, this.oldViewport, context);
        }
        redo(context) {
          return this.setViewport(this.element, this.oldViewport, this.newViewport, context);
        }
        merge(command, context) {
          if (!this.action.animate && command instanceof SetViewportCommand_1 && this.element === command.element) {
            this.newViewport = command.newViewport;
            return true;
          }
          return false;
        }
      };
      exports.SetViewportCommand = SetViewportCommand;
      SetViewportCommand.KIND = actions_1.SetViewportAction.KIND;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], SetViewportCommand.prototype, "viewerOptions", void 0);
      exports.SetViewportCommand = SetViewportCommand = SetViewportCommand_1 = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], SetViewportCommand);
      var GetViewportCommand = class GetViewportCommand extends request_command_1.ModelRequestCommand {
        constructor(action) {
          super();
          this.action = action;
        }
        retrieveResult(context) {
          const elem = context.root;
          let viewport;
          if ((0, model_1.isViewport)(elem)) {
            viewport = { scroll: elem.scroll, zoom: elem.zoom };
          } else {
            viewport = { scroll: geometry_1.Point.ORIGIN, zoom: 1 };
          }
          return actions_1.ViewportResult.create(viewport, elem.canvasBounds, this.action.requestId);
        }
      };
      exports.GetViewportCommand = GetViewportCommand;
      GetViewportCommand.KIND = actions_1.GetViewportAction.KIND;
      exports.GetViewportCommand = GetViewportCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], GetViewportCommand);
      var ViewportAnimation = class extends animation_1.Animation {
        constructor(element, oldViewport, newViewport, context) {
          super(context);
          this.element = element;
          this.oldViewport = oldViewport;
          this.newViewport = newViewport;
          this.context = context;
          this.zoomFactor = Math.log(newViewport.zoom / oldViewport.zoom);
        }
        tween(t3, context) {
          this.element.scroll = {
            x: (1 - t3) * this.oldViewport.scroll.x + t3 * this.newViewport.scroll.x,
            y: (1 - t3) * this.oldViewport.scroll.y + t3 * this.newViewport.scroll.y
          };
          this.element.zoom = this.oldViewport.zoom * Math.exp(t3 * this.zoomFactor);
          return context.root;
        }
      };
      exports.ViewportAnimation = ViewportAnimation;
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/center-fit.js
  var require_center_fit = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/center-fit.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CenterKeyboardListener = exports.FitToScreenCommand = exports.CenterCommand = exports.BoundsAwareViewportCommand = void 0;
      var actions_1 = require_actions();
      var geometry_1 = require_geometry();
      var keyboard_1 = require_keyboard();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var key_tool_1 = require_key_tool();
      var model_1 = require_model2();
      var model_2 = require_model6();
      var viewport_1 = require_viewport();
      var model_3 = require_model12();
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var BoundsAwareViewportCommand = class BoundsAwareViewportCommand extends command_1.Command {
        constructor(animate) {
          super();
          this.animate = animate;
        }
        initialize(model) {
          if (!(0, model_3.isViewport)(model)) {
            return;
          }
          this.oldViewport = {
            scroll: model.scroll,
            zoom: model.zoom
          };
          const allBounds = [];
          this.getElementIds().forEach((id) => {
            const element = model.index.getById(id);
            if (element && (0, model_1.isBoundsAware)(element)) {
              allBounds.push(this.boundsInViewport(element, element.bounds, model));
            }
          });
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_2.isSelectable)(element) && element.selected && (0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length === 0) {
            model.index.all().forEach((element) => {
              if ((0, model_1.isBoundsAware)(element)) {
                allBounds.push(this.boundsInViewport(element, element.bounds, model));
              }
            });
          }
          if (allBounds.length !== 0) {
            const bounds = allBounds.reduce((b0, b1) => geometry_1.Bounds.combine(b0, b1));
            if (geometry_1.Dimension.isValid(bounds)) {
              const newViewport = this.getNewViewport(bounds, model);
              if (newViewport) {
                const { zoomLimits, horizontalScrollLimits, verticalScrollLimits } = this.viewerOptions;
                this.newViewport = (0, model_3.limitViewport)(newViewport, model.canvasBounds, horizontalScrollLimits, verticalScrollLimits, zoomLimits);
              }
            }
          }
        }
        boundsInViewport(element, bounds, viewport) {
          if (element instanceof smodel_1.SChildElementImpl && element.parent !== viewport)
            return this.boundsInViewport(element.parent, element.parent.localToParent(bounds), viewport);
          else
            return bounds;
        }
        execute(context) {
          this.initialize(context.root);
          return this.redo(context);
        }
        undo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate)
              return new viewport_1.ViewportAnimation(model, this.newViewport, this.oldViewport, context).start();
            else {
              model.scroll = this.oldViewport.scroll;
              model.zoom = this.oldViewport.zoom;
            }
          }
          return model;
        }
        redo(context) {
          const model = context.root;
          if ((0, model_3.isViewport)(model) && this.newViewport !== void 0 && !this.equal(this.newViewport, this.oldViewport)) {
            if (this.animate) {
              return new viewport_1.ViewportAnimation(model, this.oldViewport, this.newViewport, context).start();
            } else {
              model.scroll = this.newViewport.scroll;
              model.zoom = this.newViewport.zoom;
            }
          }
          return model;
        }
        equal(vp1, vp2) {
          return (0, geometry_1.almostEquals)(vp1.zoom, vp2.zoom) && (0, geometry_1.almostEquals)(vp1.scroll.x, vp2.scroll.x) && (0, geometry_1.almostEquals)(vp1.scroll.y, vp2.scroll.y);
        }
      };
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], BoundsAwareViewportCommand.prototype, "viewerOptions", void 0);
      exports.BoundsAwareViewportCommand = BoundsAwareViewportCommand = __decorate([
        (0, inversify_1.injectable)(),
        __metadata("design:paramtypes", [Boolean])
      ], BoundsAwareViewportCommand);
      var CenterCommand = class CenterCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          let zoom = 1;
          if (this.action.retainZoom && (0, model_3.isViewport)(model)) {
            zoom = model.zoom;
          } else if (this.action.zoomScale) {
            zoom = this.action.zoomScale;
          }
          const c3 = geometry_1.Bounds.center(bounds);
          return {
            scroll: {
              x: c3.x - 0.5 * model.canvasBounds.width / zoom,
              y: c3.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.CenterCommand = CenterCommand;
      CenterCommand.KIND = actions_1.CenterAction.KIND;
      exports.CenterCommand = CenterCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], CenterCommand);
      var FitToScreenCommand = class FitToScreenCommand extends BoundsAwareViewportCommand {
        constructor(action) {
          super(action.animate);
          this.action = action;
        }
        getElementIds() {
          return this.action.elementIds;
        }
        getNewViewport(bounds, model) {
          if (!geometry_1.Dimension.isValid(model.canvasBounds)) {
            return void 0;
          }
          const c3 = geometry_1.Bounds.center(bounds);
          const delta = this.action.padding === void 0 ? 0 : 2 * this.action.padding;
          let zoom = Math.min(model.canvasBounds.width / (bounds.width + delta), model.canvasBounds.height / (bounds.height + delta));
          if (this.action.maxZoom !== void 0)
            zoom = Math.min(zoom, this.action.maxZoom);
          if (zoom === Infinity) {
            zoom = 1;
          }
          return {
            scroll: {
              x: c3.x - 0.5 * model.canvasBounds.width / zoom,
              y: c3.y - 0.5 * model.canvasBounds.height / zoom
            },
            zoom
          };
        }
      };
      exports.FitToScreenCommand = FitToScreenCommand;
      FitToScreenCommand.KIND = actions_1.FitToScreenAction.KIND;
      exports.FitToScreenCommand = FitToScreenCommand = __decorate([
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], FitToScreenCommand);
      var CenterKeyboardListener = class extends key_tool_1.KeyListener {
        keyDown(element, event) {
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyC", "ctrlCmd", "shift"))
            return [actions_1.CenterAction.create([])];
          if ((0, keyboard_1.matchesKeystroke)(event, "KeyF", "ctrlCmd", "shift"))
            return [actions_1.FitToScreenAction.create([])];
          return [];
        }
      };
      exports.CenterKeyboardListener = CenterKeyboardListener;
    }
  });

  // ../../node_modules/sprotty/lib/features/zorder/zorder.js
  var require_zorder = __commonJS({
    "../../node_modules/sprotty/lib/features/zorder/zorder.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      var __param = exports && exports.__param || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BringToFrontCommand = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var types_1 = require_types();
      var smodel_1 = require_smodel();
      var command_1 = require_command();
      var model_1 = require_model9();
      var BringToFrontCommand = class BringToFrontCommand extends command_1.Command {
        constructor(action) {
          super();
          this.action = action;
          this.selected = [];
        }
        execute(context) {
          const model = context.root;
          this.action.elementIDs.forEach((id) => {
            const element = model.index.getById(id);
            if (element instanceof model_1.SRoutableElementImpl) {
              if (element.source)
                this.addToSelection(element.source);
              if (element.target)
                this.addToSelection(element.target);
            }
            if (element instanceof smodel_1.SChildElementImpl) {
              this.addToSelection(element);
            }
            this.includeConnectedEdges(element);
          });
          return this.redo(context);
        }
        includeConnectedEdges(element) {
          if (element instanceof model_1.SConnectableElementImpl) {
            element.incomingEdges.forEach((edge) => this.addToSelection(edge));
            element.outgoingEdges.forEach((edge) => this.addToSelection(edge));
          }
          if (element instanceof smodel_1.SParentElementImpl) {
            for (const child of element.children) {
              this.includeConnectedEdges(child);
            }
          }
        }
        addToSelection(element) {
          this.selected.push({
            element,
            index: element.parent.children.indexOf(element)
          });
        }
        undo(context) {
          for (let i2 = this.selected.length - 1; i2 >= 0; i2--) {
            const selection = this.selected[i2];
            const element = selection.element;
            element.parent.move(element, selection.index);
          }
          return context.root;
        }
        redo(context) {
          for (let i2 = 0; i2 < this.selected.length; i2++) {
            this.bringToFront(this.selected[i2]);
          }
          return context.root;
        }
        bringToFront(selection) {
          const element = selection.element;
          const childrenLength = element.parent.children.length;
          element.parent.move(element, childrenLength - 1);
        }
      };
      exports.BringToFrontCommand = BringToFrontCommand;
      BringToFrontCommand.KIND = actions_1.BringToFrontAction.KIND;
      exports.BringToFrontCommand = BringToFrontCommand = __decorate([
        (0, inversify_1.injectable)(),
        __param(0, (0, inversify_1.inject)(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [Object])
      ], BringToFrontCommand);
    }
  });

  // ../../node_modules/sprotty/lib/features/bounds/di.config.js
  var require_di_config4 = __commonJS({
    "../../node_modules/sprotty/lib/features/bounds/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var hidden_bounds_updater_1 = require_hidden_bounds_updater();
      var layout_1 = require_layout();
      var command_registration_1 = require_command_registration();
      var hbox_layout_1 = require_hbox_layout();
      var vbox_layout_1 = require_vbox_layout();
      var stack_layout_1 = require_stack_layout();
      var boundsModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.SetBoundsCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bounds_manipulation_1.RequestBoundsCommand);
        bind(hidden_bounds_updater_1.HiddenBoundsUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(hidden_bounds_updater_1.HiddenBoundsUpdater);
        bind(types_1.TYPES.Layouter).to(layout_1.Layouter).inSingletonScope();
        bind(types_1.TYPES.LayoutRegistry).to(layout_1.LayoutRegistry).inSingletonScope();
        (0, layout_1.configureLayout)({ bind, isBound }, vbox_layout_1.VBoxLayouter.KIND, vbox_layout_1.VBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, hbox_layout_1.HBoxLayouter.KIND, hbox_layout_1.HBoxLayouter);
        (0, layout_1.configureLayout)({ bind, isBound }, stack_layout_1.StackLayouter.KIND, stack_layout_1.StackLayouter);
      });
      exports.default = boundsModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/button/di.config.js
  var require_di_config5 = __commonJS({
    "../../node_modules/sprotty/lib/features/button/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var button_handler_1 = require_button_handler();
      var buttonModule = new inversify_1.ContainerModule((bind) => {
        bind(button_handler_1.ButtonHandlerRegistry).toSelf().inSingletonScope();
      });
      exports.default = buttonModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/command-palette/di.config.js
  var require_di_config6 = __commonJS({
    "../../node_modules/sprotty/lib/features/command-palette/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var action_providers_1 = require_action_providers();
      var command_palette_1 = require_command_palette();
      var commandPaletteModule = new inversify_1.ContainerModule((bind) => {
        bind(command_palette_1.CommandPalette).toSelf().inSingletonScope();
        bind(types_1.TYPES.IUIExtension).toService(command_palette_1.CommandPalette);
        bind(command_palette_1.CommandPaletteKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(command_palette_1.CommandPaletteKeyListener);
        bind(action_providers_1.CommandPaletteActionProviderRegistry).toSelf().inSingletonScope();
        bind(types_1.TYPES.ICommandPaletteActionProviderRegistry).toService(action_providers_1.CommandPaletteActionProviderRegistry);
      });
      exports.default = commandPaletteModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/context-menu/di.config.js
  var require_di_config7 = __commonJS({
    "../../node_modules/sprotty/lib/features/context-menu/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var menu_providers_1 = require_menu_providers();
      var mouse_listener_1 = require_mouse_listener();
      var types_1 = require_types();
      var contextMenuModule = new inversify_1.ContainerModule((bind) => {
        bind(types_1.TYPES.IContextMenuServiceProvider).toProvider((ctx) => {
          return () => {
            return new Promise((resolve, reject) => {
              if (ctx.container.isBound(types_1.TYPES.IContextMenuService)) {
                resolve(ctx.container.get(types_1.TYPES.IContextMenuService));
              } else {
                reject();
              }
            });
          };
        });
        bind(mouse_listener_1.ContextMenuMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(mouse_listener_1.ContextMenuMouseListener);
        bind(types_1.TYPES.IContextMenuProviderRegistry).to(menu_providers_1.ContextMenuProviderRegistry);
      });
      exports.default = contextMenuModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/decoration/di.config.js
  var require_di_config8 = __commonJS({
    "../../node_modules/sprotty/lib/features/decoration/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view_1 = require_view();
      var inversify_1 = require_cjs4();
      var model_1 = require_model15();
      var views_1 = require_views3();
      var types_1 = require_types();
      var decoration_placer_1 = require_decoration_placer();
      var decorationModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, view_1.configureModelElement)({ bind, isBound }, "marker", model_1.SIssueMarkerImpl, views_1.IssueMarkerView);
        bind(decoration_placer_1.DecorationPlacer).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(decoration_placer_1.DecorationPlacer);
      });
      exports.default = decorationModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-intersection/di.config.js
  var require_di_config9 = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-intersection/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var intersection_finder_1 = require_intersection_finder();
      var edgeIntersectionModule = new inversify_1.ContainerModule((bind) => {
        bind(intersection_finder_1.IntersectionFinder).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRoutePostprocessor).toService(intersection_finder_1.IntersectionFinder);
      });
      exports.default = edgeIntersectionModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/edge-junction/di.config.js
  var require_di_config10 = __commonJS({
    "../../node_modules/sprotty/lib/features/edge-junction/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var junction_finder_1 = require_junction_finder();
      var junction_postprocessor_1 = require_junction_postprocessor();
      var edgeJunctionModule = new inversify_1.ContainerModule((bind) => {
        bind(junction_finder_1.JunctionFinder).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRoutePostprocessor).toService(junction_finder_1.JunctionFinder);
        bind(junction_postprocessor_1.JunctionPostProcessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(junction_postprocessor_1.JunctionPostProcessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(junction_postprocessor_1.JunctionPostProcessor);
      });
      exports.default = edgeJunctionModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/expand/di.config.js
  var require_di_config11 = __commonJS({
    "../../node_modules/sprotty/lib/features/expand/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var button_handler_1 = require_button_handler();
      var expand_1 = require_expand();
      var expandModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, button_handler_1.configureButtonHandler)({ bind, isBound }, expand_1.ExpandButtonHandler.TYPE, expand_1.ExpandButtonHandler);
      });
      exports.default = expandModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/export/di.config.js
  var require_di_config12 = __commonJS({
    "../../node_modules/sprotty/lib/features/export/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var export_1 = require_export();
      var svg_exporter_1 = require_svg_exporter();
      var command_registration_1 = require_command_registration();
      var exportSvgModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(export_1.ExportSvgKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(export_1.ExportSvgKeyListener);
        bind(export_1.ExportSvgPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(export_1.ExportSvgPostprocessor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, export_1.ExportSvgCommand);
        bind(types_1.TYPES.SvgExporter).to(svg_exporter_1.SvgExporter).inSingletonScope();
      });
      exports.default = exportSvgModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/fade/di.config.js
  var require_di_config13 = __commonJS({
    "../../node_modules/sprotty/lib/features/fade/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var fade_1 = require_fade();
      var fadeModule = new inversify_1.ContainerModule((bind) => {
        bind(fade_1.ElementFader).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(fade_1.ElementFader);
      });
      exports.default = fadeModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/hover/popup-position-updater.js
  var require_popup_position_updater = __commonJS({
    "../../node_modules/sprotty/lib/features/hover/popup-position-updater.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PopupPositionUpdater = void 0;
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var PopupPositionUpdater = class PopupPositionUpdater {
        decorate(vnode, element) {
          return vnode;
        }
        postUpdate() {
          const popupDiv = document.getElementById(this.options.popupDiv);
          if (popupDiv !== null && typeof window !== "undefined") {
            const boundingClientRect = popupDiv.getBoundingClientRect();
            if (window.innerHeight < boundingClientRect.height + boundingClientRect.top) {
              popupDiv.style.top = window.pageYOffset + window.innerHeight - boundingClientRect.height - 5 + "px";
            }
            if (window.innerWidth < boundingClientRect.left + boundingClientRect.width) {
              popupDiv.style.left = window.pageXOffset + window.innerWidth - boundingClientRect.width - 5 + "px";
            }
            if (boundingClientRect.left < 0) {
              popupDiv.style.left = "0px";
            }
            if (boundingClientRect.top < 0) {
              popupDiv.style.top = "0px";
            }
          }
        }
      };
      exports.PopupPositionUpdater = PopupPositionUpdater;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
      ], PopupPositionUpdater.prototype, "options", void 0);
      exports.PopupPositionUpdater = PopupPositionUpdater = __decorate([
        (0, inversify_1.injectable)()
      ], PopupPositionUpdater);
    }
  });

  // ../../node_modules/sprotty/lib/features/hover/di.config.js
  var require_di_config14 = __commonJS({
    "../../node_modules/sprotty/lib/features/hover/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var hover_1 = require_hover();
      var popup_position_updater_1 = require_popup_position_updater();
      var command_registration_1 = require_command_registration();
      var action_handler_1 = require_action_handler();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var move_1 = require_move();
      var hoverModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(popup_position_updater_1.PopupPositionUpdater).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupVNodePostprocessor).toService(popup_position_updater_1.PopupPositionUpdater);
        bind(hover_1.HoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(hover_1.HoverMouseListener);
        bind(hover_1.PopupHoverMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.PopupMouseListener).toService(hover_1.PopupHoverMouseListener);
        bind(hover_1.HoverKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(hover_1.HoverKeyListener);
        bind(types_1.TYPES.HoverState).toConstantValue({
          mouseOverTimer: void 0,
          mouseOutTimer: void 0,
          popupOpen: false,
          previousPopupElement: void 0
        });
        bind(hover_1.ClosePopupActionHandler).toSelf().inSingletonScope();
        const context = { bind, isBound };
        (0, command_registration_1.configureCommand)(context, hover_1.HoverFeedbackCommand);
        (0, command_registration_1.configureCommand)(context, hover_1.SetPopupModelCommand);
        (0, action_handler_1.configureActionHandler)(context, hover_1.SetPopupModelCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.FitToScreenCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, center_fit_1.CenterCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, viewport_1.SetViewportCommand.KIND, hover_1.ClosePopupActionHandler);
        (0, action_handler_1.configureActionHandler)(context, move_1.MoveCommand.KIND, hover_1.ClosePopupActionHandler);
      });
      exports.default = hoverModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/move/di.config.js
  var require_di_config15 = __commonJS({
    "../../node_modules/sprotty/lib/features/move/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var move_1 = require_move();
      var command_registration_1 = require_command_registration();
      var moveModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(move_1.MoveMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(move_1.MoveMouseListener);
        (0, command_registration_1.configureCommand)({ bind, isBound }, move_1.MoveCommand);
        bind(move_1.LocationPostprocessor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IVNodePostprocessor).toService(move_1.LocationPostprocessor);
        bind(types_1.TYPES.HiddenVNodePostprocessor).toService(move_1.LocationPostprocessor);
      });
      exports.default = moveModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/open/di.config.js
  var require_di_config16 = __commonJS({
    "../../node_modules/sprotty/lib/features/open/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var open_1 = require_open();
      var openModule = new inversify_1.ContainerModule((bind) => {
        bind(open_1.OpenMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(open_1.OpenMouseListener);
      });
      exports.default = openModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/routing/di.config.js
  var require_di_config17 = __commonJS({
    "../../node_modules/sprotty/lib/features/routing/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var manhattan_edge_router_1 = require_manhattan_edge_router();
      var polyline_edge_router_1 = require_polyline_edge_router();
      var manhattan_anchors_1 = require_manhattan_anchors();
      var polyline_anchors_1 = require_polyline_anchors();
      var anchor_1 = require_anchor();
      var routing_1 = require_routing();
      var bezier_edge_router_1 = require_bezier_edge_router();
      var bezier_anchors_1 = require_bezier_anchors();
      var command_registration_1 = require_command_registration();
      var routingModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(routing_1.EdgeRouterRegistry).toSelf().inSingletonScope();
        bind(anchor_1.AnchorComputerRegistry).toSelf().inSingletonScope();
        bind(manhattan_edge_router_1.ManhattanEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(manhattan_edge_router_1.ManhattanEdgeRouter);
        bind(manhattan_anchors_1.ManhattanEllipticAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanEllipticAnchor);
        bind(manhattan_anchors_1.ManhattanRectangularAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanRectangularAnchor);
        bind(manhattan_anchors_1.ManhattanDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(manhattan_anchors_1.ManhattanDiamondAnchor);
        bind(polyline_edge_router_1.PolylineEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(polyline_edge_router_1.PolylineEdgeRouter);
        bind(polyline_anchors_1.EllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.EllipseAnchor);
        bind(polyline_anchors_1.RectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.RectangleAnchor);
        bind(polyline_anchors_1.DiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(polyline_anchors_1.DiamondAnchor);
        bind(bezier_edge_router_1.BezierEdgeRouter).toSelf().inSingletonScope();
        bind(types_1.TYPES.IEdgeRouter).toService(bezier_edge_router_1.BezierEdgeRouter);
        bind(bezier_anchors_1.BezierEllipseAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierEllipseAnchor);
        bind(bezier_anchors_1.BezierRectangleAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierRectangleAnchor);
        bind(bezier_anchors_1.BezierDiamondAnchor).toSelf().inSingletonScope();
        bind(types_1.TYPES.IAnchorComputer).toService(bezier_anchors_1.BezierDiamondAnchor);
        (0, command_registration_1.configureCommand)({ bind, isBound }, bezier_edge_router_1.AddRemoveBezierSegmentCommand);
      });
      exports.default = routingModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/select/di.config.js
  var require_di_config18 = __commonJS({
    "../../node_modules/sprotty/lib/features/select/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var select_1 = require_select();
      var command_registration_1 = require_command_registration();
      var selectModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.SelectAllCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, select_1.GetSelectionCommand);
        bind(select_1.SelectKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(select_1.SelectKeyboardListener);
        bind(select_1.SelectMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(select_1.SelectMouseListener);
      });
      exports.default = selectModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/undo-redo/di.config.js
  var require_di_config19 = __commonJS({
    "../../node_modules/sprotty/lib/features/undo-redo/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var undo_redo_1 = require_undo_redo();
      var undoRedoModule = new inversify_1.ContainerModule((bind) => {
        bind(undo_redo_1.UndoRedoKeyListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(undo_redo_1.UndoRedoKeyListener);
      });
      exports.default = undoRedoModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/update/di.config.js
  var require_di_config20 = __commonJS({
    "../../node_modules/sprotty/lib/features/update/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var update_model_1 = require_update_model();
      var updateModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, update_model_1.UpdateModelCommand);
      });
      exports.default = updateModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/viewport/di.config.js
  var require_di_config21 = __commonJS({
    "../../node_modules/sprotty/lib/features/viewport/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var types_1 = require_types();
      var center_fit_1 = require_center_fit();
      var viewport_1 = require_viewport();
      var scroll_1 = require_scroll();
      var zoom_1 = require_zoom();
      var command_registration_1 = require_command_registration();
      var viewportModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.CenterCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, center_fit_1.FitToScreenCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.SetViewportCommand);
        (0, command_registration_1.configureCommand)({ bind, isBound }, viewport_1.GetViewportCommand);
        bind(center_fit_1.CenterKeyboardListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.KeyListener).toService(center_fit_1.CenterKeyboardListener);
        bind(scroll_1.ScrollMouseListener).toSelf().inSingletonScope();
        bind(zoom_1.ZoomMouseListener).toSelf().inSingletonScope();
        bind(types_1.TYPES.MouseListener).toService(scroll_1.ScrollMouseListener);
        bind(types_1.TYPES.MouseListener).toService(zoom_1.ZoomMouseListener);
      });
      exports.default = viewportModule;
    }
  });

  // ../../node_modules/sprotty/lib/features/zorder/di.config.js
  var require_di_config22 = __commonJS({
    "../../node_modules/sprotty/lib/features/zorder/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var zorder_1 = require_zorder();
      var zorderModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        (0, command_registration_1.configureCommand)({ bind, isBound }, zorder_1.BringToFrontCommand);
      });
      exports.default = zorderModule;
    }
  });

  // ../../node_modules/sprotty/lib/graph/views.js
  var require_views6 = __commonJS({
    "../../node_modules/sprotty/lib/graph/views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SBezierControlHandleView = exports.SBezierCreateHandleView = exports.SCompartmentView = exports.SLabelView = exports.SRoutingHandleView = exports.BezierCurveEdgeView = exports.PolylineEdgeViewWithGapsOnIntersections = exports.JumpingPolylineEdgeView = exports.PolylineEdgeView = exports.SGraphView = void 0;
      var inversify_1 = require_cjs4();
      var geometry_1 = require_geometry();
      var model_utils_1 = require_model_utils();
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var intersection_finder_1 = require_intersection_finder();
      var model_1 = require_model10();
      var model_2 = require_model9();
      var routing_1 = require_routing();
      var views_2 = require_views5();
      var jsx_1 = require_jsx();
      var geometry_2 = require_geometry2();
      var SGraphView2 = class SGraphView {
        render(model, context) {
          const edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
          const transform = `scale(${model.zoom}) translate(${-model.scroll.x},${-model.scroll.y})`;
          return (0, jsx_1.svg)(
            "svg",
            { "class-sprotty-graph": true },
            (0, jsx_1.svg)("g", { transform }, context.renderChildren(model, { edgeRouting }))
          );
        }
      };
      exports.SGraphView = SGraphView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SGraphView2.prototype, "edgeRouterRegistry", void 0);
      exports.SGraphView = SGraphView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SGraphView2);
      var PolylineEdgeView2 = class PolylineEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            this.renderJunctionPoints(edge, route, context, args),
            context.renderChildren(edge, { route })
          );
        }
        renderJunctionPoints(edge, route, context, args) {
          const radius = 5;
          const junctionPoints = [];
          for (let i2 = 1; i2 < route.length; i2++) {
            if (route[i2].isJunction) {
              junctionPoints.push((0, jsx_1.svg)("circle", { cx: route[i2].x, cy: route[i2].y, r: radius }));
            }
          }
          if (junctionPoints.length > 0) {
            return (0, jsx_1.svg)("g", { "class-sprotty-junction": true }, junctionPoints);
          }
          return void 0;
        }
        renderLine(edge, segments, context, args) {
          const firstPoint = segments[0];
          let path = `M ${firstPoint.x},${firstPoint.y}`;
          for (let i2 = 1; i2 < segments.length; i2++) {
            const p3 = segments[i2];
            path += ` L ${p3.x},${p3.y}`;
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.PolylineEdgeView = PolylineEdgeView2;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], PolylineEdgeView2.prototype, "edgeRouterRegistry", void 0);
      exports.PolylineEdgeView = PolylineEdgeView2 = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeView2);
      var JumpingPolylineEdgeView = class JumpingPolylineEdgeView extends PolylineEdgeView2 {
        constructor() {
          super(...arguments);
          this.jumpOffsetBefore = 5;
          this.jumpOffsetAfter = 5;
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 2;
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          for (let i2 = 0; i2 < segments.length; i2++) {
            const p3 = segments[i2];
            if (i2 === 0) {
              path = `M ${p3.x},${p3.y}`;
            }
            if ((0, intersection_finder_1.isIntersectingRoutedPoint)(p3)) {
              path += this.intersectionPath(edge, segments, p3, args);
            }
            if (i2 !== 0) {
              path += ` L ${p3.x},${p3.y}`;
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        /**
         * Returns a path that takes the intersections into account by drawing a line jump or a gap for intersections on that path.
         */
        intersectionPath(edge, segments, intersectingPoint, args) {
          if (intersectingPoint.intersections.length < 1) {
            return "";
          }
          const segment = this.getLineSegment(edge, intersectingPoint.intersections[0], args, segments);
          const intersections = this.getIntersectionsSortedBySegmentDirection(segment, intersectingPoint);
          let path = "";
          for (const intersection of intersections) {
            const otherLineSegment = this.getOtherLineSegment(edge, intersection, args);
            if (otherLineSegment === void 0) {
              continue;
            }
            const currentLineSegment = this.getLineSegment(edge, intersection, args, segments);
            const intersectionPoint = intersection.intersectionPoint;
            if (this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createJumpPath(intersectionPoint, currentLineSegment);
            } else if (this.shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment)) {
              path += this.createGapPath(intersectionPoint, currentLineSegment);
            }
          }
          return path;
        }
        /**
         * Returns the intersections sorted by the direction of the `lineSegment`.
         *
         * The coordinate system goes from left to right and top to bottom.
         * Thus, x increases to the right and y increases downwards.
         *
         * We need to draw the intersections in the order of the direction of the line segment.
         * To draw a line pointing north, we need to order intersections by Y in a descending order.
         * To draw a line pointing south, we need to order intersections by Y in an ascending order.
         */
        getIntersectionsSortedBySegmentDirection(lineSegment, intersectingPoint) {
          switch (lineSegment.direction) {
            case "north":
            case "north-east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_DESCENDING_Y);
            case "south":
            case "south-east":
            case "east":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_Y);
            case "south-west":
            case "west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_Y);
            case "north-west":
              return intersectingPoint.intersections.sort(intersection_finder_1.BY_DESCENDING_X_THEN_DESCENDING_Y);
          }
        }
        /**
         * Whether or not to draw a line jump on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineGapOnIntersection()`.
         */
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) < Math.abs(otherLineSegment.slopeOrMax);
        }
        /**
         * Whether or not to draw a line gap on an intersection for the `currentLineSegment`.
         * This should usually be inverse of `shouldDrawLineJumpOnIntersection()`.
         */
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return !this.shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment);
        }
        getLineSegment(edge, intersection, args, segments) {
          const route = segments ? segments : this.edgeRouterRegistry.route(edge, args);
          const index = intersection.routable1 === edge.id ? intersection.segmentIndex1 : intersection.segmentIndex2;
          return new geometry_2.PointToPointLine(route[index], route[index + 1]);
        }
        getOtherLineSegment(currentEdge, intersection, args) {
          const otherEdgeId = intersection.routable1 === currentEdge.id ? intersection.routable2 : intersection.routable1;
          const otherEdge = currentEdge.index.getById(otherEdgeId);
          if (!(otherEdge instanceof model_2.SRoutableElementImpl)) {
            return void 0;
          }
          return this.getLineSegment(otherEdge, intersection, args);
        }
        createJumpPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.jumpOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.jumpOffsetAfter);
          const rotation = lineSegment.p1.x < lineSegment.p2.x ? 1 : 0;
          return ` L ${anchorBefore.x},${anchorBefore.y} A 1,1 0,0 ${rotation} ${anchorAfter.x},${anchorAfter.y}`;
        }
        createGapPath(intersectionPoint, lineSegment) {
          let offsetBefore;
          let offsetAfter;
          if (intersectionPoint.y < lineSegment.p1.y) {
            offsetBefore = -this.skipOffsetBefore;
            offsetAfter = this.jumpOffsetAfter + this.skipOffsetAfter;
          } else {
            offsetBefore = this.jumpOffsetBefore + this.skipOffsetAfter;
            offsetAfter = -this.skipOffsetBefore;
          }
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, offsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, offsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView;
      exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], JumpingPolylineEdgeView);
      var PolylineEdgeViewWithGapsOnIntersections = class PolylineEdgeViewWithGapsOnIntersections extends JumpingPolylineEdgeView {
        constructor() {
          super(...arguments);
          this.skipOffsetBefore = 3;
          this.skipOffsetAfter = 3;
        }
        shouldDrawLineJumpOnIntersection(currentLineSegment, otherLineSegment) {
          return false;
        }
        shouldDrawLineGapOnIntersection(currentLineSegment, otherLineSegment) {
          return Math.abs(currentLineSegment.slopeOrMax) >= Math.abs(otherLineSegment.slopeOrMax);
        }
        createGapPath(intersectionPoint, lineSegment) {
          const anchorBefore = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p1, this.skipOffsetBefore);
          const anchorAfter = geometry_1.Point.shiftTowards(intersectionPoint, lineSegment.p2, this.skipOffsetAfter);
          return ` L ${anchorBefore.x},${anchorBefore.y} M ${anchorAfter.x},${anchorAfter.y}`;
        }
      };
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections;
      exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections = __decorate([
        (0, inversify_1.injectable)()
      ], PolylineEdgeViewWithGapsOnIntersections);
      var BezierCurveEdgeView = class BezierCurveEdgeView extends views_2.RoutableView {
        render(edge, context, args) {
          const route = this.edgeRouterRegistry.route(edge, args);
          if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
          }
          if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
              return void 0;
            }
            return (0, jsx_1.svg)("g", null, context.renderChildren(edge, { route }));
          }
          return (0, jsx_1.svg)(
            "g",
            { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route })
          );
        }
        renderLine(edge, segments, context, args) {
          let path = "";
          if (segments.length >= 4) {
            path += this.buildMainSegment(segments);
            const pointsLeft = segments.length - 4;
            if (pointsLeft > 0 && pointsLeft % 3 === 0) {
              for (let i2 = 4; i2 < segments.length; i2 += 3) {
                path += this.addSpline(segments, i2);
              }
            }
          }
          return (0, jsx_1.svg)("path", { d: path });
        }
        buildMainSegment(segments) {
          const s3 = segments[0];
          const h1 = segments[1];
          const h22 = segments[2];
          const t3 = segments[3];
          return `M${s3.x},${s3.y} C${h1.x},${h1.y} ${h22.x},${h22.y} ${t3.x},${t3.y}`;
        }
        addSpline(segments, index) {
          const c3 = segments[index + 1];
          const p3 = segments[index + 2];
          return ` S${c3.x},${c3.y} ${p3.x},${p3.y}`;
        }
        renderAdditionals(edge, segments, context) {
          return [];
        }
        renderDanglingEdge(message, edge, context) {
          return (0, jsx_1.svg)("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
        }
      };
      exports.BezierCurveEdgeView = BezierCurveEdgeView;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], BezierCurveEdgeView.prototype, "edgeRouterRegistry", void 0);
      exports.BezierCurveEdgeView = BezierCurveEdgeView = __decorate([
        (0, inversify_1.injectable)()
      ], BezierCurveEdgeView);
      var SRoutingHandleView = class SRoutingHandleView {
        constructor() {
          this.minimalPointDistance = 10;
        }
        render(handle, context, args) {
          if (args && args.route) {
            if (handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const theRoute = args.route === void 0 ? this.edgeRouterRegistry.route(handle.parent, args) : args.route;
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
        getRadius() {
          return 7;
        }
      };
      exports.SRoutingHandleView = SRoutingHandleView;
      __decorate([
        (0, inversify_1.inject)(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
      ], SRoutingHandleView.prototype, "edgeRouterRegistry", void 0);
      exports.SRoutingHandleView = SRoutingHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SRoutingHandleView);
      var SLabelView2 = class SLabelView extends views_1.ShapeView {
        render(label, context) {
          if (!(0, model_1.isEdgeLayoutable)(label) && !this.isVisible(label, context)) {
            return void 0;
          }
          const vnode = (0, jsx_1.svg)("text", { "class-sprotty-label": true }, label.text);
          const subType = (0, model_utils_1.getSubType)(label);
          if (subType) {
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          }
          return vnode;
        }
      };
      exports.SLabelView = SLabelView2;
      exports.SLabelView = SLabelView2 = __decorate([
        (0, inversify_1.injectable)()
      ], SLabelView2);
      var SCompartmentView = class SCompartmentView {
        render(compartment, context, args) {
          const translate = `translate(${compartment.bounds.x}, ${compartment.bounds.y})`;
          const vnode = (0, jsx_1.svg)("g", { transform: translate, "class-sprotty-comp": "{true}" }, context.renderChildren(compartment));
          const subType = (0, model_utils_1.getSubType)(compartment);
          if (subType)
            (0, vnode_utils_1.setAttr)(vnode, "class", subType);
          return vnode;
        }
      };
      exports.SCompartmentView = SCompartmentView;
      exports.SCompartmentView = SCompartmentView = __decorate([
        (0, inversify_1.injectable)()
      ], SCompartmentView);
      var SBezierCreateHandleView = class SBezierCreateHandleView extends SRoutingHandleView {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                const translation = "translate(" + position.x + ", " + position.y + ")";
                const textOffsetX = -5.5;
                const textOffsetY = 5.5;
                const text = handle.kind === "bezier-add" ? "+" : "-";
                const node = (0, jsx_1.svg)(
                  "g",
                  { transform: translation, "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                  (0, jsx_1.svg)("circle", { r: this.getRadius() }),
                  (0, jsx_1.svg)("text", { x: textOffsetX, y: textOffsetY, "attrs-text-align": "middle", "style-font-family": "monospace", "style-pointer-events": "none", "style-fill": "white" }, text)
                );
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierCreateHandleView = SBezierCreateHandleView;
      exports.SBezierCreateHandleView = SBezierCreateHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierCreateHandleView);
      var SBezierControlHandleView = class SBezierControlHandleView extends SRoutingHandleView {
        render(handle, context, args) {
          if (args) {
            const theRoute = args.route;
            if (theRoute && handle.parent instanceof model_2.SRoutableElementImpl) {
              const router = this.edgeRouterRegistry.get(handle.parent.routerKind);
              const position = router.getHandlePosition(handle.parent, theRoute, handle);
              if (position !== void 0) {
                let pathEndPos;
                for (let i2 = 0; i2 < theRoute.length; i2++) {
                  const elem = theRoute[i2];
                  if (elem.kind === position.kind && elem.pointIndex === position.pointIndex) {
                    if (handle.kind === "bezier-control-before") {
                      pathEndPos = theRoute[i2 + 1];
                    } else {
                      pathEndPos = theRoute[i2 - 1];
                    }
                    break;
                  }
                }
                let node;
                if (pathEndPos) {
                  const coords = `M ${position.x}, ${position.y} L ${pathEndPos.x}, ${pathEndPos.y}`;
                  node = (0, jsx_1.svg)(
                    "g",
                    { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback },
                    (0, jsx_1.svg)("path", { d: coords, stroke: "grey", "style-stroke-width": "2px" }),
                    (0, jsx_1.svg)("circle", { cx: position.x, cy: position.y, r: this.getRadius() })
                  );
                } else {
                  node = (0, jsx_1.svg)("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                }
                (0, vnode_utils_1.setAttr)(node, "data-kind", handle.kind);
                return node;
              }
            }
          }
          return (0, jsx_1.svg)("g", null);
        }
      };
      exports.SBezierControlHandleView = SBezierControlHandleView;
      exports.SBezierControlHandleView = SBezierControlHandleView = __decorate([
        (0, inversify_1.injectable)()
      ], SBezierControlHandleView);
    }
  });

  // ../../node_modules/sprotty/lib/model-source/di.config.js
  var require_di_config23 = __commonJS({
    "../../node_modules/sprotty/lib/model-source/di.config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var inversify_1 = require_cjs4();
      var command_registration_1 = require_command_registration();
      var types_1 = require_types();
      var commit_model_1 = require_commit_model();
      var model_source_1 = require_model_source();
      var modelSourceModule = new inversify_1.ContainerModule((bind, _unbind, isBound) => {
        bind(types_1.TYPES.ModelSourceProvider).toProvider((context) => {
          return () => {
            return new Promise((resolve) => {
              resolve(context.container.get(types_1.TYPES.ModelSource));
            });
          };
        });
        (0, command_registration_1.configureCommand)({ bind, isBound }, commit_model_1.CommitModelCommand);
        bind(types_1.TYPES.IActionHandlerInitializer).toService(types_1.TYPES.ModelSource);
        bind(model_source_1.ComputedBoundsApplicator).toSelf().inSingletonScope();
      });
      exports.default = modelSourceModule;
    }
  });

  // ../../node_modules/sprotty/lib/lib/modules.js
  var require_modules = __commonJS({
    "../../node_modules/sprotty/lib/lib/modules.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadDefaultModules = void 0;
      var di_config_1 = __importDefault(require_di_config());
      var di_config_2 = __importDefault(require_di_config23());
      var di_config_3 = __importDefault(require_di_config4());
      var di_config_4 = __importDefault(require_di_config5());
      var di_config_5 = __importDefault(require_di_config6());
      var di_config_6 = __importDefault(require_di_config7());
      var di_config_7 = __importDefault(require_di_config8());
      var di_config_8 = __importDefault(require_di_config2());
      var di_config_9 = require_di_config3();
      var di_config_10 = __importDefault(require_di_config11());
      var di_config_11 = __importDefault(require_di_config12());
      var di_config_12 = __importDefault(require_di_config13());
      var di_config_13 = __importDefault(require_di_config14());
      var di_config_14 = __importDefault(require_di_config15());
      var di_config_15 = __importDefault(require_di_config16());
      var di_config_16 = __importDefault(require_di_config17());
      var di_config_17 = __importDefault(require_di_config18());
      var di_config_18 = __importDefault(require_di_config19());
      var di_config_19 = __importDefault(require_di_config20());
      var di_config_20 = __importDefault(require_di_config21());
      var di_config_21 = __importDefault(require_di_config22());
      function loadDefaultModules2(container, options) {
        const modules = [
          di_config_1.default,
          di_config_2.default,
          di_config_3.default,
          di_config_4.default,
          di_config_5.default,
          di_config_6.default,
          di_config_7.default,
          di_config_9.edgeEditModule,
          di_config_8.default,
          di_config_10.default,
          di_config_11.default,
          di_config_12.default,
          di_config_13.default,
          di_config_9.labelEditModule,
          di_config_9.labelEditUiModule,
          di_config_14.default,
          di_config_15.default,
          di_config_16.default,
          di_config_17.default,
          di_config_18.default,
          di_config_19.default,
          di_config_20.default,
          di_config_21.default
        ];
        if (options && options.exclude) {
          for (const mod of options.exclude) {
            const index = modules.indexOf(mod);
            if (index >= 0)
              modules.splice(index, 1);
          }
        }
        container.load(...modules);
      }
      exports.loadDefaultModules = loadDefaultModules2;
    }
  });

  // ../../node_modules/sprotty/lib/lib/virtualize.js
  var require_virtualize = __commonJS({
    "../../node_modules/sprotty/lib/lib/virtualize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var snabbdom_1 = require_snabbdom_cjs();
      function buildVNodeData(attrs) {
        const data = {};
        const addData = (memo, name) => {
          if (name !== "style" && name !== "class") {
            const val = unescapeEntities(attrs[name]);
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        const _attrs = Object.keys(attrs).reduce(addData, null);
        if (_attrs) {
          data.attrs = _attrs;
        }
        const style = parseStyle(attrs);
        if (style) {
          data.style = style;
        }
        const classes = parseClass(attrs);
        if (classes) {
          data.class = classes;
        }
        return data;
      }
      function parseStyle(attrs) {
        const addStyle = (memo, styleProp) => {
          const res = styleProp.split(":");
          const name = transformName(res[0].trim());
          if (name) {
            const val = res[1].replace("!important", "").trim();
            memo ? memo[name] = val : memo = { [name]: val };
          }
          return memo;
        };
        try {
          return attrs.style.split(";").reduce(addStyle, null);
        } catch (e2) {
          return null;
        }
      }
      function parseClass(attrs) {
        const addClass = (memo, className) => {
          className = className.trim();
          if (className) {
            memo ? memo[className] = true : memo = { [className]: true };
          }
          return memo;
        };
        try {
          return attrs.class.split(" ").reduce(addClass, null);
        } catch (e2) {
          return null;
        }
      }
      function transformName(name) {
        name = name.replace(/-(\w)/g, function _replace($1, $2) {
          return $2.toUpperCase();
        });
        const firstChar = name.charAt(0).toLowerCase();
        return `${firstChar}${name.substring(1)}`;
      }
      var entityRegex = new RegExp("&[a-z0-9#]+;", "gi");
      var el = null;
      function unescapeEntities(text) {
        if (!el) {
          el = document.createElement("div");
        }
        return text.replace(entityRegex, (entity) => {
          if (el === null)
            return "";
          el.innerHTML = entity;
          return el.textContent === null ? "" : el.textContent;
        });
      }
      function recurse(doc, func) {
        let node = doc;
        let parent = null;
        const stack = [];
        const setChild = (n) => {
          const child = n.firstChild;
          if (child !== null) {
            parent = n;
          }
          node = child;
        };
        func(node, parent);
        setChild(node);
        while (true) {
          while (node) {
            stack.push(node);
            func(node, parent);
            setChild(node);
          }
          const _node = stack.pop();
          node = _node ? _node : null;
          if (!stack.length)
            break;
          parent = stack[stack.length - 1];
          if (node) {
            const sibling = node.nextSibling;
            if (sibling == null) {
              parent = stack[stack.length - 1];
            }
            node = sibling;
          }
        }
      }
      var vdom = null;
      var vnodeMap = /* @__PURE__ */ new Map();
      var delimited = false;
      function toVNode(node, parent) {
        let current;
        if (parent !== null) {
          current = vnodeMap.get(parent);
        }
        switch (node === null || node === void 0 ? void 0 : node.nodeType) {
          // element
          case 1: {
            if (current === void 0)
              return;
            current.children = current.children ? current.children : [];
            const children = current.children;
            const attributes = node.attributes;
            const attrs = {};
            for (let i2 = 0; i2 < attributes.length; i2++) {
              const attr = attributes.item(i2);
              if (attr) {
                attrs[attr.name] = attr.value;
              }
            }
            const vn = (0, snabbdom_1.h)(node.nodeName, buildVNodeData(attrs));
            children.push(vn);
            vnodeMap.set(node, vn);
            break;
          }
          // text
          case 3: {
            const text = node.textContent;
            if (text !== null && current !== void 0) {
              current.children = current.children ? current.children : [];
              const children = current.children;
              const lastData = children.length > 0 ? children[children.length - 1] : null;
              if (!delimited && typeof lastData !== "string" && lastData !== null && lastData.sel === void 0) {
                lastData.text = lastData.text + text;
              } else {
                children.push((0, snabbdom_1.vnode)(void 0, void 0, void 0, text, void 0));
              }
              delimited = false;
            }
            break;
          }
          case 8: {
            delimited = true;
            break;
          }
          // document
          case 9: {
            vdom = (0, snabbdom_1.vnode)(void 0, void 0, [], void 0, void 0);
            vnodeMap.set(node, vdom);
            break;
          }
          default:
            break;
        }
      }
      function stripVNode(vnodes) {
        const children = vnodes === null || vnodes === void 0 ? void 0 : vnodes.children;
        if (typeof children === "undefined")
          return null;
        if (children.length === 1 && typeof children[0] !== "string")
          return children[0];
        return null;
      }
      function virtualizeString(html) {
        var _a4, _b2;
        const parser = new window.DOMParser();
        if (parser === void 0 || html === void 0 || html === "")
          return null;
        const doc = parser.parseFromString(html, "application/xml");
        if (((_a4 = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a4 === void 0 ? void 0 : _a4.nodeName) === "parsererror") {
          const error = `${(_b2 = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _b2 === void 0 ? void 0 : _b2.textContent}`;
          return (0, snabbdom_1.h)("parsererror", [error]);
        }
        delimited = false;
        vdom = null;
        recurse(doc, toVNode);
        if (vdom === null)
          return null;
        return stripVNode(vdom);
      }
      exports.default = virtualizeString;
    }
  });

  // ../../node_modules/sprotty/lib/lib/model.js
  var require_model18 = __commonJS({
    "../../node_modules/sprotty/lib/lib/model.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectElement = exports.ForeignObjectElementImpl = exports.ShapedPreRenderedElement = exports.ShapedPreRenderedElementImpl = exports.PreRenderedElement = exports.PreRenderedElementImpl = exports.HtmlRoot = exports.HtmlRootImpl = exports.RectangularPort = exports.CircularPort = exports.DiamondNode = exports.RectangularNode = exports.CircularNode = void 0;
      var geometry_1 = require_geometry();
      var smodel_1 = require_smodel();
      var model_1 = require_model2();
      var model_2 = require_model8();
      var model_3 = require_model6();
      var sgraph_1 = require_sgraph();
      var anchor_1 = require_anchor();
      var CircularNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularNode = CircularNode;
      var RectangularNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularNode = RectangularNode;
      var DiamondNode = class extends sgraph_1.SNodeImpl {
        get anchorKind() {
          return anchor_1.DIAMOND_ANCHOR_KIND;
        }
      };
      exports.DiamondNode = DiamondNode;
      var CircularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.ELLIPTIC_ANCHOR_KIND;
        }
      };
      exports.CircularPort = CircularPort;
      var RectangularPort = class extends sgraph_1.SPortImpl {
        get anchorKind() {
          return anchor_1.RECTANGULAR_ANCHOR_KIND;
        }
      };
      exports.RectangularPort = RectangularPort;
      var HtmlRootImpl = class extends smodel_1.SModelRootImpl {
        constructor() {
          super(...arguments);
          this.classes = [];
        }
      };
      exports.HtmlRootImpl = HtmlRootImpl;
      exports.HtmlRoot = HtmlRootImpl;
      var PreRenderedElementImpl = class extends smodel_1.SChildElementImpl {
      };
      exports.PreRenderedElementImpl = PreRenderedElementImpl;
      exports.PreRenderedElement = PreRenderedElementImpl;
      var ShapedPreRenderedElementImpl = class extends PreRenderedElementImpl {
        constructor() {
          super(...arguments);
          this.position = geometry_1.Point.ORIGIN;
          this.size = geometry_1.Dimension.EMPTY;
          this.selected = false;
          this.alignment = geometry_1.Point.ORIGIN;
        }
        get bounds() {
          return {
            x: this.position.x,
            y: this.position.y,
            width: this.size.width,
            height: this.size.height
          };
        }
        set bounds(newBounds) {
          this.position = {
            x: newBounds.x,
            y: newBounds.y
          };
          this.size = {
            width: newBounds.width,
            height: newBounds.height
          };
        }
      };
      exports.ShapedPreRenderedElementImpl = ShapedPreRenderedElementImpl;
      ShapedPreRenderedElementImpl.DEFAULT_FEATURES = [model_2.moveFeature, model_1.boundsFeature, model_3.selectFeature, model_1.alignFeature];
      exports.ShapedPreRenderedElement = ShapedPreRenderedElementImpl;
      var ForeignObjectElementImpl = class extends ShapedPreRenderedElementImpl {
        get bounds() {
          if (geometry_1.Dimension.isValid(this.size)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.size.width,
              height: this.size.height
            };
          } else if ((0, model_1.isBoundsAware)(this.parent)) {
            return {
              x: this.position.x,
              y: this.position.y,
              width: this.parent.bounds.width,
              height: this.parent.bounds.height
            };
          }
          return geometry_1.Bounds.EMPTY;
        }
      };
      exports.ForeignObjectElementImpl = ForeignObjectElementImpl;
      exports.ForeignObjectElement = ForeignObjectElementImpl;
    }
  });

  // ../../node_modules/sprotty/lib/lib/generic-views.js
  var require_generic_views = __commonJS({
    "../../node_modules/sprotty/lib/lib/generic-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForeignObjectView = exports.PreRenderedView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var virtualize_1 = __importDefault(require_virtualize());
      var vnode_utils_1 = require_vnode_utils();
      var views_1 = require_views();
      var model_1 = require_model18();
      var PreRenderedView = class PreRenderedView extends views_1.ShapeView {
        render(model, context) {
          if (model instanceof model_1.ShapedPreRenderedElementImpl && !this.isVisible(model, context)) {
            return void 0;
          }
          const node = (0, virtualize_1.default)(model.code);
          if (node === null)
            return void 0;
          this.correctNamespace(node);
          return node;
        }
        correctNamespace(node) {
          if (node.sel === "svg" || node.sel === "g")
            (0, vnode_utils_1.setNamespace)(node, "http://www.w3.org/2000/svg");
        }
      };
      exports.PreRenderedView = PreRenderedView;
      exports.PreRenderedView = PreRenderedView = __decorate([
        (0, inversify_1.injectable)()
      ], PreRenderedView);
      var ForeignObjectView = class ForeignObjectView {
        render(model, context) {
          const foreignObjectContents = (0, virtualize_1.default)(model.code);
          if (foreignObjectContents === null)
            return void 0;
          const node = (0, jsx_1.svg)(
            "g",
            null,
            (0, jsx_1.svg)("foreignObject", { requiredFeatures: "http://www.w3.org/TR/SVG11/feature#Extensibility", height: model.bounds.height, width: model.bounds.width, x: 0, y: 0 }, foreignObjectContents),
            context.renderChildren(model)
          );
          (0, vnode_utils_1.setAttr)(node, "class", model.type);
          (0, vnode_utils_1.setNamespace)(foreignObjectContents, model.namespace);
          return node;
        }
      };
      exports.ForeignObjectView = ForeignObjectView;
      exports.ForeignObjectView = ForeignObjectView = __decorate([
        (0, inversify_1.injectable)()
      ], ForeignObjectView);
    }
  });

  // ../../node_modules/sprotty/lib/lib/html-views.js
  var require_html_views = __commonJS({
    "../../node_modules/sprotty/lib/lib/html-views.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HtmlRootView = void 0;
      var jsx_1 = require_jsx();
      var inversify_1 = require_cjs4();
      var vnode_utils_1 = require_vnode_utils();
      var HtmlRootView = class HtmlRootView {
        render(model, context) {
          const root = (0, jsx_1.html)("div", null, context.renderChildren(model));
          for (const c3 of model.classes) {
            (0, vnode_utils_1.setClass)(root, c3, true);
          }
          return root;
        }
      };
      exports.HtmlRootView = HtmlRootView;
      exports.HtmlRootView = HtmlRootView = __decorate([
        (0, inversify_1.injectable)()
      ], HtmlRootView);
    }
  });

  // ../../node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "../../node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a3, b3) {
        if ("function" == typeof define && define.amd) define([], b3);
        else if ("undefined" != typeof exports) b3();
        else {
          b3(), a3.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b3(a4, b4) {
          return "undefined" == typeof b4 ? b4 = { autoBom: false } : "object" != typeof b4 && (console.warn("Deprecated: Expected third argument to be a object"), b4 = { autoBom: !b4 }), b4.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a4.type) ? new Blob(["\uFEFF", a4], { type: a4.type }) : a4;
        }
        function c3(a4, b4, c4) {
          var d4 = new XMLHttpRequest();
          d4.open("GET", a4), d4.responseType = "blob", d4.onload = function() {
            g3(d4.response, b4, c4);
          }, d4.onerror = function() {
            console.error("could not download file");
          }, d4.send();
        }
        function d3(a4) {
          var b4 = new XMLHttpRequest();
          b4.open("HEAD", a4, false);
          try {
            b4.send();
          } catch (a5) {
          }
          return 200 <= b4.status && 299 >= b4.status;
        }
        function e2(a4) {
          try {
            a4.dispatchEvent(new MouseEvent("click"));
          } catch (c4) {
            var b4 = document.createEvent("MouseEvents");
            b4.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a4.dispatchEvent(b4);
          }
        }
        var f3 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a3 = f3.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g3 = f3.saveAs || ("object" != typeof window || window !== f3 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a3 ? function(b4, g4, h4) {
          var i2 = f3.URL || f3.webkitURL, j3 = document.createElement("a");
          g4 = g4 || b4.name || "download", j3.download = g4, j3.rel = "noopener", "string" == typeof b4 ? (j3.href = b4, j3.origin === location.origin ? e2(j3) : d3(j3.href) ? c3(b4, g4, h4) : e2(j3, j3.target = "_blank")) : (j3.href = i2.createObjectURL(b4), setTimeout(function() {
            i2.revokeObjectURL(j3.href);
          }, 4e4), setTimeout(function() {
            e2(j3);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f4, g4, h4) {
          if (g4 = g4 || f4.name || "download", "string" != typeof f4) navigator.msSaveOrOpenBlob(b3(f4, h4), g4);
          else if (d3(f4)) c3(f4, g4, h4);
          else {
            var i2 = document.createElement("a");
            i2.href = f4, i2.target = "_blank", setTimeout(function() {
              e2(i2);
            });
          }
        } : function(b4, d4, e3, g4) {
          if (g4 = g4 || open("", "_blank"), g4 && (g4.document.title = g4.document.body.innerText = "downloading..."), "string" == typeof b4) return c3(b4, d4, e3);
          var h4 = "application/octet-stream" === b4.type, i2 = /constructor/i.test(f3.HTMLElement) || f3.safari, j3 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j3 || h4 && i2 || a3) && "undefined" != typeof FileReader) {
            var k3 = new FileReader();
            k3.onloadend = function() {
              var a4 = k3.result;
              a4 = j3 ? a4 : a4.replace(/^data:[^;]*;/, "data:attachment/file;"), g4 ? g4.location.href = a4 : location = a4, g4 = null;
            }, k3.readAsDataURL(b4);
          } else {
            var l3 = f3.URL || f3.webkitURL, m3 = l3.createObjectURL(b4);
            g4 ? g4.location = m3 : location.href = m3, g4 = null, setTimeout(function() {
              l3.revokeObjectURL(m3);
            }, 4e4);
          }
        });
        f3.saveAs = g3.saveAs = g3, "undefined" != typeof module && (module.exports = g3);
      });
    }
  });

  // ../../node_modules/sprotty/lib/model-source/diagram-server.js
  var require_diagram_server2 = __commonJS({
    "../../node_modules/sprotty/lib/model-source/diagram-server.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagramServerProxy = exports.ServerStatusAction = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var set_model_1 = require_set_model();
      var types_1 = require_types();
      var bounds_manipulation_1 = require_bounds_manipulation();
      var update_model_1 = require_update_model();
      var model_source_1 = require_model_source();
      var ServerStatusAction = class _ServerStatusAction {
        constructor() {
          this.kind = _ServerStatusAction.KIND;
        }
      };
      exports.ServerStatusAction = ServerStatusAction;
      ServerStatusAction.KIND = "serverStatus";
      var receivedFromServerProperty = "__receivedFromServer";
      var DiagramServerProxy = class DiagramServerProxy extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = {
            type: "NONE",
            id: "ROOT"
          };
        }
        get model() {
          return this.currentRoot;
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(bounds_manipulation_1.RequestBoundsCommand.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
          registry.register(actions_1.CollapseExpandAction.KIND, this);
          registry.register(actions_1.CollapseExpandAllAction.KIND, this);
          registry.register(actions_1.OpenAction.KIND, this);
          registry.register(ServerStatusAction.KIND, this);
          if (!this.clientId) {
            this.clientId = this.viewerOptions.baseDiv;
          }
        }
        handle(action) {
          const forwardToServer = this.handleLocally(action);
          if (forwardToServer) {
            this.forwardToServer(action);
          }
        }
        forwardToServer(action) {
          const message = {
            clientId: this.clientId,
            action
          };
          this.logger.log(this, "sending", message);
          this.sendMessage(message);
        }
        /**
         * Called when a message is received from the remote diagram server.
         */
        messageReceived(data) {
          const object = typeof data === "string" ? JSON.parse(data) : data;
          if ((0, actions_1.isActionMessage)(object) && object.action) {
            if (!object.clientId || object.clientId === this.clientId) {
              object.action[receivedFromServerProperty] = true;
              this.logger.log(this, "receiving", object);
              this.actionDispatcher.dispatch(object.action).then(() => {
                this.storeNewModel(object.action);
              });
            }
          } else {
            this.logger.error(this, "received data is not an action message", object);
          }
        }
        /**
         * Check whether the given action should be handled locally. Returns true if the action should
         * still be sent to the server, and false if it's only handled locally.
         */
        handleLocally(action) {
          this.storeNewModel(action);
          switch (action.kind) {
            case actions_1.ComputedBoundsAction.KIND:
              return this.handleComputedBounds(action);
            case actions_1.RequestModelAction.KIND:
              return this.handleRequestModel(action);
            case bounds_manipulation_1.RequestBoundsCommand.KIND:
              return false;
            case actions_1.ExportSvgAction.KIND:
              return this.handleExportSvgAction(action);
            case ServerStatusAction.KIND:
              return this.handleServerStateAction(action);
          }
          return !action[receivedFromServerProperty];
        }
        /**
         * Put the new model contained in the given action into the model storage, if there is any.
         */
        storeNewModel(action) {
          if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND || action.kind === bounds_manipulation_1.RequestBoundsCommand.KIND) {
            const newRoot = action.newRoot;
            if (newRoot) {
              this.currentRoot = newRoot;
              if (action.kind === set_model_1.SetModelCommand.KIND || action.kind === update_model_1.UpdateModelCommand.KIND) {
                this.lastSubmittedModelType = newRoot.type;
              }
            }
          }
        }
        handleRequestModel(action) {
          const newOptions = Object.assign({ needsClientLayout: this.viewerOptions.needsClientLayout, needsServerLayout: this.viewerOptions.needsServerLayout }, action.options);
          const newAction = Object.assign(Object.assign({}, action), { options: newOptions });
          this.forwardToServer(newAction);
          return false;
        }
        /**
         * If the server requires to compute a layout, the computed bounds are forwarded. Otherwise they
         * are applied to the current model locally and a model update is triggered.
         */
        handleComputedBounds(action) {
          if (this.viewerOptions.needsServerLayout) {
            return true;
          } else {
            const root = this.currentRoot;
            this.computedBoundsApplicator.apply(root, action);
            if (root.type === this.lastSubmittedModelType) {
              this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(root));
            } else {
              this.actionDispatcher.dispatch(actions_1.SetModelAction.create(root));
            }
            this.lastSubmittedModelType = root.type;
            return false;
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
          return false;
        }
        handleServerStateAction(action) {
          return false;
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
      };
      exports.DiagramServerProxy = DiagramServerProxy;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], DiagramServerProxy.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], DiagramServerProxy.prototype, "computedBoundsApplicator", void 0);
      exports.DiagramServerProxy = DiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], DiagramServerProxy);
    }
  });

  // ../../node_modules/sprotty/lib/model-source/local-model-source.js
  var require_local_model_source = __commonJS({
    "../../node_modules/sprotty/lib/model-source/local-model-source.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalModelSource = void 0;
      var file_saver_1 = require_FileSaver_min();
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var sprotty_protocol_1 = require_lib();
      var model_utils_1 = require_model_utils();
      var types_1 = require_types();
      var smodel_factory_1 = require_smodel_factory();
      var model_matching_1 = require_model_matching();
      var model_source_1 = require_model_source();
      var LocalModelSource2 = class LocalModelSource extends model_source_1.ModelSource {
        constructor() {
          super(...arguments);
          this.currentRoot = smodel_factory_1.EMPTY_ROOT;
        }
        get model() {
          return this.currentRoot;
        }
        set model(root) {
          this.setModel(root);
        }
        initialize(registry) {
          super.initialize(registry);
          registry.register(actions_1.ComputedBoundsAction.KIND, this);
          registry.register(actions_1.RequestPopupModelAction.KIND, this);
        }
        /**
         * Set the model without incremental update.
         */
        setModel(newRoot) {
          this.currentRoot = newRoot;
          return this.submitModel(newRoot, false);
        }
        commitModel(newRoot) {
          const previousRoot = this.currentRoot;
          this.currentRoot = newRoot;
          return previousRoot;
        }
        /**
         * Apply an incremental update to the model with an animation showing the transition to
         * the new state. If `newRoot` is undefined, the current root is submitted; in that case
         * it is assumed that it has been modified before.
         */
        updateModel(newRoot) {
          if (newRoot === void 0) {
            return this.submitModel(this.currentRoot, true);
          } else {
            this.currentRoot = newRoot;
            return this.submitModel(newRoot, true);
          }
        }
        /**
         * Get the current selection from the model.
         */
        async getSelection() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetSelectionAction.create());
          const result = [];
          this.gatherSelectedElements(this.currentRoot, new Set(res.selectedElementsIDs), result);
          return result;
        }
        gatherSelectedElements(element, selected, result) {
          if (selected.has(element.id)) {
            result.push(element);
          }
          if (element.children) {
            for (const child of element.children) {
              this.gatherSelectedElements(child, selected, result);
            }
          }
        }
        /**
         * Get the current viewport from the model.
         */
        async getViewport() {
          const res = await this.actionDispatcher.request(sprotty_protocol_1.GetViewportAction.create());
          return {
            scroll: res.viewport.scroll,
            zoom: res.viewport.zoom,
            canvasBounds: res.canvasBounds
          };
        }
        /**
         * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
         * `ComputedBoundsAction`, otherwise call `doSubmitModel()` directly.
         */
        async submitModel(newRoot, update, cause) {
          if (this.viewerOptions.needsClientLayout) {
            const computedBounds = await this.actionDispatcher.request(actions_1.RequestBoundsAction.create(newRoot));
            const index = this.computedBoundsApplicator.apply(this.currentRoot, computedBounds);
            await this.doSubmitModel(newRoot, update, cause, index);
          } else {
            await this.doSubmitModel(newRoot, update, cause);
          }
        }
        /**
         * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
         * `update` argument. If available, the model layout engine is invoked first.
         */
        async doSubmitModel(newRoot, update, cause, index) {
          if (this.layoutEngine !== void 0) {
            try {
              const layoutResult = this.layoutEngine.layout(newRoot, index);
              if (layoutResult instanceof Promise)
                newRoot = await layoutResult;
              else if (layoutResult !== void 0)
                newRoot = layoutResult;
            } catch (error) {
              this.logger.error(this, error.toString(), error.stack);
            }
          }
          const lastSubmittedModelType = this.lastSubmittedModelType;
          this.lastSubmittedModelType = newRoot.type;
          if (cause && cause.kind === actions_1.RequestModelAction.KIND && cause.requestId) {
            const request = cause;
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot, request.requestId));
          } else if (update && newRoot.type === lastSubmittedModelType) {
            const input = Array.isArray(update) ? update : newRoot;
            await this.actionDispatcher.dispatch(actions_1.UpdateModelAction.create(input, { animate: true, cause }));
          } else {
            await this.actionDispatcher.dispatch(actions_1.SetModelAction.create(newRoot));
          }
        }
        /**
         * Modify the current model with an array of matches.
         */
        applyMatches(matches) {
          const root = this.currentRoot;
          (0, model_matching_1.applyMatches)(root, matches);
          return this.submitModel(root, matches);
        }
        /**
         * Modify the current model by adding new elements.
         */
        addElements(elements) {
          const matches = [];
          for (const e2 of elements) {
            const anye = e2;
            if (typeof anye.element === "object" && typeof anye.parentId === "string") {
              matches.push({
                right: anye.element,
                rightParentId: anye.parentId
              });
            } else if (typeof anye.id === "string") {
              matches.push({
                right: anye,
                rightParentId: this.currentRoot.id
              });
            }
          }
          return this.applyMatches(matches);
        }
        /**
         * Modify the current model by removing elements.
         */
        removeElements(elements) {
          const matches = [];
          const index = new model_utils_1.SModelIndex();
          index.add(this.currentRoot);
          for (const e2 of elements) {
            const anye = e2;
            if (anye.elementId !== void 0 && anye.parentId !== void 0) {
              const element = index.getById(anye.elementId);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: anye.parentId
                });
              }
            } else {
              const element = index.getById(anye);
              if (element !== void 0) {
                matches.push({
                  left: element,
                  leftParentId: this.currentRoot.id
                });
              }
            }
          }
          return this.applyMatches(matches);
        }
        // ----- Methods for handling incoming actions ----------------------------
        handle(action) {
          switch (action.kind) {
            case actions_1.RequestModelAction.KIND:
              this.handleRequestModel(action);
              break;
            case actions_1.ComputedBoundsAction.KIND:
              this.computedBoundsApplicator.apply(this.currentRoot, action);
              break;
            case actions_1.RequestPopupModelAction.KIND:
              this.handleRequestPopupModel(action);
              break;
            case actions_1.ExportSvgAction.KIND:
              this.handleExportSvgAction(action);
              break;
          }
        }
        handleRequestModel(action) {
          this.submitModel(this.currentRoot, false, action);
        }
        handleRequestPopupModel(action) {
          if (this.popupModelProvider !== void 0) {
            const element = (0, model_utils_1.findElement)(this.currentRoot, action.elementId);
            const popupRoot = this.popupModelProvider.getPopupModel(action, element);
            if (popupRoot !== void 0) {
              popupRoot.canvasBounds = action.bounds;
              this.actionDispatcher.dispatch(actions_1.SetPopupModelAction.create(popupRoot, action.requestId));
            }
          }
        }
        handleExportSvgAction(action) {
          const blob = new Blob([action.svg], { type: "text/plain;charset=utf-8" });
          (0, file_saver_1.saveAs)(blob, "diagram.svg");
        }
      };
      exports.LocalModelSource = LocalModelSource2;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
      ], LocalModelSource2.prototype, "logger", void 0);
      __decorate([
        (0, inversify_1.inject)(model_source_1.ComputedBoundsApplicator),
        __metadata("design:type", model_source_1.ComputedBoundsApplicator)
      ], LocalModelSource2.prototype, "computedBoundsApplicator", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IPopupModelProvider),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource2.prototype, "popupModelProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.IModelLayoutEngine),
        (0, inversify_1.optional)(),
        __metadata("design:type", Object)
      ], LocalModelSource2.prototype, "layoutEngine", void 0);
      exports.LocalModelSource = LocalModelSource2 = __decorate([
        (0, inversify_1.injectable)()
      ], LocalModelSource2);
    }
  });

  // ../../node_modules/sprotty/lib/model-source/logging.js
  var require_logging2 = __commonJS({
    "../../node_modules/sprotty/lib/model-source/logging.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      var __metadata = exports && exports.__metadata || function(k3, v3) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k3, v3);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ForwardingLogger = void 0;
      var inversify_1 = require_cjs4();
      var actions_1 = require_actions();
      var logging_1 = require_logging();
      var types_1 = require_types();
      var ForwardingLogger = class ForwardingLogger {
        error(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.error)
            this.forward(thisArg, message, logging_1.LogLevel.error, params);
        }
        warn(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.warn)
            this.forward(thisArg, message, logging_1.LogLevel.warn, params);
        }
        info(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.info)
            this.forward(thisArg, message, logging_1.LogLevel.info, params);
        }
        log(thisArg, message, ...params) {
          if (this.logLevel >= logging_1.LogLevel.log) {
            try {
              const caller = typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg);
              console.log.apply(thisArg, [caller + ": " + message, ...params]);
            } catch (error) {
            }
          }
        }
        forward(thisArg, message, logLevel, params) {
          const date = /* @__PURE__ */ new Date();
          const action = actions_1.LoggingAction.create({
            message,
            severity: logging_1.LogLevel[logLevel],
            time: date.toLocaleTimeString(),
            caller: typeof thisArg === "object" ? thisArg.constructor.name : String(thisArg),
            params: params.map((p3) => JSON.stringify(p3))
          });
          this.modelSourceProvider().then((modelSource) => {
            try {
              modelSource.handle(action);
            } catch (error) {
              try {
                console.log.apply(thisArg, [message, action, error]);
              } catch (e2) {
              }
            }
          });
        }
      };
      exports.ForwardingLogger = ForwardingLogger;
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.ModelSourceProvider),
        __metadata("design:type", Function)
      ], ForwardingLogger.prototype, "modelSourceProvider", void 0);
      __decorate([
        (0, inversify_1.inject)(types_1.TYPES.LogLevel),
        __metadata("design:type", Number)
      ], ForwardingLogger.prototype, "logLevel", void 0);
      exports.ForwardingLogger = ForwardingLogger = __decorate([
        (0, inversify_1.injectable)()
      ], ForwardingLogger);
    }
  });

  // ../../node_modules/sprotty/lib/model-source/websocket.js
  var require_websocket = __commonJS({
    "../../node_modules/sprotty/lib/model-source/websocket.js"(exports) {
      "use strict";
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
        else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WebSocketDiagramServerProxy = void 0;
      var inversify_1 = require_cjs4();
      var diagram_server_1 = require_diagram_server2();
      var WebSocketDiagramServerProxy = class WebSocketDiagramServerProxy extends diagram_server_1.DiagramServerProxy {
        listen(webSocket) {
          webSocket.addEventListener("message", (event) => {
            this.messageReceived(event.data);
          });
          webSocket.addEventListener("error", (event) => {
            this.logger.error(this, "error event received", event);
          });
          this.webSocket = webSocket;
        }
        disconnect() {
          if (this.webSocket) {
            this.webSocket.close();
            this.webSocket = void 0;
          }
        }
        sendMessage(message) {
          if (this.webSocket) {
            this.webSocket.send(JSON.stringify(message));
          } else {
            throw new Error("WebSocket is not connected");
          }
        }
      };
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy;
      exports.WebSocketDiagramServerProxy = WebSocketDiagramServerProxy = __decorate([
        (0, inversify_1.injectable)()
      ], WebSocketDiagramServerProxy);
    }
  });

  // ../../node_modules/sprotty/lib/utils/color.js
  var require_color = __commonJS({
    "../../node_modules/sprotty/lib/utils/color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ColorMap = exports.toSVG = exports.rgb = void 0;
      function rgb(red, green, blue) {
        return {
          red,
          green,
          blue
        };
      }
      exports.rgb = rgb;
      function toSVG(c3) {
        return "rgb(" + c3.red + "," + c3.green + "," + c3.blue + ")";
      }
      exports.toSVG = toSVG;
      var ColorMap = class {
        constructor(stops) {
          this.stops = stops;
        }
        getColor(t3) {
          t3 = Math.max(0, Math.min(0.99999999, t3));
          const i2 = Math.floor(t3 * this.stops.length);
          return this.stops[i2];
        }
      };
      exports.ColorMap = ColorMap;
    }
  });

  // ../../node_modules/sprotty/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/sprotty/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      }) : (function(o3, m3, k3, k22) {
        if (k22 === void 0) k22 = k3;
        o3[k22] = m3[k3];
      }));
      var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3)) __createBinding(exports2, m3, p3);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.modelSourceModule = exports.zorderModule = exports.viewportModule = exports.updateModule = exports.undoRedoModule = exports.selectModule = exports.routingModule = exports.openModule = exports.moveModule = exports.hoverModule = exports.fadeModule = exports.exportModule = exports.expandModule = exports.edgeLayoutModule = exports.edgeJunctionModule = exports.edgeIntersectionModule = exports.decorationModule = exports.contextMenuModule = exports.commandPaletteModule = exports.buttonModule = exports.boundsModule = exports.defaultModule = void 0;
      __exportStar(require_action(), exports);
      __exportStar(require_action_dispatcher(), exports);
      __exportStar(require_action_handler(), exports);
      __exportStar(require_diagram_locker(), exports);
      __exportStar(require_animation_frame_syncer(), exports);
      __exportStar(require_animation(), exports);
      __exportStar(require_easing(), exports);
      __exportStar(require_command(), exports);
      __exportStar(require_command_registration(), exports);
      __exportStar(require_command_stack_options(), exports);
      __exportStar(require_command_stack(), exports);
      __exportStar(require_initialize_canvas(), exports);
      __exportStar(require_set_model(), exports);
      __exportStar(require_smodel_factory(), exports);
      __exportStar(require_smodel_utils(), exports);
      __exportStar(require_smodel(), exports);
      __exportStar(require_ui_extension_registry(), exports);
      __exportStar(require_ui_extension(), exports);
      __exportStar(require_key_tool(), exports);
      __exportStar(require_mouse_tool(), exports);
      __exportStar(require_thunk_view(), exports);
      __exportStar(require_view(), exports);
      __exportStar(require_viewer_cache(), exports);
      __exportStar(require_viewer_options(), exports);
      __exportStar(require_viewer(), exports);
      __exportStar(require_vnode_postprocessor(), exports);
      __exportStar(require_vnode_utils(), exports);
      __exportStar(require_types(), exports);
      var di_config_1 = __importDefault(require_di_config());
      exports.defaultModule = di_config_1.default;
      __exportStar(require_bounds_manipulation(), exports);
      __exportStar(require_hidden_bounds_updater(), exports);
      __exportStar(require_layout(), exports);
      __exportStar(require_model2(), exports);
      __exportStar(require_vbox_layout(), exports);
      __exportStar(require_hbox_layout(), exports);
      __exportStar(require_stack_layout(), exports);
      __exportStar(require_views(), exports);
      __exportStar(require_button_handler(), exports);
      __exportStar(require_model4(), exports);
      __exportStar(require_action_providers(), exports);
      __exportStar(require_command_palette(), exports);
      __exportStar(require_context_menu_service(), exports);
      __exportStar(require_menu_providers(), exports);
      __exportStar(require_mouse_listener(), exports);
      __exportStar(require_di_config2(), exports);
      __exportStar(require_edge_layout(), exports);
      __exportStar(require_model10(), exports);
      __exportStar(require_create(), exports);
      __exportStar(require_create_on_drag(), exports);
      __exportStar(require_di_config3(), exports);
      __exportStar(require_delete(), exports);
      __exportStar(require_edit_label(), exports);
      __exportStar(require_edit_label_ui(), exports);
      __exportStar(require_edit_routing(), exports);
      __exportStar(require_model11(), exports);
      __exportStar(require_reconnect(), exports);
      __exportStar(require_expand(), exports);
      __exportStar(require_model14(), exports);
      __exportStar(require_views2(), exports);
      __exportStar(require_export(), exports);
      __exportStar(require_model13(), exports);
      __exportStar(require_svg_exporter(), exports);
      __exportStar(require_svg_export_postprocessor(), exports);
      __exportStar(require_fade(), exports);
      __exportStar(require_model3(), exports);
      __exportStar(require_hover(), exports);
      __exportStar(require_model7(), exports);
      __exportStar(require_model15(), exports);
      __exportStar(require_views3(), exports);
      __exportStar(require_decoration_placer(), exports);
      __exportStar(require_intersection_finder(), exports);
      __exportStar(require_sweepline(), exports);
      __exportStar(require_junction_finder(), exports);
      __exportStar(require_junction_postprocessor(), exports);
      __exportStar(require_model8(), exports);
      __exportStar(require_move(), exports);
      __exportStar(require_snap(), exports);
      __exportStar(require_model5(), exports);
      __exportStar(require_open(), exports);
      __exportStar(require_model16(), exports);
      __exportStar(require_model17(), exports);
      __exportStar(require_views4(), exports);
      __exportStar(require_anchor(), exports);
      __exportStar(require_abstract_edge_router(), exports);
      __exportStar(require_bezier_anchors(), exports);
      __exportStar(require_bezier_edge_router(), exports);
      __exportStar(require_manhattan_anchors(), exports);
      __exportStar(require_manhattan_edge_router(), exports);
      __exportStar(require_model9(), exports);
      __exportStar(require_polyline_anchors(), exports);
      __exportStar(require_polyline_edge_router(), exports);
      __exportStar(require_routing(), exports);
      __exportStar(require_views5(), exports);
      __exportStar(require_model6(), exports);
      __exportStar(require_select(), exports);
      __exportStar(require_undo_redo(), exports);
      __exportStar(require_model_matching(), exports);
      __exportStar(require_update_model(), exports);
      __exportStar(require_center_fit(), exports);
      __exportStar(require_model12(), exports);
      __exportStar(require_scroll(), exports);
      __exportStar(require_viewport_root(), exports);
      __exportStar(require_viewport(), exports);
      __exportStar(require_zoom(), exports);
      __exportStar(require_zorder(), exports);
      var di_config_2 = __importDefault(require_di_config4());
      exports.boundsModule = di_config_2.default;
      var di_config_3 = __importDefault(require_di_config5());
      exports.buttonModule = di_config_3.default;
      var di_config_4 = __importDefault(require_di_config6());
      exports.commandPaletteModule = di_config_4.default;
      var di_config_5 = __importDefault(require_di_config7());
      exports.contextMenuModule = di_config_5.default;
      var di_config_6 = __importDefault(require_di_config8());
      exports.decorationModule = di_config_6.default;
      var di_config_7 = __importDefault(require_di_config9());
      exports.edgeIntersectionModule = di_config_7.default;
      var di_config_8 = __importDefault(require_di_config10());
      exports.edgeJunctionModule = di_config_8.default;
      var di_config_9 = __importDefault(require_di_config2());
      exports.edgeLayoutModule = di_config_9.default;
      var di_config_10 = __importDefault(require_di_config11());
      exports.expandModule = di_config_10.default;
      var di_config_11 = __importDefault(require_di_config12());
      exports.exportModule = di_config_11.default;
      var di_config_12 = __importDefault(require_di_config13());
      exports.fadeModule = di_config_12.default;
      var di_config_13 = __importDefault(require_di_config14());
      exports.hoverModule = di_config_13.default;
      var di_config_14 = __importDefault(require_di_config15());
      exports.moveModule = di_config_14.default;
      var di_config_15 = __importDefault(require_di_config16());
      exports.openModule = di_config_15.default;
      var di_config_16 = __importDefault(require_di_config17());
      exports.routingModule = di_config_16.default;
      var di_config_17 = __importDefault(require_di_config18());
      exports.selectModule = di_config_17.default;
      var di_config_18 = __importDefault(require_di_config19());
      exports.undoRedoModule = di_config_18.default;
      var di_config_19 = __importDefault(require_di_config20());
      exports.updateModule = di_config_19.default;
      var di_config_20 = __importDefault(require_di_config21());
      exports.viewportModule = di_config_20.default;
      var di_config_21 = __importDefault(require_di_config22());
      exports.zorderModule = di_config_21.default;
      __exportStar(require_sgraph(), exports);
      __exportStar(require_views6(), exports);
      __exportStar(require_modules(), exports);
      __exportStar(require_generic_views(), exports);
      __exportStar(require_html_views(), exports);
      __exportStar(require_jsx(), exports);
      __exportStar(require_model18(), exports);
      __exportStar(require_svg_views(), exports);
      __exportStar(require_commit_model(), exports);
      __exportStar(require_diagram_server2(), exports);
      __exportStar(require_local_model_source(), exports);
      __exportStar(require_logging2(), exports);
      __exportStar(require_model_source(), exports);
      __exportStar(require_websocket(), exports);
      var di_config_22 = __importDefault(require_di_config23());
      exports.modelSourceModule = di_config_22.default;
      __exportStar(require_browser(), exports);
      __exportStar(require_codicon(), exports);
      __exportStar(require_color(), exports);
      __exportStar(require_geometry2(), exports);
      __exportStar(require_inversify(), exports);
      __exportStar(require_logging(), exports);
      __exportStar(require_registry(), exports);
    }
  });

  // src/extension/webview/diagram-client.ts
  var import_reflect_metadata2 = __toESM(require_Reflect());

  // ../../node_modules/inversify/lib/esm/index.js
  var import_reflect_metadata = __toESM(require_Reflect(), 1);

  // ../../node_modules/@inversifyjs/common/lib/esm/index.js
  var t = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
  var _a, _e;
  _a = t;
  var r = class {
    constructor(e2) {
      __publicField(this, _a);
      __privateAdd(this, _e);
      __privateSet(this, _e, e2), this[t] = true;
    }
    static is(e2) {
      return "object" == typeof e2 && null !== e2 && true === e2[t];
    }
    unwrap() {
      return __privateGet(this, _e).call(this);
    }
  };
  _e = new WeakMap();

  // ../../node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
  function t2(t3, e2) {
    return Reflect.getMetadata(e2, t3);
  }
  function e(e2, n, a3, c3) {
    var _a4;
    const f3 = c3((_a4 = t2(e2, n)) != null ? _a4 : a3);
    Reflect.defineMetadata(n, f3, e2);
  }

  // ../../node_modules/@inversifyjs/core/lib/esm/index.js
  var a = "named";
  var r2 = "name";
  var i = "unmanaged";
  var o = "optional";
  var s = "inject";
  var c = "multi_inject";
  var u = "post_construct";
  var d = "pre_destroy";
  var m = [s, c, r2, i, a, o];
  var l = Symbol.for("@inversifyjs/core/InversifyCoreError");
  var _a2, _b;
  var f = class _f extends (_b = Error, _a2 = l, _b) {
    constructor(t3, e2, n) {
      super(e2, n);
      __publicField(this, _a2);
      __publicField(this, "kind");
      this[l] = true, this.kind = t3;
    }
    static is(t3) {
      return "object" == typeof t3 && null !== t3 && true === t3[l];
    }
    static isErrorOfKind(t3, e2) {
      return _f.is(t3) && t3.kind === e2;
    }
  };
  var g;
  var p;
  function h(t3, e2) {
    const n = [];
    for (let t4 = 0; t4 < e2.length; ++t4) {
      void 0 === e2[t4] && n.push(t4);
    }
    if (n.length > 0) throw new f(g.missingInjectionDecorator, `Found unexpected missing metadata on type "${t3.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  }
  function y(t3) {
    return { kind: p.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), targetName: void 0, value: t3 };
  }
  function v(t3) {
    const e2 = t3.find(((t4) => t4.key === s)), n = t3.find(((t4) => t4.key === c));
    if (void 0 !== t3.find(((t4) => t4.key === i))) return (function(t4, e3) {
      if (void 0 !== e3 || void 0 !== t4) throw new f(g.missingInjectionDecorator, "Expected a single @inject, @multiInject or @unmanaged metadata");
      return { kind: p.unmanaged };
    })(e2, n);
    if (void 0 === n && void 0 === e2) throw new f(g.missingInjectionDecorator, "Expected @inject, @multiInject or @unmanaged metadata");
    const u3 = t3.find(((t4) => t4.key === a)), d3 = t3.find(((t4) => t4.key === o)), l3 = t3.find(((t4) => t4.key === r2));
    return { kind: void 0 === e2 ? p.multipleInjection : p.singleInjection, name: u3 == null ? void 0 : u3.value, optional: void 0 !== d3, tags: new Map(t3.filter(((t4) => m.every(((e3) => t4.key !== e3)))).map(((t4) => [t4.key, t4.value]))), targetName: l3 == null ? void 0 : l3.value, value: void 0 === e2 ? n == null ? void 0 : n.value : e2.value };
  }
  function j(t3, e2, n) {
    try {
      return v(n);
    } catch (n2) {
      throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at constructor arguments at index "${e2.toString()}"`, { cause: n2 }) : n2;
    }
  }
  function k(e2) {
    const n = t2(e2, "design:paramtypes"), a3 = t2(e2, "inversify:tagged"), r3 = [];
    if (void 0 !== a3) for (const [t3, n2] of Object.entries(a3)) {
      const a4 = parseInt(t3);
      r3[a4] = j(e2, a4, n2);
    }
    if (void 0 !== n) {
      for (let t3 = 0; t3 < n.length; ++t3) if (void 0 === r3[t3]) {
        const e3 = n[t3];
        r3[t3] = y(e3);
      }
    }
    return h(e2, r3), r3;
  }
  function I(t3, e2, n) {
    try {
      return v(n);
    } catch (n2) {
      throw f.isErrorOfKind(n2, g.missingInjectionDecorator) ? new f(g.missingInjectionDecorator, `Expected a single @inject, @multiInject or @unmanaged decorator at type "${t3.name}" at property "${e2.toString()}"`, { cause: n2 }) : n2;
    }
  }
  function w(e2) {
    const n = t2(e2, "inversify:tagged_props"), a3 = /* @__PURE__ */ new Map();
    if (void 0 !== n) for (const t3 of Reflect.ownKeys(n)) {
      const r3 = n[t3];
      a3.set(t3, I(e2, t3, r3));
    }
    return a3;
  }
  function M(e2) {
    const n = t2(e2, u), a3 = t2(e2, d);
    return { constructorArguments: k(e2), lifecycle: { postConstructMethodName: n == null ? void 0 : n.value, preDestroyMethodName: a3 == null ? void 0 : a3.value }, properties: w(e2) };
  }
  function N(t3, e2) {
    const n = e2.getConstructorMetadata(t3), a3 = [];
    for (const [e3, r3] of Object.entries(n.userGeneratedMetadata)) {
      const n2 = parseInt(e3);
      a3[n2] = j(t3, n2, r3);
    }
    if (void 0 !== n.compilerGeneratedMetadata) {
      for (let t4 = 0; t4 < n.compilerGeneratedMetadata.length; ++t4) if (void 0 === a3[t4]) {
        const e3 = n.compilerGeneratedMetadata[t4];
        a3[t4] = y(e3);
      }
    }
    return h(t3, a3), a3;
  }
  function E(t3, e2) {
    const n = e2.getPropertiesMetadata(t3), a3 = /* @__PURE__ */ new Map();
    for (const e3 of Reflect.ownKeys(n)) {
      const r3 = n[e3];
      a3.set(e3, I(t3, e3, r3));
    }
    return a3;
  }
  function D(e2, n) {
    const a3 = t2(e2, u), r3 = t2(e2, d);
    return { constructorArguments: N(e2, n), lifecycle: { postConstructMethodName: a3 == null ? void 0 : a3.value, preDestroyMethodName: r3 == null ? void 0 : r3.value }, properties: E(e2, n) };
  }
  function b(t3) {
    const e2 = Object.getPrototypeOf(t3.prototype), n = e2 == null ? void 0 : e2.constructor;
    return n;
  }
  function O(t3) {
    return t3.kind === p.unmanaged ? [{ key: i, value: true }] : (function(t4) {
      const e2 = [A(t4)];
      void 0 !== t4.name && e2.push({ key: a, value: t4.name });
      t4.optional && e2.push({ key: o, value: true });
      for (const [n, a3] of t4.tags) e2.push({ key: n, value: a3 });
      void 0 !== t4.targetName && e2.push({ key: r2, value: t4.targetName });
      return e2;
    })(t3);
  }
  function A(t3) {
    let e2;
    switch (t3.kind) {
      case p.multipleInjection:
        e2 = { key: c, value: t3.value };
        break;
      case p.singleInjection:
        e2 = { key: s, value: t3.value };
    }
    return e2;
  }
  !(function(t3) {
    t3[t3.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", t3[t3.missingInjectionDecorator = 1] = "missingInjectionDecorator", t3[t3.planning = 2] = "planning", t3[t3.unknown = 3] = "unknown";
  })(g || (g = {})), (function(t3) {
    t3[t3.multipleInjection = 0] = "multipleInjection", t3[t3.singleInjection = 1] = "singleInjection", t3[t3.unmanaged = 2] = "unmanaged";
  })(p || (p = {}));
  var _t;
  var x = class {
    constructor(t3) {
      __privateAdd(this, _t);
      __privateSet(this, _t, t3);
    }
    startsWith(t3) {
      return __privateGet(this, _t).startsWith(t3);
    }
    endsWith(t3) {
      return __privateGet(this, _t).endsWith(t3);
    }
    contains(t3) {
      return __privateGet(this, _t).includes(t3);
    }
    equals(t3) {
      return __privateGet(this, _t) === t3;
    }
    value() {
      return __privateGet(this, _t);
    }
  };
  _t = new WeakMap();
  var C = "@inversifyjs/core/targetId";
  var _e2, _n, _a3, _r, _i, _o;
  var T = class {
    constructor(n, a3, r3) {
      __privateAdd(this, _e2);
      __privateAdd(this, _n);
      __privateAdd(this, _a3);
      __privateAdd(this, _r);
      __privateAdd(this, _i);
      __privateAdd(this, _o);
      __privateSet(this, _n, (function() {
        var _a4;
        const n2 = (_a4 = t2(Object, C)) != null ? _a4 : 0;
        return n2 === Number.MAX_SAFE_INTEGER ? e(Object, C, n2, (() => Number.MIN_SAFE_INTEGER)) : e(Object, C, n2, ((t3) => t3 + 1)), n2;
      })()), __privateSet(this, _a3, n), __privateSet(this, _r, void 0), __privateSet(this, _e2, a3), __privateSet(this, _i, new x("string" == typeof n ? n : n.toString().slice(7, -1))), __privateSet(this, _o, r3);
    }
    get id() {
      return __privateGet(this, _n);
    }
    get identifier() {
      return __privateGet(this, _a3);
    }
    get metadata() {
      return void 0 === __privateGet(this, _r) && __privateSet(this, _r, O(__privateGet(this, _e2))), __privateGet(this, _r);
    }
    get name() {
      return __privateGet(this, _i);
    }
    get type() {
      return __privateGet(this, _o);
    }
    get serviceIdentifier() {
      return r.is(__privateGet(this, _e2).value) ? __privateGet(this, _e2).value.unwrap() : __privateGet(this, _e2).value;
    }
    getCustomTags() {
      return [...__privateGet(this, _e2).tags.entries()].map((([t3, e2]) => ({ key: t3, value: e2 })));
    }
    getNamedTag() {
      return void 0 === __privateGet(this, _e2).name ? null : { key: a, value: __privateGet(this, _e2).name };
    }
    hasTag(t3) {
      return this.metadata.some(((e2) => e2.key === t3));
    }
    isArray() {
      return __privateGet(this, _e2).kind === p.multipleInjection;
    }
    isNamed() {
      return void 0 !== __privateGet(this, _e2).name;
    }
    isOptional() {
      return __privateGet(this, _e2).optional;
    }
    isTagged() {
      return __privateGet(this, _e2).tags.size > 0;
    }
    matchesArray(t3) {
      return this.isArray() && __privateGet(this, _e2).value === t3;
    }
    matchesNamedTag(t3) {
      return __privateGet(this, _e2).name === t3;
    }
    matchesTag(t3) {
      return (e2) => this.metadata.some(((n) => n.key === t3 && n.value === e2));
    }
  };
  _e2 = new WeakMap();
  _n = new WeakMap();
  _a3 = new WeakMap();
  _r = new WeakMap();
  _i = new WeakMap();
  _o = new WeakMap();
  var _ = (t3) => /* @__PURE__ */ (function(t4, e2) {
    return function(n) {
      var _a4, _b2;
      const a3 = t4(n);
      let r3 = b(n);
      for (; void 0 !== r3 && r3 !== Object; ) {
        const t5 = e2(r3);
        for (const [e3, n2] of t5) a3.properties.has(e3) || a3.properties.set(e3, n2);
        r3 = b(r3);
      }
      const i2 = [];
      for (const t5 of a3.constructorArguments) if (t5.kind !== p.unmanaged) {
        const e3 = (_a4 = t5.targetName) != null ? _a4 : "";
        i2.push(new T(e3, t5, "ConstructorArgument"));
      }
      for (const [t5, e3] of a3.properties) if (e3.kind !== p.unmanaged) {
        const n2 = (_b2 = e3.targetName) != null ? _b2 : t5;
        i2.push(new T(n2, e3, "ClassProperty"));
      }
      return i2;
    };
  })(void 0 === t3 ? M : (e2) => D(e2, t3), void 0 === t3 ? w : (e2) => E(e2, t3));

  // ../../node_modules/inversify/lib/esm/index.js
  var s2 = "named";
  var o2 = "name";
  var a2 = "unmanaged";
  var c2 = "optional";
  var d2 = "inject";
  var u2 = "multi_inject";
  var h2 = "inversify:tagged";
  var l2 = "inversify:tagged_props";
  var g2 = "inversify:paramtypes";
  var y2 = "design:paramtypes";
  var p2 = "post_construct";
  var f2 = "pre_destroy";
  var _2 = [d2, u2, o2, a2, s2, c2];
  var v2 = Object.freeze({ __proto__: null, DESIGN_PARAM_TYPES: y2, INJECT_TAG: d2, MULTI_INJECT_TAG: u2, NAMED_TAG: s2, NAME_TAG: o2, NON_CUSTOM_TAG_KEYS: _2, OPTIONAL_TAG: c2, PARAM_TYPES: g2, POST_CONSTRUCT: p2, PRE_DESTROY: f2, TAGGED: h2, TAGGED_PROP: l2, UNMANAGED_TAG: a2 });
  var b2 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
  var w2 = { ConstantValue: "ConstantValue", Constructor: "Constructor", DynamicValue: "DynamicValue", Factory: "Factory", Function: "Function", Instance: "Instance", Invalid: "Invalid", Provider: "Provider" };
  var m2 = { ClassProperty: "ClassProperty", ConstructorArgument: "ConstructorArgument", Variable: "Variable" };
  var A2 = 0;
  function S() {
    return A2++;
  }
  var I2 = class _I {
    constructor(t3, n) {
      __publicField(this, "id");
      __publicField(this, "moduleId");
      __publicField(this, "activated");
      __publicField(this, "serviceIdentifier");
      __publicField(this, "implementationType");
      __publicField(this, "cache");
      __publicField(this, "dynamicValue");
      __publicField(this, "scope");
      __publicField(this, "type");
      __publicField(this, "factory");
      __publicField(this, "provider");
      __publicField(this, "constraint");
      __publicField(this, "onActivation");
      __publicField(this, "onDeactivation");
      this.id = S(), this.activated = false, this.serviceIdentifier = t3, this.scope = n, this.type = w2.Invalid, this.constraint = (t4) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
    }
    clone() {
      const t3 = new _I(this.serviceIdentifier, this.scope);
      return t3.activated = t3.scope === b2.Singleton && this.activated, t3.implementationType = this.implementationType, t3.dynamicValue = this.dynamicValue, t3.scope = this.scope, t3.type = this.type, t3.factory = this.factory, t3.provider = this.provider, t3.constraint = this.constraint, t3.onActivation = this.onActivation, t3.onDeactivation = this.onDeactivation, t3.cache = this.cache, t3;
    }
  };
  var T2 = "Metadata key was used more than once in a parameter:";
  var D2 = "NULL argument";
  var N2 = "Key Not Found";
  var C2 = "Ambiguous match found for serviceIdentifier:";
  var x2 = "No matching bindings found for serviceIdentifier:";
  var R = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
  var E2 = (t3, n) => `onDeactivation() error in class ${t3}: ${n}`;
  var M2 = class {
    getConstructorMetadata(t3) {
      var _a4, _b2;
      return { compilerGeneratedMetadata: (_a4 = Reflect.getMetadata(y2, t3)) != null ? _a4 : [], userGeneratedMetadata: (_b2 = Reflect.getMetadata(h2, t3)) != null ? _b2 : {} };
    }
    getPropertiesMetadata(t3) {
      var _a4;
      return (_a4 = Reflect.getMetadata(l2, t3)) != null ? _a4 : {};
    }
  };
  var B;
  function P(t3) {
    return t3 instanceof RangeError || "Maximum call stack size exceeded" === t3.message;
  }
  !(function(t3) {
    t3[t3.MultipleBindingsAvailable = 2] = "MultipleBindingsAvailable", t3[t3.NoBindingsAvailable = 0] = "NoBindingsAvailable", t3[t3.OnlyOneBindingAvailable = 1] = "OnlyOneBindingAvailable";
  })(B || (B = {}));
  function k2(t3) {
    return "function" == typeof t3 ? t3.name : "symbol" == typeof t3 ? t3.toString() : t3;
  }
  function q(t3, n, e2) {
    let i2 = "";
    const r3 = e2(t3, n);
    return 0 !== r3.length && (i2 = "\nRegistered bindings:", r3.forEach(((t4) => {
      let n2 = "Object";
      null !== t4.implementationType && (n2 = O2(t4.implementationType)), i2 = `${i2}
 ${n2}`, t4.constraint.metaData && (i2 = `${i2} - ${t4.constraint.metaData}`);
    }))), i2;
  }
  function F(t3, n) {
    return null !== t3.parentRequest && (t3.parentRequest.serviceIdentifier === n || F(t3.parentRequest, n));
  }
  function j2(t3) {
    t3.childRequests.forEach(((n) => {
      if (F(t3, n.serviceIdentifier)) {
        const t4 = (function(t5) {
          const n2 = (function t6(n3, e2 = []) {
            const i2 = k2(n3.serviceIdentifier);
            return e2.push(i2), null !== n3.parentRequest ? t6(n3.parentRequest, e2) : e2;
          })(t5);
          return n2.reverse().join(" --> ");
        })(n);
        throw new Error(`Circular dependency found: ${t4}`);
      }
      j2(n);
    }));
  }
  function O2(t3) {
    if (null != t3.name && "" !== t3.name) return t3.name;
    {
      const n = t3.toString(), e2 = n.match(/^function\s*([^\s(]+)/);
      return null === e2 ? `Anonymous function: ${n}` : e2[1];
    }
  }
  function $(t3) {
    return `{"key":"${t3.key.toString()}","value":"${t3.value.toString()}"}`;
  }
  var V = class {
    constructor(t3) {
      __publicField(this, "id");
      __publicField(this, "container");
      __publicField(this, "plan");
      __publicField(this, "currentRequest");
      this.id = S(), this.container = t3;
    }
    addPlan(t3) {
      this.plan = t3;
    }
    setCurrentRequest(t3) {
      this.currentRequest = t3;
    }
  };
  var W = class {
    constructor(t3, n) {
      __publicField(this, "key");
      __publicField(this, "value");
      this.key = t3, this.value = n;
    }
    toString() {
      return this.key === s2 ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
    }
  };
  var G = class {
    constructor(t3, n) {
      __publicField(this, "parentContext");
      __publicField(this, "rootRequest");
      this.parentContext = t3, this.rootRequest = n;
    }
  };
  function K(t3, e2) {
    const i2 = (function(t4) {
      const n = Object.getPrototypeOf(t4.prototype), e3 = n == null ? void 0 : n.constructor;
      return e3;
    })(e2);
    if (void 0 === i2 || i2 === Object) return 0;
    const r3 = _(t3)(i2), s3 = r3.map(((t4) => t4.metadata.filter(((t5) => t5.key === a2)))), o3 = [].concat.apply([], s3).length, c3 = r3.length - o3;
    return c3 > 0 ? c3 : K(t3, i2);
  }
  var H = class _H {
    constructor(t3, n, e2, i2, r3) {
      __publicField(this, "id");
      __publicField(this, "serviceIdentifier");
      __publicField(this, "parentContext");
      __publicField(this, "parentRequest");
      __publicField(this, "bindings");
      __publicField(this, "childRequests");
      __publicField(this, "target");
      __publicField(this, "requestScope");
      this.id = S(), this.serviceIdentifier = t3, this.parentContext = n, this.parentRequest = e2, this.target = r3, this.childRequests = [], this.bindings = Array.isArray(i2) ? i2 : [i2], this.requestScope = null === e2 ? /* @__PURE__ */ new Map() : null;
    }
    addChildRequest(t3, n, e2) {
      const i2 = new _H(t3, this.parentContext, this, n, e2);
      return this.childRequests.push(i2), i2;
    }
  };
  function U(t3) {
    return t3._bindingDictionary;
  }
  function L(t3, n, e2, i2, r3) {
    let s3 = J(e2.container, r3.serviceIdentifier), o3 = [];
    return s3.length === B.NoBindingsAvailable && true === e2.container.options.autoBindInjectable && "function" == typeof r3.serviceIdentifier && t3.getConstructorMetadata(r3.serviceIdentifier).compilerGeneratedMetadata && (e2.container.bind(r3.serviceIdentifier).toSelf(), s3 = J(e2.container, r3.serviceIdentifier)), o3 = n ? s3 : s3.filter(((t4) => {
      const n2 = new H(t4.serviceIdentifier, e2, i2, t4, r3);
      return t4.constraint(n2);
    })), (function(t4, n2, e3, i3, r4) {
      switch (n2.length) {
        case B.NoBindingsAvailable:
          if (i3.isOptional()) return n2;
          {
            const n3 = k2(t4);
            let s4 = x2;
            throw s4 += (function(t5, n4) {
              if (n4.isTagged() || n4.isNamed()) {
                let e4 = "";
                const i4 = n4.getNamedTag(), r5 = n4.getCustomTags();
                return null !== i4 && (e4 += $(i4) + "\n"), null !== r5 && r5.forEach(((t6) => {
                  e4 += $(t6) + "\n";
                })), ` ${t5}
 ${t5} - ${e4}`;
              }
              return ` ${t5}`;
            })(n3, i3), s4 += q(r4, n3, J), null !== e3 && (s4 += `
Trying to resolve bindings for "${k2(e3.serviceIdentifier)}"`), new Error(s4);
          }
        case B.OnlyOneBindingAvailable:
          return n2;
        case B.MultipleBindingsAvailable:
        default:
          if (i3.isArray()) return n2;
          {
            const n3 = k2(t4);
            let e4 = `${C2} ${n3}`;
            throw e4 += q(r4, n3, J), new Error(e4);
          }
      }
    })(r3.serviceIdentifier, o3, i2, r3, e2.container), o3;
  }
  function Y(t3, n) {
    const e2 = n.isMultiInject ? u2 : d2, i2 = [new W(e2, t3)];
    return void 0 !== n.customTag && i2.push(new W(n.customTag.key, n.customTag.value)), true === n.isOptional && i2.push(new W(c2, true)), i2;
  }
  function z(t3, e2, i2, r3, s3, o3) {
    let a3, c3;
    if (null === s3) {
      a3 = L(t3, e2, r3, null, o3), c3 = new H(i2, r3, null, a3, o3);
      const n = new G(r3, c3);
      r3.addPlan(n);
    } else a3 = L(t3, e2, r3, s3, o3), c3 = s3.addChildRequest(o3.serviceIdentifier, a3, o3);
    a3.forEach(((e3) => {
      let i3 = null;
      if (o3.isArray()) i3 = c3.addChildRequest(e3.serviceIdentifier, e3, o3);
      else {
        if (null !== e3.cache) return;
        i3 = c3;
      }
      if (e3.type === w2.Instance && null !== e3.implementationType) {
        const s4 = (function(t4, e4) {
          return _(t4)(e4);
        })(t3, e3.implementationType);
        if (true !== r3.container.options.skipBaseClassChecks) {
          const n = K(t3, e3.implementationType);
          if (s4.length < n) {
            const t4 = `The number of constructor arguments in the derived class ${O2(e3.implementationType)} must be >= than the number of constructor arguments of its base class.`;
            throw new Error(t4);
          }
        }
        s4.forEach(((n) => {
          z(t3, false, n.serviceIdentifier, r3, i3, n);
        }));
      }
    }));
  }
  function J(t3, n) {
    let e2 = [];
    const i2 = U(t3);
    return i2.hasKey(n) ? e2 = i2.get(n) : null !== t3.parent && (e2 = J(t3.parent, n)), e2;
  }
  function Q(t3, n, s3, o3, a3, c3 = false) {
    const d3 = new V(n), u3 = (function(t4, n2, s4) {
      const o4 = Y(n2, s4), a4 = v(o4);
      if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
      return new T("", a4, t4);
    })(s3, o3, a3);
    try {
      return z(t3, c3, o3, d3, null, u3), d3;
    } catch (t4) {
      throw P(t4) && j2(d3.plan.rootRequest), t4;
    }
  }
  function X(t3) {
    return ("object" == typeof t3 && null !== t3 || "function" == typeof t3) && "function" == typeof t3.then;
  }
  function Z(t3) {
    return !!X(t3) || Array.isArray(t3) && t3.some(X);
  }
  var tt = (t3, n, e2) => {
    t3.has(n.id) || t3.set(n.id, e2);
  };
  var nt = (t3, n) => {
    t3.cache = n, t3.activated = true, X(n) && et(t3, n);
  };
  var et = async (t3, n) => {
    try {
      const e2 = await n;
      t3.cache = e2;
    } catch (n2) {
      throw t3.cache = null, t3.activated = false, n2;
    }
  };
  var it;
  !(function(t3) {
    t3.DynamicValue = "toDynamicValue", t3.Factory = "toFactory", t3.Provider = "toProvider";
  })(it || (it = {}));
  function st(t3, n, e2) {
    let i2;
    if (n.length > 0) {
      const r3 = (function(t4, n2) {
        return t4.reduce(((t5, e3) => {
          const i3 = n2(e3);
          return e3.target.type === m2.ConstructorArgument ? t5.constructorInjections.push(i3) : (t5.propertyRequests.push(e3), t5.propertyInjections.push(i3)), t5.isAsync || (t5.isAsync = Z(i3)), t5;
        }), { constructorInjections: [], isAsync: false, propertyInjections: [], propertyRequests: [] });
      })(n, e2), s3 = __spreadProps(__spreadValues({}, r3), { constr: t3 });
      i2 = r3.isAsync ? (async function(t4) {
        const n2 = await at(t4.constructorInjections), e3 = await at(t4.propertyInjections);
        return ot(__spreadProps(__spreadValues({}, t4), { constructorInjections: n2, propertyInjections: e3 }));
      })(s3) : ot(s3);
    } else i2 = new t3();
    return i2;
  }
  function ot(t3) {
    const n = new t3.constr(...t3.constructorInjections);
    return t3.propertyRequests.forEach(((e2, i2) => {
      const r3 = e2.target.identifier, s3 = t3.propertyInjections[i2];
      e2.target.isOptional() && void 0 === s3 || (n[r3] = s3);
    })), n;
  }
  async function at(t3) {
    const n = [];
    for (const e2 of t3) Array.isArray(e2) ? n.push(Promise.all(e2)) : n.push(e2);
    return Promise.all(n);
  }
  function ct(t3, n) {
    const e2 = (function(t4, n2) {
      var _a4;
      if (Reflect.hasMetadata(p2, t4)) {
        const r3 = Reflect.getMetadata(p2, t4);
        try {
          return (_a4 = n2[r3.value]) == null ? void 0 : _a4.call(n2);
        } catch (n3) {
          if (n3 instanceof Error) throw new Error((e3 = t4.name, i2 = n3.message, `@postConstruct error in class ${e3}: ${i2}`));
        }
      }
      var e3, i2;
    })(t3, n);
    return X(e2) ? e2.then((() => n)) : n;
  }
  function dt(t3, n) {
    t3.scope !== b2.Singleton && (function(t4, n2) {
      const e2 = `Class cannot be instantiated in ${t4.scope === b2.Request ? "request" : "transient"} scope.`;
      if ("function" == typeof t4.onDeactivation) throw new Error(E2(n2.name, e2));
      if (Reflect.hasMetadata(f2, n2)) throw new Error(`@preDestroy error in class ${n2.name}: ${e2}`);
    })(t3, n);
  }
  var ut = (t3) => (n) => {
    n.parentContext.setCurrentRequest(n);
    const e2 = n.bindings, i2 = n.childRequests, r3 = n.target && n.target.isArray(), s3 = !(n.parentRequest && n.parentRequest.target && n.target && n.parentRequest.target.matchesArray(n.target.serviceIdentifier));
    if (r3 && s3) return i2.map(((n2) => ut(t3)(n2)));
    {
      if (n.target.isOptional() && 0 === e2.length) return;
      const i3 = e2[0];
      return yt(t3, n, i3);
    }
  };
  var ht = (t3, n) => {
    const e2 = ((t4) => {
      switch (t4.type) {
        case w2.Factory:
          return { factory: t4.factory, factoryType: it.Factory };
        case w2.Provider:
          return { factory: t4.provider, factoryType: it.Provider };
        case w2.DynamicValue:
          return { factory: t4.dynamicValue, factoryType: it.DynamicValue };
        default:
          throw new Error(`Unexpected factory type ${t4.type}`);
      }
    })(t3);
    return ((t4, n2) => {
      try {
        return t4();
      } catch (t5) {
        if (P(t5)) throw n2();
        throw t5;
      }
    })((() => e2.factory.bind(t3)(n)), (() => {
      return new Error((t4 = e2.factoryType, i2 = n.currentRequest.serviceIdentifier.toString(), `It looks like there is a circular dependency in one of the '${t4}' bindings. Please investigate bindings with service identifier '${i2}'.`));
      var t4, i2;
    }));
  };
  var lt = (t3, n, e2) => {
    let i2;
    const r3 = n.childRequests;
    switch (((t4) => {
      let n2 = null;
      switch (t4.type) {
        case w2.ConstantValue:
        case w2.Function:
          n2 = t4.cache;
          break;
        case w2.Constructor:
        case w2.Instance:
          n2 = t4.implementationType;
          break;
        case w2.DynamicValue:
          n2 = t4.dynamicValue;
          break;
        case w2.Provider:
          n2 = t4.provider;
          break;
        case w2.Factory:
          n2 = t4.factory;
      }
      if (null === n2) {
        const n3 = k2(t4.serviceIdentifier);
        throw new Error(`Invalid binding type: ${n3}`);
      }
    })(e2), e2.type) {
      case w2.ConstantValue:
      case w2.Function:
        i2 = e2.cache;
        break;
      case w2.Constructor:
        i2 = e2.implementationType;
        break;
      case w2.Instance:
        i2 = (function(t4, n2, e3, i3) {
          dt(t4, n2);
          const r4 = st(n2, e3, i3);
          return X(r4) ? r4.then(((t5) => ct(n2, t5))) : ct(n2, r4);
        })(e2, e2.implementationType, r3, ut(t3));
        break;
      default:
        i2 = ht(e2, n.parentContext);
    }
    return i2;
  };
  var gt = (t3, n, e2) => {
    let i2 = ((t4, n2) => n2.scope === b2.Singleton && n2.activated ? n2.cache : n2.scope === b2.Request && t4.has(n2.id) ? t4.get(n2.id) : null)(t3, n);
    return null !== i2 || (i2 = e2(), ((t4, n2, e3) => {
      n2.scope === b2.Singleton && nt(n2, e3), n2.scope === b2.Request && tt(t4, n2, e3);
    })(t3, n, i2)), i2;
  };
  var yt = (t3, n, e2) => gt(t3, e2, (() => {
    let i2 = lt(t3, n, e2);
    return i2 = X(i2) ? i2.then(((t4) => pt(n, e2, t4))) : pt(n, e2, i2), i2;
  }));
  function pt(t3, n, e2) {
    let i2 = ft(t3.parentContext, n, e2);
    const r3 = wt(t3.parentContext.container);
    let s3, o3 = r3.next();
    do {
      s3 = o3.value;
      const n2 = t3.parentContext, e3 = t3.serviceIdentifier, a3 = bt(s3, e3);
      i2 = X(i2) ? vt(a3, n2, i2) : _t2(a3, n2, i2), o3 = r3.next();
    } while (true !== o3.done && !U(s3).hasKey(t3.serviceIdentifier));
    return i2;
  }
  var ft = (t3, n, e2) => {
    let i2;
    return i2 = "function" == typeof n.onActivation ? n.onActivation(t3, e2) : e2, i2;
  };
  var _t2 = (t3, n, e2) => {
    let i2 = t3.next();
    for (; true !== i2.done; ) {
      if (X(e2 = i2.value(n, e2))) return vt(t3, n, e2);
      i2 = t3.next();
    }
    return e2;
  };
  var vt = async (t3, n, e2) => {
    let i2 = await e2, r3 = t3.next();
    for (; true !== r3.done; ) i2 = await r3.value(n, i2), r3 = t3.next();
    return i2;
  };
  var bt = (t3, n) => {
    const e2 = t3._activations;
    return e2.hasKey(n) ? e2.get(n).values() : [].values();
  };
  var wt = (t3) => {
    const n = [t3];
    let e2 = t3.parent;
    for (; null !== e2; ) n.push(e2), e2 = e2.parent;
    return { next: () => {
      const t4 = n.pop();
      return void 0 !== t4 ? { done: false, value: t4 } : { done: true, value: void 0 };
    } };
  };
  var mt = (t3, n) => {
    const e2 = t3.parentRequest;
    return null !== e2 && (!!n(e2) || mt(e2, n));
  };
  var At = (t3) => (n) => {
    const e2 = (e3) => null !== e3 && null !== e3.target && e3.target.matchesTag(t3)(n);
    return e2.metaData = new W(t3, n), e2;
  };
  var St = At(s2);
  var It = (t3) => (n) => {
    let e2 = null;
    if (null !== n) {
      if (e2 = n.bindings[0], "string" == typeof t3) return e2.serviceIdentifier === t3;
      {
        const e3 = n.bindings[0].implementationType;
        return t3 === e3;
      }
    }
    return false;
  };
  var Tt = class {
    constructor(t3) {
      __publicField(this, "_binding");
      this._binding = t3;
    }
    when(t3) {
      return this._binding.constraint = t3, new Dt(this._binding);
    }
    whenTargetNamed(t3) {
      return this._binding.constraint = St(t3), new Dt(this._binding);
    }
    whenTargetIsDefault() {
      return this._binding.constraint = (t3) => {
        if (null === t3) return false;
        return null !== t3.target && !t3.target.isNamed() && !t3.target.isTagged();
      }, new Dt(this._binding);
    }
    whenTargetTagged(t3, n) {
      return this._binding.constraint = At(t3)(n), new Dt(this._binding);
    }
    whenInjectedInto(t3) {
      return this._binding.constraint = (n) => null !== n && It(t3)(n.parentRequest), new Dt(this._binding);
    }
    whenParentNamed(t3) {
      return this._binding.constraint = (n) => null !== n && St(t3)(n.parentRequest), new Dt(this._binding);
    }
    whenParentTagged(t3, n) {
      return this._binding.constraint = (e2) => null !== e2 && At(t3)(n)(e2.parentRequest), new Dt(this._binding);
    }
    whenAnyAncestorIs(t3) {
      return this._binding.constraint = (n) => null !== n && mt(n, It(t3)), new Dt(this._binding);
    }
    whenNoAncestorIs(t3) {
      return this._binding.constraint = (n) => null !== n && !mt(n, It(t3)), new Dt(this._binding);
    }
    whenAnyAncestorNamed(t3) {
      return this._binding.constraint = (n) => null !== n && mt(n, St(t3)), new Dt(this._binding);
    }
    whenNoAncestorNamed(t3) {
      return this._binding.constraint = (n) => null !== n && !mt(n, St(t3)), new Dt(this._binding);
    }
    whenAnyAncestorTagged(t3, n) {
      return this._binding.constraint = (e2) => null !== e2 && mt(e2, At(t3)(n)), new Dt(this._binding);
    }
    whenNoAncestorTagged(t3, n) {
      return this._binding.constraint = (e2) => null !== e2 && !mt(e2, At(t3)(n)), new Dt(this._binding);
    }
    whenAnyAncestorMatches(t3) {
      return this._binding.constraint = (n) => null !== n && mt(n, t3), new Dt(this._binding);
    }
    whenNoAncestorMatches(t3) {
      return this._binding.constraint = (n) => null !== n && !mt(n, t3), new Dt(this._binding);
    }
  };
  var Dt = class {
    constructor(t3) {
      __publicField(this, "_binding");
      this._binding = t3;
    }
    onActivation(t3) {
      return this._binding.onActivation = t3, new Tt(this._binding);
    }
    onDeactivation(t3) {
      return this._binding.onDeactivation = t3, new Tt(this._binding);
    }
  };
  var Nt = class {
    constructor(t3) {
      __publicField(this, "_bindingWhenSyntax");
      __publicField(this, "_bindingOnSyntax");
      __publicField(this, "_binding");
      this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding);
    }
    when(t3) {
      return this._bindingWhenSyntax.when(t3);
    }
    whenTargetNamed(t3) {
      return this._bindingWhenSyntax.whenTargetNamed(t3);
    }
    whenTargetIsDefault() {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    }
    whenTargetTagged(t3, n) {
      return this._bindingWhenSyntax.whenTargetTagged(t3, n);
    }
    whenInjectedInto(t3) {
      return this._bindingWhenSyntax.whenInjectedInto(t3);
    }
    whenParentNamed(t3) {
      return this._bindingWhenSyntax.whenParentNamed(t3);
    }
    whenParentTagged(t3, n) {
      return this._bindingWhenSyntax.whenParentTagged(t3, n);
    }
    whenAnyAncestorIs(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
    }
    whenNoAncestorIs(t3) {
      return this._bindingWhenSyntax.whenNoAncestorIs(t3);
    }
    whenAnyAncestorNamed(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
    }
    whenAnyAncestorTagged(t3, n) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
    }
    whenNoAncestorNamed(t3) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
    }
    whenNoAncestorTagged(t3, n) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
    }
    whenAnyAncestorMatches(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
    }
    whenNoAncestorMatches(t3) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
    }
    onActivation(t3) {
      return this._bindingOnSyntax.onActivation(t3);
    }
    onDeactivation(t3) {
      return this._bindingOnSyntax.onDeactivation(t3);
    }
  };
  var Ct = class {
    constructor(t3) {
      __publicField(this, "_binding");
      this._binding = t3;
    }
    inRequestScope() {
      return this._binding.scope = b2.Request, new Nt(this._binding);
    }
    inSingletonScope() {
      return this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    inTransientScope() {
      return this._binding.scope = b2.Transient, new Nt(this._binding);
    }
  };
  var xt = class {
    constructor(t3) {
      __publicField(this, "_bindingInSyntax");
      __publicField(this, "_bindingWhenSyntax");
      __publicField(this, "_bindingOnSyntax");
      __publicField(this, "_binding");
      this._binding = t3, this._bindingWhenSyntax = new Tt(this._binding), this._bindingOnSyntax = new Dt(this._binding), this._bindingInSyntax = new Ct(t3);
    }
    inRequestScope() {
      return this._bindingInSyntax.inRequestScope();
    }
    inSingletonScope() {
      return this._bindingInSyntax.inSingletonScope();
    }
    inTransientScope() {
      return this._bindingInSyntax.inTransientScope();
    }
    when(t3) {
      return this._bindingWhenSyntax.when(t3);
    }
    whenTargetNamed(t3) {
      return this._bindingWhenSyntax.whenTargetNamed(t3);
    }
    whenTargetIsDefault() {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    }
    whenTargetTagged(t3, n) {
      return this._bindingWhenSyntax.whenTargetTagged(t3, n);
    }
    whenInjectedInto(t3) {
      return this._bindingWhenSyntax.whenInjectedInto(t3);
    }
    whenParentNamed(t3) {
      return this._bindingWhenSyntax.whenParentNamed(t3);
    }
    whenParentTagged(t3, n) {
      return this._bindingWhenSyntax.whenParentTagged(t3, n);
    }
    whenAnyAncestorIs(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(t3);
    }
    whenNoAncestorIs(t3) {
      return this._bindingWhenSyntax.whenNoAncestorIs(t3);
    }
    whenAnyAncestorNamed(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(t3);
    }
    whenAnyAncestorTagged(t3, n) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(t3, n);
    }
    whenNoAncestorNamed(t3) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(t3);
    }
    whenNoAncestorTagged(t3, n) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(t3, n);
    }
    whenAnyAncestorMatches(t3) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(t3);
    }
    whenNoAncestorMatches(t3) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(t3);
    }
    onActivation(t3) {
      return this._bindingOnSyntax.onActivation(t3);
    }
    onDeactivation(t3) {
      return this._bindingOnSyntax.onDeactivation(t3);
    }
  };
  var Rt = class {
    constructor(t3) {
      __publicField(this, "_binding");
      this._binding = t3;
    }
    to(t3) {
      return this._binding.type = w2.Instance, this._binding.implementationType = t3, new xt(this._binding);
    }
    toSelf() {
      if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
      const t3 = this._binding.serviceIdentifier;
      return this.to(t3);
    }
    toConstantValue(t3) {
      return this._binding.type = w2.ConstantValue, this._binding.cache = t3, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    toDynamicValue(t3) {
      return this._binding.type = w2.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = t3, this._binding.implementationType = null, new xt(this._binding);
    }
    toConstructor(t3) {
      return this._binding.type = w2.Constructor, this._binding.implementationType = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    toFactory(t3) {
      return this._binding.type = w2.Factory, this._binding.factory = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    toFunction(t3) {
      if ("function" != typeof t3) throw new Error("Value provided to function binding must be a function!");
      const n = this.toConstantValue(t3);
      return this._binding.type = w2.Function, this._binding.scope = b2.Singleton, n;
    }
    toAutoFactory(t3) {
      return this._binding.type = w2.Factory, this._binding.factory = (n) => () => n.container.get(t3), this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    toAutoNamedFactory(t3) {
      return this._binding.type = w2.Factory, this._binding.factory = (n) => (e2) => n.container.getNamed(t3, e2), new Nt(this._binding);
    }
    toProvider(t3) {
      return this._binding.type = w2.Provider, this._binding.provider = t3, this._binding.scope = b2.Singleton, new Nt(this._binding);
    }
    toService(t3) {
      this._binding.type = w2.DynamicValue, Object.defineProperty(this._binding, "cache", { configurable: true, enumerable: true, get: () => null, set(t4) {
      } }), this._binding.dynamicValue = (n) => {
        try {
          return n.container.get(t3);
        } catch (e2) {
          return n.container.getAsync(t3);
        }
      }, this._binding.implementationType = null;
    }
  };
  var Et = class _Et {
    constructor() {
      __publicField(this, "bindings");
      __publicField(this, "activations");
      __publicField(this, "deactivations");
      __publicField(this, "middleware");
      __publicField(this, "moduleActivationStore");
    }
    static of(t3, n, e2, i2, r3) {
      const s3 = new _Et();
      return s3.bindings = t3, s3.middleware = n, s3.deactivations = i2, s3.activations = e2, s3.moduleActivationStore = r3, s3;
    }
  };
  var Mt = class _Mt {
    constructor() {
      __publicField(this, "_map");
      this._map = /* @__PURE__ */ new Map();
    }
    getMap() {
      return this._map;
    }
    add(t3, n) {
      if (this._checkNonNulish(t3), null == n) throw new Error(D2);
      const e2 = this._map.get(t3);
      void 0 !== e2 ? e2.push(n) : this._map.set(t3, [n]);
    }
    get(t3) {
      this._checkNonNulish(t3);
      const n = this._map.get(t3);
      if (void 0 !== n) return n;
      throw new Error(N2);
    }
    remove(t3) {
      if (this._checkNonNulish(t3), !this._map.delete(t3)) throw new Error(N2);
    }
    removeIntersection(t3) {
      this.traverse(((n, e2) => {
        const i2 = t3.hasKey(n) ? t3.get(n) : void 0;
        if (void 0 !== i2) {
          const t4 = e2.filter(((t5) => !i2.some(((n2) => t5 === n2))));
          this._setValue(n, t4);
        }
      }));
    }
    removeByCondition(t3) {
      const n = [];
      return this._map.forEach(((e2, i2) => {
        const r3 = [];
        for (const i3 of e2) {
          t3(i3) ? n.push(i3) : r3.push(i3);
        }
        this._setValue(i2, r3);
      })), n;
    }
    hasKey(t3) {
      return this._checkNonNulish(t3), this._map.has(t3);
    }
    clone() {
      const t3 = new _Mt();
      return this._map.forEach(((n, e2) => {
        n.forEach(((n2) => {
          var i2;
          t3.add(e2, "object" == typeof (i2 = n2) && null !== i2 && "clone" in i2 && "function" == typeof i2.clone ? n2.clone() : n2);
        }));
      })), t3;
    }
    traverse(t3) {
      this._map.forEach(((n, e2) => {
        t3(e2, n);
      }));
    }
    _checkNonNulish(t3) {
      if (null == t3) throw new Error(D2);
    }
    _setValue(t3, n) {
      n.length > 0 ? this._map.set(t3, n) : this._map.delete(t3);
    }
  };
  var Bt = class _Bt {
    constructor() {
      __publicField(this, "_map", /* @__PURE__ */ new Map());
    }
    remove(t3) {
      const n = this._map.get(t3);
      return void 0 === n ? this._getEmptyHandlersStore() : (this._map.delete(t3), n);
    }
    addDeactivation(t3, n, e2) {
      this._getModuleActivationHandlers(t3).onDeactivations.add(n, e2);
    }
    addActivation(t3, n, e2) {
      this._getModuleActivationHandlers(t3).onActivations.add(n, e2);
    }
    clone() {
      const t3 = new _Bt();
      return this._map.forEach(((n, e2) => {
        t3._map.set(e2, { onActivations: n.onActivations.clone(), onDeactivations: n.onDeactivations.clone() });
      })), t3;
    }
    _getModuleActivationHandlers(t3) {
      let n = this._map.get(t3);
      return void 0 === n && (n = this._getEmptyHandlersStore(), this._map.set(t3, n)), n;
    }
    _getEmptyHandlersStore() {
      return { onActivations: new Mt(), onDeactivations: new Mt() };
    }
  };
  var Pt = class _Pt {
    constructor(t3) {
      __publicField(this, "id");
      __publicField(this, "parent");
      __publicField(this, "options");
      __publicField(this, "_middleware");
      __publicField(this, "_bindingDictionary");
      __publicField(this, "_activations");
      __publicField(this, "_deactivations");
      __publicField(this, "_snapshots");
      __publicField(this, "_metadataReader");
      __publicField(this, "_moduleActivationStore");
      const n = t3 || {};
      if ("object" != typeof n) throw new Error("Invalid Container constructor argument. Container options must be an object.");
      if (void 0 === n.defaultScope) n.defaultScope = b2.Transient;
      else if (n.defaultScope !== b2.Singleton && n.defaultScope !== b2.Transient && n.defaultScope !== b2.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
      if (void 0 === n.autoBindInjectable) n.autoBindInjectable = false;
      else if ("boolean" != typeof n.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
      if (void 0 === n.skipBaseClassChecks) n.skipBaseClassChecks = false;
      else if ("boolean" != typeof n.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
      this.options = { autoBindInjectable: n.autoBindInjectable, defaultScope: n.defaultScope, skipBaseClassChecks: n.skipBaseClassChecks }, this.id = S(), this._bindingDictionary = new Mt(), this._snapshots = [], this._middleware = null, this._activations = new Mt(), this._deactivations = new Mt(), this.parent = null, this._metadataReader = new M2(), this._moduleActivationStore = new Bt();
    }
    static merge(t3, n, ...e2) {
      const i2 = new _Pt(), r3 = [t3, n, ...e2].map(((t4) => U(t4))), s3 = U(i2);
      return r3.forEach(((t4) => {
        var n2;
        n2 = s3, t4.traverse(((t5, e3) => {
          e3.forEach(((t6) => {
            n2.add(t6.serviceIdentifier, t6.clone());
          }));
        }));
      })), i2;
    }
    load(...t3) {
      const n = this._getContainerModuleHelpersFactory();
      for (const e2 of t3) {
        const t4 = n(e2.id);
        e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
      }
    }
    async loadAsync(...t3) {
      const n = this._getContainerModuleHelpersFactory();
      for (const e2 of t3) {
        const t4 = n(e2.id);
        await e2.registry(t4.bindFunction, t4.unbindFunction, t4.isboundFunction, t4.rebindFunction, t4.unbindAsyncFunction, t4.onActivationFunction, t4.onDeactivationFunction);
      }
    }
    unload(...t3) {
      t3.forEach(((t4) => {
        const n = this._removeModuleBindings(t4.id);
        this._deactivateSingletons(n), this._removeModuleHandlers(t4.id);
      }));
    }
    async unloadAsync(...t3) {
      for (const n of t3) {
        const t4 = this._removeModuleBindings(n.id);
        await this._deactivateSingletonsAsync(t4), this._removeModuleHandlers(n.id);
      }
    }
    bind(t3) {
      return this._bind(this._buildBinding(t3));
    }
    rebind(t3) {
      return this.unbind(t3), this.bind(t3);
    }
    async rebindAsync(t3) {
      return await this.unbindAsync(t3), this.bind(t3);
    }
    unbind(t3) {
      if (this._bindingDictionary.hasKey(t3)) {
        const n = this._bindingDictionary.get(t3);
        this._deactivateSingletons(n);
      }
      this._removeServiceFromDictionary(t3);
    }
    async unbindAsync(t3) {
      if (this._bindingDictionary.hasKey(t3)) {
        const n = this._bindingDictionary.get(t3);
        await this._deactivateSingletonsAsync(n);
      }
      this._removeServiceFromDictionary(t3);
    }
    unbindAll() {
      this._bindingDictionary.traverse(((t3, n) => {
        this._deactivateSingletons(n);
      })), this._bindingDictionary = new Mt();
    }
    async unbindAllAsync() {
      const t3 = [];
      this._bindingDictionary.traverse(((n, e2) => {
        t3.push(this._deactivateSingletonsAsync(e2));
      })), await Promise.all(t3), this._bindingDictionary = new Mt();
    }
    onActivation(t3, n) {
      this._activations.add(t3, n);
    }
    onDeactivation(t3, n) {
      this._deactivations.add(t3, n);
    }
    isBound(t3) {
      let n = this._bindingDictionary.hasKey(t3);
      return !n && this.parent && (n = this.parent.isBound(t3)), n;
    }
    isCurrentBound(t3) {
      return this._bindingDictionary.hasKey(t3);
    }
    isBoundNamed(t3, n) {
      return this.isBoundTagged(t3, s2, n);
    }
    isBoundTagged(t3, n, s3) {
      let o3 = false;
      if (this._bindingDictionary.hasKey(t3)) {
        const a3 = this._bindingDictionary.get(t3), c3 = (function(t4, n2, s4) {
          const o4 = Y(n2, s4), a4 = v(o4);
          if (a4.kind === p.unmanaged) throw new Error("Unexpected metadata when creating target");
          const c4 = new T("", a4, "Variable"), d3 = new V(t4);
          return new H(n2, d3, null, [], c4);
        })(this, t3, { customTag: { key: n, value: s3 }, isMultiInject: false });
        o3 = a3.some(((t4) => t4.constraint(c3)));
      }
      return !o3 && this.parent && (o3 = this.parent.isBoundTagged(t3, n, s3)), o3;
    }
    snapshot() {
      this._snapshots.push(Et.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    }
    restore() {
      const t3 = this._snapshots.pop();
      if (void 0 === t3) throw new Error("No snapshot available to restore.");
      this._bindingDictionary = t3.bindings, this._activations = t3.activations, this._deactivations = t3.deactivations, this._middleware = t3.middleware, this._moduleActivationStore = t3.moduleActivationStore;
    }
    createChild(t3) {
      const n = new _Pt(t3 || this.options);
      return n.parent = this, n;
    }
    applyMiddleware(...t3) {
      const n = this._middleware ? this._middleware : this._planAndResolve();
      this._middleware = t3.reduce(((t4, n2) => n2(t4)), n);
    }
    applyCustomMetadataReader(t3) {
      this._metadataReader = t3;
    }
    get(t3) {
      const n = this._getNotAllArgs(t3, false, false);
      return this._getButThrowIfAsync(n);
    }
    async getAsync(t3) {
      const n = this._getNotAllArgs(t3, false, false);
      return this._get(n);
    }
    getTagged(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, false, false, n, e2);
      return this._getButThrowIfAsync(i2);
    }
    async getTaggedAsync(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, false, false, n, e2);
      return this._get(i2);
    }
    getNamed(t3, n) {
      return this.getTagged(t3, s2, n);
    }
    async getNamedAsync(t3, n) {
      return this.getTaggedAsync(t3, s2, n);
    }
    getAll(t3, n) {
      const e2 = this._getAllArgs(t3, n, false);
      return this._getButThrowIfAsync(e2);
    }
    async getAllAsync(t3, n) {
      const e2 = this._getAllArgs(t3, n, false);
      return this._getAll(e2);
    }
    getAllTagged(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, true, false, n, e2);
      return this._getButThrowIfAsync(i2);
    }
    async getAllTaggedAsync(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, true, false, n, e2);
      return this._getAll(i2);
    }
    getAllNamed(t3, n) {
      return this.getAllTagged(t3, s2, n);
    }
    async getAllNamedAsync(t3, n) {
      return this.getAllTaggedAsync(t3, s2, n);
    }
    resolve(t3) {
      const n = this.isBound(t3);
      n || this.bind(t3).toSelf();
      const e2 = this.get(t3);
      return n || this.unbind(t3), e2;
    }
    tryGet(t3) {
      const n = this._getNotAllArgs(t3, false, true);
      return this._getButThrowIfAsync(n);
    }
    async tryGetAsync(t3) {
      const n = this._getNotAllArgs(t3, false, true);
      return this._get(n);
    }
    tryGetTagged(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, false, true, n, e2);
      return this._getButThrowIfAsync(i2);
    }
    async tryGetTaggedAsync(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, false, true, n, e2);
      return this._get(i2);
    }
    tryGetNamed(t3, n) {
      return this.tryGetTagged(t3, s2, n);
    }
    async tryGetNamedAsync(t3, n) {
      return this.tryGetTaggedAsync(t3, s2, n);
    }
    tryGetAll(t3, n) {
      const e2 = this._getAllArgs(t3, n, true);
      return this._getButThrowIfAsync(e2);
    }
    async tryGetAllAsync(t3, n) {
      const e2 = this._getAllArgs(t3, n, true);
      return this._getAll(e2);
    }
    tryGetAllTagged(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, true, true, n, e2);
      return this._getButThrowIfAsync(i2);
    }
    async tryGetAllTaggedAsync(t3, n, e2) {
      const i2 = this._getNotAllArgs(t3, true, true, n, e2);
      return this._getAll(i2);
    }
    tryGetAllNamed(t3, n) {
      return this.tryGetAllTagged(t3, s2, n);
    }
    async tryGetAllNamedAsync(t3, n) {
      return this.tryGetAllTaggedAsync(t3, s2, n);
    }
    _preDestroy(t3, n) {
      var _a4;
      if (void 0 !== t3 && Reflect.hasMetadata(f2, t3)) {
        const e2 = Reflect.getMetadata(f2, t3);
        return (_a4 = n[e2.value]) == null ? void 0 : _a4.call(n);
      }
    }
    _removeModuleHandlers(t3) {
      const n = this._moduleActivationStore.remove(t3);
      this._activations.removeIntersection(n.onActivations), this._deactivations.removeIntersection(n.onDeactivations);
    }
    _removeModuleBindings(t3) {
      return this._bindingDictionary.removeByCondition(((n) => n.moduleId === t3));
    }
    _deactivate(t3, n) {
      const e2 = null == n ? void 0 : Object.getPrototypeOf(n).constructor;
      try {
        if (this._deactivations.hasKey(t3.serviceIdentifier)) {
          const i3 = this._deactivateContainer(n, this._deactivations.get(t3.serviceIdentifier).values());
          if (X(i3)) return this._handleDeactivationError(i3.then((async () => this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2))), t3.serviceIdentifier);
        }
        const i2 = this._propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2);
        if (X(i2)) return this._handleDeactivationError(i2, t3.serviceIdentifier);
      } catch (n2) {
        if (n2 instanceof Error) throw new Error(E2(k2(t3.serviceIdentifier), n2.message));
      }
    }
    async _handleDeactivationError(t3, n) {
      try {
        await t3;
      } catch (t4) {
        if (t4 instanceof Error) throw new Error(E2(k2(n), t4.message));
      }
    }
    _deactivateContainer(t3, n) {
      let e2 = n.next();
      for (; "function" == typeof e2.value; ) {
        const i2 = e2.value(t3);
        if (X(i2)) return i2.then((async () => this._deactivateContainerAsync(t3, n)));
        e2 = n.next();
      }
    }
    async _deactivateContainerAsync(t3, n) {
      let e2 = n.next();
      for (; "function" == typeof e2.value; ) await e2.value(t3), e2 = n.next();
    }
    _getContainerModuleHelpersFactory() {
      const t3 = (t4) => (n2) => {
        const e3 = this._buildBinding(n2);
        return e3.moduleId = t4, this._bind(e3);
      }, n = () => (t4) => {
        this.unbind(t4);
      }, e2 = () => async (t4) => this.unbindAsync(t4), i2 = () => (t4) => this.isBound(t4), r3 = (n2) => {
        const e3 = t3(n2);
        return (t4) => (this.unbind(t4), e3(t4));
      }, s3 = (t4) => (n2, e3) => {
        this._moduleActivationStore.addActivation(t4, n2, e3), this.onActivation(n2, e3);
      }, o3 = (t4) => (n2, e3) => {
        this._moduleActivationStore.addDeactivation(t4, n2, e3), this.onDeactivation(n2, e3);
      };
      return (a3) => ({ bindFunction: t3(a3), isboundFunction: i2(), onActivationFunction: s3(a3), onDeactivationFunction: o3(a3), rebindFunction: r3(a3), unbindAsyncFunction: e2(), unbindFunction: n() });
    }
    _bind(t3) {
      return this._bindingDictionary.add(t3.serviceIdentifier, t3), new Rt(t3);
    }
    _buildBinding(t3) {
      const n = this.options.defaultScope || b2.Transient;
      return new I2(t3, n);
    }
    async _getAll(t3) {
      return Promise.all(this._get(t3));
    }
    _get(t3) {
      const n = __spreadProps(__spreadValues({}, t3), { contextInterceptor: (t4) => t4, targetType: m2.Variable });
      if (this._middleware) {
        const t4 = this._middleware(n);
        if (null == t4) throw new Error("Invalid return type in middleware. Middleware must return!");
        return t4;
      }
      return this._planAndResolve()(n);
    }
    _getButThrowIfAsync(t3) {
      const n = this._get(t3);
      if (Z(n)) throw new Error(`You are attempting to construct ${(function(t4) {
        return "function" == typeof t4 ? `[function/class ${t4.name || "<anonymous>"}]` : "symbol" == typeof t4 ? t4.toString() : `'${t4}'`;
      })(t3.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);
      return n;
    }
    _getAllArgs(t3, n, e2) {
      return { avoidConstraints: !(n == null ? void 0 : n.enforceBindingConstraints), isMultiInject: true, isOptional: e2, serviceIdentifier: t3 };
    }
    _getNotAllArgs(t3, n, e2, i2, r3) {
      return { avoidConstraints: false, isMultiInject: n, isOptional: e2, key: i2, serviceIdentifier: t3, value: r3 };
    }
    _getPlanMetadataFromNextArgs(t3) {
      const n = { isMultiInject: t3.isMultiInject };
      return void 0 !== t3.key && (n.customTag = { key: t3.key, value: t3.value }), true === t3.isOptional && (n.isOptional = true), n;
    }
    _planAndResolve() {
      return (t3) => {
        let n = Q(this._metadataReader, this, t3.targetType, t3.serviceIdentifier, this._getPlanMetadataFromNextArgs(t3), t3.avoidConstraints);
        n = t3.contextInterceptor(n);
        const e2 = (function(t4) {
          return ut(t4.plan.rootRequest.requestScope)(t4.plan.rootRequest);
        })(n);
        return e2;
      };
    }
    _deactivateIfSingleton(t3) {
      if (t3.activated) return X(t3.cache) ? t3.cache.then(((n) => this._deactivate(t3, n))) : this._deactivate(t3, t3.cache);
    }
    _deactivateSingletons(t3) {
      for (const n of t3) {
        if (X(this._deactivateIfSingleton(n))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
      }
    }
    async _deactivateSingletonsAsync(t3) {
      await Promise.all(t3.map((async (t4) => this._deactivateIfSingleton(t4))));
    }
    _propagateContainerDeactivationThenBindingAndPreDestroy(t3, n, e2) {
      return this.parent ? this._deactivate.bind(this.parent)(t3, n) : this._bindingDeactivationAndPreDestroy(t3, n, e2);
    }
    async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t3, n, e2) {
      this.parent ? await this._deactivate.bind(this.parent)(t3, n) : await this._bindingDeactivationAndPreDestroyAsync(t3, n, e2);
    }
    _removeServiceFromDictionary(t3) {
      try {
        this._bindingDictionary.remove(t3);
      } catch (n) {
        throw new Error(`Could not unbind serviceIdentifier: ${k2(t3)}`);
      }
    }
    _bindingDeactivationAndPreDestroy(t3, n, e2) {
      if ("function" == typeof t3.onDeactivation) {
        const i2 = t3.onDeactivation(n);
        if (X(i2)) return i2.then((() => this._preDestroy(e2, n)));
      }
      return this._preDestroy(e2, n);
    }
    async _bindingDeactivationAndPreDestroyAsync(t3, n, e2) {
      "function" == typeof t3.onDeactivation && await t3.onDeactivation(n), await this._preDestroy(e2, n);
    }
  };
  function Ft(t3, n, e2, i2) {
    !(function(t4) {
      if (void 0 !== t4) throw new Error(R);
    })(n), Ot(h2, t3, e2.toString(), i2);
  }
  function jt(t3) {
    let n = [];
    if (Array.isArray(t3)) {
      n = t3;
      const e2 = (function(t4) {
        const n2 = /* @__PURE__ */ new Set();
        for (const e3 of t4) {
          if (n2.has(e3)) return e3;
          n2.add(e3);
        }
      })(n.map(((t4) => t4.key)));
      if (void 0 !== e2) throw new Error(`${T2} ${e2.toString()}`);
    } else n = [t3];
    return n;
  }
  function Ot(t3, n, e2, i2) {
    const r3 = jt(i2);
    let s3 = {};
    Reflect.hasOwnMetadata(t3, n) && (s3 = Reflect.getMetadata(t3, n));
    let o3 = s3[e2];
    if (void 0 === o3) o3 = [];
    else for (const t4 of o3) if (r3.some(((n2) => n2.key === t4.key))) throw new Error(`${T2} ${t4.key.toString()}`);
    o3.push(...r3), s3[e2] = o3, Reflect.defineMetadata(t3, s3, n);
  }
  function $t(t3) {
    return (n, e2, i2) => {
      "number" == typeof i2 ? Ft(n, e2, i2, t3) : (function(t4, n2, e3) {
        if (void 0 !== t4.prototype) throw new Error(R);
        Ot(l2, t4.constructor, n2, e3);
      })(n, e2, t3);
    };
  }
  function Kt() {
    return function(t3) {
      if (Reflect.hasOwnMetadata(g2, t3)) throw new Error("Cannot apply @injectable decorator multiple times.");
      const n = Reflect.getMetadata(y2, t3) || [];
      return Reflect.defineMetadata(g2, n, t3), t3;
    };
  }
  function Lt(t3) {
    return (n) => (e2, i2, r3) => {
      if (void 0 === n) {
        const t4 = "function" == typeof e2 ? e2.name : e2.constructor.name;
        throw new Error(`@inject called with undefined this could mean that the class ${t4} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`);
      }
      $t(new W(t3, n))(e2, i2, r3);
    };
  }
  var Yt = Lt(d2);
  var Qt = Lt(u2);
  function Zt(t3, n) {
    return () => (e2, i2) => {
      const r3 = new W(t3, i2);
      if (Reflect.hasOwnMetadata(t3, e2.constructor)) throw new Error(n);
      Reflect.defineMetadata(t3, r3, e2.constructor);
    };
  }
  var tn = Zt(p2, "Cannot apply @postConstruct decorator multiple times in the same class");
  var nn = Zt(f2, "Cannot apply @preDestroy decorator multiple times in the same class");

  // src/extension/webview/diagram-client.ts
  var import_sprotty2 = __toESM(require_lib2());
  var import_snabbdom = __toESM(require_snabbdom_cjs());
  var BASE_DIV_ID = "sprotty";
  var SVG_NS = "http://www.w3.org/2000/svg";
  var LABEL_GAP = 10;
  var NODE_PADDING = 10;
  var LINE_GAP = 6;
  var PROPERTY_HEIGHT = 16;
  var DEFAULT_FONT_SIZE = 13;
  var MIN_SCALE = 0.2;
  var MAX_SCALE = 3;
  var MARKER_CONFIGS = [
    // Open Arrow Markers (Relations)
    {
      id: "oml-open-arrow",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12" }]
    },
    {
      id: "oml-open-arrow-hover",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12" }]
    },
    {
      id: "oml-open-arrow-selected",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12" }]
    },
    // Closed Triangle Markers (Specializations)
    {
      id: "oml-closed-triangle",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12 Z" }]
    },
    {
      id: "oml-closed-triangle-hover",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12 Z" }]
    },
    {
      id: "oml-closed-triangle-selected",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [{ d: "M0,0 L12,6 L0,12 Z" }]
    },
    // Equivalence Triangle Markers (Equivalence Axioms)
    {
      id: "oml-equivalence-triangle",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [
        { d: "M-8,0 L-8,12" },
        { d: "M-5,0 L-5,12" },
        { d: "M0,0 L12,6 L0,12 Z" }
      ]
    },
    {
      id: "oml-equivalence-triangle-hover",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [
        { d: "M-8,0 L-8,12" },
        { d: "M-5,0 L-5,12" },
        { d: "M0,0 L12,6 L0,12 Z" }
      ]
    },
    {
      id: "oml-equivalence-triangle-selected",
      viewBox: "0 0 14 12",
      refX: "12",
      refY: "6",
      markerWidth: "16",
      markerHeight: "16",
      paths: [
        { d: "M-8,0 L-8,12" },
        { d: "M-5,0 L-5,12" },
        { d: "M0,0 L12,6 L0,12 Z" }
      ]
    }
  ];
  function createMarker(config) {
    return (0, import_snabbdom.h)(`marker#${config.id}`, {
      ns: SVG_NS,
      attrs: {
        viewBox: config.viewBox,
        refX: config.refX,
        refY: config.refY,
        markerUnits: "userSpaceOnUse",
        markerWidth: config.markerWidth,
        markerHeight: config.markerHeight,
        orient: "auto",
        overflow: "visible"
      }
    }, config.paths.map((p3) => {
      var _a4;
      return (0, import_snabbdom.h)("path", {
        ns: SVG_NS,
        class: (_a4 = p3.class) == null ? void 0 : _a4.split(" ").reduce((acc, cls) => __spreadProps(__spreadValues({}, acc), { [cls]: true }), {}),
        attrs: { d: p3.d }
      });
    }));
  }
  var OmlGraphView = class extends import_sprotty2.SGraphView {
    render(model, context) {
      const vnode = super.render(model, context);
      const defs = (0, import_snabbdom.h)("defs", { ns: SVG_NS }, MARKER_CONFIGS.map(createMarker));
      vnode.children = vnode.children ? [defs, ...vnode.children] : [defs];
      return vnode;
    }
  };
  var OmlEdgeView = class extends import_sprotty2.PolylineEdgeView {
    renderLine(edge, segments, context, args) {
      var _a4, _b2, _c, _d, _e3, _f;
      const lineVNode = super.renderLine(edge, segments, context, args);
      const kind = (_c = (_b2 = edge == null ? void 0 : edge.kind) != null ? _b2 : (_a4 = edge == null ? void 0 : edge.data) == null ? void 0 : _a4.kind) != null ? _c : "relation";
      const hasMarker = (_d = edge == null ? void 0 : edge.hasMarker) != null ? _d : true;
      const markerId = this.getMarkerId(kind, hasMarker);
      const attrsTarget = (_e3 = lineVNode.data) != null ? _e3 : lineVNode.data = {};
      const attrs = (_f = attrsTarget.attrs) != null ? _f : attrsTarget.attrs = {};
      delete attrs["marker-start"];
      delete attrs["marker-mid"];
      if (markerId) {
        attrs["marker-end"] = `url(#${markerId})`;
      } else {
        delete attrs["marker-end"];
      }
      return lineVNode;
    }
    getMarkerId(kind, hasMarker) {
      if (kind === "specialization") return "oml-closed-triangle";
      if (kind === "equivalence" && hasMarker) return "oml-equivalence-triangle";
      if (kind === "relation" && hasMarker) return "oml-open-arrow";
      return void 0;
    }
    render(model, context) {
      const vnode = super.render(model, context);
      this.applyLabelOffset(vnode, model);
      return vnode;
    }
    applyLabelOffset(vnode, model) {
      var _a4, _b2, _c, _d, _e3, _f, _g;
      try {
        const rawIndex = (_c = (_b2 = model == null ? void 0 : model.labelIndex) != null ? _b2 : (_a4 = model == null ? void 0 : model.data) == null ? void 0 : _a4.labelIndex) != null ? _c : 0;
        const idx = typeof rawIndex === "number" ? Math.max(0, rawIndex) : 0;
        if (idx > 0) {
          const pairIndex = Math.ceil(idx / 2);
          const sign = idx % 2 === 0 ? 1 : -1;
          const offsetY = pairIndex * LABEL_GAP * sign;
          const labelVNode = this.findLabelVNode(vnode);
          if (labelVNode) {
            const data = (_d = labelVNode.data) != null ? _d : labelVNode.data = {};
            const attrs = (_e3 = data.attrs) != null ? _e3 : data.attrs = {};
            const existing = typeof attrs.transform === "string" ? attrs.transform : (_g = (_f = data.props) == null ? void 0 : _f.transform) != null ? _g : "";
            const translate = `translate(0, ${offsetY})`;
            attrs.transform = existing ? `${translate} ${existing}` : translate;
          }
        }
      } catch (e2) {
      }
    }
    findLabelVNode(vnode) {
      var _a4;
      if (!vnode || !vnode.children) return void 0;
      for (const child of vnode.children) {
        const cls = (_a4 = child == null ? void 0 : child.data) == null ? void 0 : _a4.class;
        if (cls && (cls["sprotty-label"] || cls["sprotty_label"])) return child;
        if (child.children && child.children.some((c3) => c3 && c3.sel === "text")) return child;
        const found = this.findLabelVNode(child);
        if (found) return found;
      }
      return void 0;
    }
  };
  var OmlRectNodeView = class extends import_sprotty2.RectangularNodeView {
    render(model, context) {
      var _a4, _b2, _c, _d, _e3, _f, _g, _h;
      const group = super.render(model, context);
      try {
        const width = (_d = (_c = (_a4 = model.size) == null ? void 0 : _a4.width) != null ? _c : (_b2 = model.bounds) == null ? void 0 : _b2.width) != null ? _d : 120;
        const height = (_h = (_g = (_e3 = model.size) == null ? void 0 : _e3.height) != null ? _g : (_f = model.bounds) == null ? void 0 : _f.height) != null ? _h : 56;
        this.renderTypes(group, model, width);
        this.pushLabelDown(group);
        const compartmentY = this.renderCompartmentLine(group, model, width, height);
        this.renderProperties(group, model, compartmentY);
      } catch (e2) {
      }
      return group;
    }
    pushLabelDown(group) {
      var _a4, _b2;
      if (!group || !Array.isArray(group.children)) return;
      for (const child of group.children) {
        if (((_a4 = child == null ? void 0 : child.data) == null ? void 0 : _a4.class) && (child.data.class["sprotty-label"] || child.data.class["sprotty_label"])) {
          const attrs = (_b2 = child.data.attrs) != null ? _b2 : child.data.attrs = {};
          attrs.y = 16;
        }
      }
    }
    renderTypes(group, model, width) {
      var _a4;
      const types = (_a4 = model.types) != null ? _a4 : [];
      if (types.length === 0 || !Array.isArray(group.children)) return;
      const typesText = `\xAB${types.join(", ")}\xBB`;
      const typesVNode = (0, import_snabbdom.h)("text", {
        ns: SVG_NS,
        attrs: { x: width / 2, y: NODE_PADDING + 2, "text-anchor": "middle" },
        class: { "oml-types-label": true }
      }, typesText);
      group.children.push(typesVNode);
    }
    renderCompartmentLine(group, model, width, height) {
      var _a4;
      const kindOffset = 16;
      const label = ((_a4 = model.children) != null ? _a4 : []).find((c3) => c3.type === "label");
      const labelY = (label == null ? void 0 : label.bounds) && Number.isFinite(label.bounds.y) ? label.bounds.y : 0;
      const labelH = (label == null ? void 0 : label.bounds) && Number.isFinite(label.bounds.height) && label.bounds.height > 0 ? label.bounds.height : DEFAULT_FONT_SIZE;
      const compartmentY = Math.max(NODE_PADDING + kindOffset, Math.min(height - NODE_PADDING, labelY + labelH + LINE_GAP + kindOffset));
      const lineVNode = (0, import_snabbdom.h)("line", {
        ns: SVG_NS,
        class: { "oml-compartment-line": true },
        attrs: {
          x1: NODE_PADDING,
          y1: compartmentY,
          x2: Math.max(NODE_PADDING, width - NODE_PADDING),
          y2: compartmentY
        }
      });
      if (Array.isArray(group.children)) {
        group.children.push(lineVNode);
      }
      return compartmentY;
    }
    renderProperties(group, model, compartmentY) {
      var _a4;
      const properties = (_a4 = model.props) != null ? _a4 : [];
      if (!Array.isArray(group.children)) return;
      properties.forEach((prop, idx) => {
        const py = compartmentY + LINE_GAP + idx * PROPERTY_HEIGHT;
        const textVNode = (0, import_snabbdom.h)("text", {
          ns: SVG_NS,
          attrs: {
            x: NODE_PADDING + 4,
            y: py
          },
          class: { "oml-property-label": true }
        }, prop);
        group.children.push(textVNode);
      });
    }
  };
  var _EmptyView_decorators, _init;
  _EmptyView_decorators = [Kt()];
  var EmptyView = class {
    render(element, context) {
      return (0, import_snabbdom.h)("g", { ns: SVG_NS, attrs: { visibility: "hidden" } }, []);
    }
  };
  _init = __decoratorStart(null);
  EmptyView = __decorateElement(_init, 0, "EmptyView", _EmptyView_decorators, EmptyView);
  __runInitializers(_init, 1, EmptyView);
  function createOmlContainer(baseDiv) {
    const container = new Pt();
    (0, import_sprotty2.loadDefaultModules)(container);
    (0, import_sprotty2.overrideViewerOptions)(container, {
      baseDiv,
      needsClientLayout: false,
      needsServerLayout: true
    });
    container.rebind(import_sprotty2.TYPES.ILogger).to(import_sprotty2.ConsoleLogger).inSingletonScope();
    container.rebind(import_sprotty2.TYPES.LogLevel).toConstantValue(import_sprotty2.LogLevel.error);
    (0, import_sprotty2.configureModelElement)(container, "graph", import_sprotty2.SGraphImpl, OmlGraphView);
    (0, import_sprotty2.configureModelElement)(container, "node:rect", import_sprotty2.SNodeImpl, OmlRectNodeView);
    (0, import_sprotty2.configureModelElement)(container, "label", import_sprotty2.SLabelImpl, import_sprotty2.SLabelView);
    (0, import_sprotty2.configureModelElement)(container, "edge", import_sprotty2.SEdgeImpl, OmlEdgeView);
    const routingTypes = [
      "routing-point",
      "volatile-routing-point",
      "bezier-routing-point",
      "bezier-create-routing-point",
      "bezier-remove-routing-point"
    ];
    routingTypes.forEach((type) => {
      (0, import_sprotty2.configureModelElement)(container, type, import_sprotty2.SChildElementImpl, EmptyView);
    });
    if (!container.isBound(import_sprotty2.TYPES.ModelSource)) {
      container.bind(import_sprotty2.TYPES.ModelSource).to(import_sprotty2.LocalModelSource).inSingletonScope();
    }
    disableMoveListeners(container);
    return container;
  }
  function disableMoveListeners(container) {
    if (!container.isBound(import_sprotty2.TYPES.MouseListener)) return;
    const allListeners = container.getAll(import_sprotty2.TYPES.MouseListener);
    const filtered = allListeners.filter((listener) => {
      var _a4;
      const ctor = ((_a4 = listener == null ? void 0 : listener.constructor) == null ? void 0 : _a4.name) || "";
      return !ctor.includes("Move");
    });
    if (filtered.length > 0) {
      container.unbind(import_sprotty2.TYPES.MouseListener);
      filtered.forEach((listener) => {
        container.bind(import_sprotty2.TYPES.MouseListener).toConstantValue(listener);
      });
    }
  }
  var currentDiagramModel = null;
  function findElementById(model, id) {
    if (!model) return null;
    if (model.id === id) return model;
    if (model.children) {
      for (const child of model.children) {
        const found = findElementById(child, id);
        if (found) return found;
      }
    }
    return null;
  }
  var MarkerManager = class {
    constructor(baseDiv) {
      this.baseDiv = baseDiv;
      this.svg = null;
    }
    initialize() {
      const root = document.getElementById(this.baseDiv);
      if (!root) return;
      this.svg = root.querySelector("svg");
      if (!this.svg) return;
      this.setupObserver();
      this.setupHoverListeners();
      this.updateMarkerReferences();
    }
    setupHoverListeners() {
      if (!this.svg) return;
      this.svg.addEventListener("mouseenter", (e2) => {
        const target = e2.target;
        const edge = target.closest("g.sprotty-edge");
        if (edge) {
          edge.setAttribute("data-hover", "true");
        }
      }, true);
      this.svg.addEventListener("mouseleave", (e2) => {
        const target = e2.target;
        const edge = target.closest("g.sprotty-edge");
        if (edge) {
          edge.removeAttribute("data-hover");
        }
      }, true);
    }
    setupObserver() {
      if (!this.svg) return;
      const observer = new MutationObserver((mutations) => {
        this.handleMutations(mutations);
        this.updateMarkerReferences();
      });
      observer.observe(this.svg, {
        subtree: true,
        attributeFilter: ["class", "data-hover"],
        attributeOldValue: true
      });
    }
    handleMutations(mutations) {
      for (const mutation of mutations) {
        if (mutation.type !== "attributes") continue;
        const attr = mutation.attributeName;
        if (attr !== "class" && attr !== "data-hover") continue;
        const target = mutation.target;
        const domId = this.extractDomId(target);
        if (!domId) continue;
        if (attr === "class") {
          this.propagateSelection(target, domId);
        } else if (attr === "data-hover") {
          this.propagateHover(target, domId);
        }
      }
    }
    extractDomId(element) {
      let domId = element.getAttribute("id");
      if (!domId && element.parentElement) {
        domId = element.parentElement.getAttribute("id");
      }
      return domId || void 0;
    }
    propagateSelection(target, domId) {
      const isSelected = target.classList.contains("selected");
      const relationBase = domId.replace(/-edge[12]$/, "");
      this.setSelected(document.getElementById(relationBase), isSelected);
      this.setSelected(document.getElementById(`${relationBase}-edge1`), isSelected);
      this.setSelected(document.getElementById(`${relationBase}-edge2`), isSelected);
      const descRelationMatch = domId.match(/^(.+?)-(source|target)-edge\d+$/);
      if (descRelationMatch) {
        this.propagateToRelatedElements(descRelationMatch[1], isSelected, "selected");
      }
      const eqMatch = domId.match(/^(.+?)<->(\[?\d+\]?)(-edge\d+)?$/);
      if (eqMatch) {
        const eqPrefix = `${eqMatch[1]}<->${eqMatch[2]}`;
        this.propagateToElementsWithPrefix(eqPrefix, isSelected, "selected");
      }
    }
    propagateHover(target, domId) {
      const isHover = target.hasAttribute("data-hover");
      const relationBase = domId.replace(/-edge[12]$/, "");
      this.setHover(document.getElementById(relationBase), isHover);
      this.setHover(document.getElementById(`${relationBase}-edge1`), isHover);
      this.setHover(document.getElementById(`${relationBase}-edge2`), isHover);
    }
    propagateToRelatedElements(baseId, state, attribute) {
      if (!this.svg) return;
      const allElements = this.svg.querySelectorAll("[id]");
      allElements.forEach((el) => {
        const elId = el.getAttribute("id") || "";
        if (elId === baseId || elId.startsWith(`${baseId}-source-edge`) || elId.startsWith(`${baseId}-target-edge`)) {
          if (attribute === "selected") {
            this.setSelected(el, state);
          } else {
            this.setHover(el, state);
          }
        }
      });
    }
    propagateToElementsWithPrefix(prefix, state, attribute) {
      if (!this.svg) return;
      const allElements = this.svg.querySelectorAll("[id]");
      allElements.forEach((el) => {
        const elId = el.getAttribute("id") || "";
        if (elId.startsWith(prefix)) {
          if (attribute === "selected") {
            this.setSelected(el, state);
          } else {
            this.setHover(el, state);
          }
        }
      });
    }
    setSelected(el, selected) {
      if (!el) return;
      const hasClass = el.classList.contains("selected");
      if (selected && !hasClass) el.classList.add("selected");
      else if (!selected && hasClass) el.classList.remove("selected");
    }
    setHover(el, hover) {
      if (!el) return;
      const hasAttr = el.hasAttribute("data-hover");
      if (hover && !hasAttr) el.setAttribute("data-hover", "true");
      else if (!hover && hasAttr) el.removeAttribute("data-hover");
    }
    updateMarkerReferences() {
      if (!this.svg) return;
      const edges = this.svg.querySelectorAll("g.sprotty-edge");
      edges.forEach((edge) => {
        const isSelected = edge.classList.contains("selected");
        const hasHoverAttr = edge.hasAttribute("data-hover");
        const lineElement = edge.querySelector("polyline, path, line");
        if (!lineElement) return;
        const currentMarkerEnd = lineElement.getAttribute("marker-end");
        if (!currentMarkerEnd) return;
        const newMarkerEnd = this.determineMarkerEnd(currentMarkerEnd, isSelected, hasHoverAttr);
        if (newMarkerEnd && lineElement.getAttribute("marker-end") !== newMarkerEnd) {
          lineElement.setAttribute("marker-end", newMarkerEnd);
        }
      });
    }
    determineMarkerEnd(currentMarker, isSelected, isHover) {
      const markerType = this.getMarkerType(currentMarker);
      if (!markerType) return null;
      const suffix = isSelected ? "-selected" : isHover ? "-hover" : "";
      return `url(#${markerType}${suffix})`;
    }
    getMarkerType(markerEnd) {
      if (markerEnd.includes("oml-open-arrow")) return "oml-open-arrow";
      if (markerEnd.includes("oml-closed-triangle")) return "oml-closed-triangle";
      if (markerEnd.includes("oml-equivalence-triangle")) return "oml-equivalence-triangle";
      return null;
    }
  };
  var PanZoomController = class {
    constructor(root, target) {
      this.root = root;
      this.target = target;
      this.isPanning = false;
      this.startX = 0;
      this.startY = 0;
      this.panX = 0;
      this.panY = 0;
      this.scale = 1;
      this.pinchActive = false;
      this.pinchStartDist = 0;
      this.pinchStartScale = 1;
      this.pinchStartPanX = 0;
      this.pinchStartPanY = 0;
      this.pinchCenterX = 0;
      this.pinchCenterY = 0;
      this.initialize();
    }
    initialize() {
      this.target.style.willChange = "transform";
      this.root.style.cursor = "grab";
      this.root.__resetView = () => this.reset();
      this.attachEventListeners();
    }
    attachEventListeners() {
      this.root.addEventListener("mousedown", this.onMouseDown.bind(this), { capture: true });
      this.root.addEventListener("mousedown", this.preventNodeDrag.bind(this), { capture: true });
      window.addEventListener("mousemove", this.onMouseMove.bind(this), { capture: true });
      window.addEventListener("mouseup", this.onMouseUp.bind(this), { capture: true });
      this.root.addEventListener("wheel", this.onWheel.bind(this), { passive: false, capture: true });
      this.root.addEventListener("touchstart", this.onTouchStart.bind(this), { passive: false, capture: true });
      window.addEventListener("touchmove", this.onTouchMove.bind(this), { passive: false, capture: true });
      window.addEventListener("touchend", this.onTouchEnd.bind(this), { capture: true });
    }
    onMouseDown(e2) {
      const el = e2.target;
      const hitInteractive = el.closest("g.sprotty-node, g.sprotty-edge") !== null;
      if (e2.button === 1 || e2.button === 0 && !hitInteractive) {
        this.isPanning = true;
        this.startX = e2.clientX - this.panX;
        this.startY = e2.clientY - this.panY;
        this.root.style.cursor = "grabbing";
      }
    }
    preventNodeDrag(e2) {
      if (e2.button !== 0) return;
      const targetEl = e2.target;
      const onNode = targetEl.closest("g.sprotty-node") !== null;
      if (!onNode) return;
      const cancelDrag = (ev) => ev.preventDefault();
      const up = () => {
        window.removeEventListener("mousemove", cancelDrag, true);
        window.removeEventListener("mouseup", up, true);
      };
      window.addEventListener("mousemove", cancelDrag, true);
      window.addEventListener("mouseup", up, true);
    }
    onMouseMove(e2) {
      if (!this.isPanning) return;
      this.panX = e2.clientX - this.startX;
      this.panY = e2.clientY - this.startY;
      this.updateTransform();
      e2.preventDefault();
    }
    onMouseUp() {
      if (!this.isPanning) return;
      this.isPanning = false;
      this.root.style.cursor = "grab";
    }
    onWheel(e2) {
      const rect = this.root.getBoundingClientRect();
      const cx = e2.clientX - rect.left;
      const cy = e2.clientY - rect.top;
      const zoomFactor = Math.exp(-e2.deltaY * 1e-3);
      this.zoomAt(this.scale * zoomFactor, cx, cy);
      e2.preventDefault();
    }
    onTouchStart(e2) {
      if (e2.touches.length === 1) {
        const t3 = e2.touches.item(0);
        this.isPanning = true;
        this.startX = t3.clientX - this.panX;
        this.startY = t3.clientY - this.panY;
      } else if (e2.touches.length === 2) {
        this.initializePinch(e2);
      }
    }
    initializePinch(e2) {
      this.pinchActive = true;
      const t0 = e2.touches.item(0);
      const t1 = e2.touches.item(1);
      this.pinchStartDist = this.distance(t0.clientX, t0.clientY, t1.clientX, t1.clientY);
      this.pinchStartScale = this.scale;
      this.pinchStartPanX = this.panX;
      this.pinchStartPanY = this.panY;
      const rect = this.root.getBoundingClientRect();
      this.pinchCenterX = (t0.clientX + t1.clientX) / 2 - rect.left;
      this.pinchCenterY = (t0.clientY + t1.clientY) / 2 - rect.top;
      this.isPanning = false;
    }
    onTouchMove(e2) {
      if (this.pinchActive && e2.touches.length === 2) {
        this.handlePinchMove(e2);
        return;
      }
      if (this.isPanning && e2.touches.length === 1) {
        const t3 = e2.touches.item(0);
        this.panX = t3.clientX - this.startX;
        this.panY = t3.clientY - this.startY;
        this.updateTransform();
        e2.preventDefault();
      }
    }
    handlePinchMove(e2) {
      const t0 = e2.touches.item(0);
      const t1 = e2.touches.item(1);
      const d3 = this.distance(t0.clientX, t0.clientY, t1.clientX, t1.clientY);
      const newScale = this.clamp(this.pinchStartScale * (d3 / this.pinchStartDist), MIN_SCALE, MAX_SCALE);
      const s0 = this.scale;
      const s1 = newScale;
      this.panX = this.pinchStartPanX + (1 - s1 / s0) * (this.pinchCenterX - this.pinchStartPanX);
      this.panY = this.pinchStartPanY + (1 - s1 / s0) * (this.pinchCenterY - this.pinchStartPanY);
      this.scale = newScale;
      this.updateTransform();
      e2.preventDefault();
    }
    onTouchEnd(e2) {
      if (e2.touches.length === 0) {
        this.isPanning = false;
        this.pinchActive = false;
      } else if (e2.touches.length === 1) {
        this.pinchActive = false;
        const t3 = e2.touches.item(0);
        this.startX = t3.clientX - this.panX;
        this.startY = t3.clientY - this.panY;
      }
    }
    zoomAt(newScale, cx, cy) {
      const s0 = this.scale;
      const s1 = this.clamp(newScale, MIN_SCALE, MAX_SCALE);
      if (s1 === s0) return;
      this.panX = this.panX + (1 - s1 / s0) * (cx - this.panX);
      this.panY = this.panY + (1 - s1 / s0) * (cy - this.panY);
      this.scale = s1;
      this.updateTransform();
    }
    updateTransform() {
      this.target.style.transformOrigin = "0 0";
      this.target.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
    }
    reset() {
      this.panX = 0;
      this.panY = 0;
      this.scale = 1;
      this.updateTransform();
    }
    distance(x1, y1, x22, y22) {
      return Math.hypot(x22 - x1, y22 - y1);
    }
    clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
  };
  var NavigationHandler = class {
    constructor(baseDiv, vscodeApi, modelGetter) {
      this.baseDiv = baseDiv;
      this.vscodeApi = vscodeApi;
      this.modelGetter = modelGetter;
      this.initialize();
    }
    initialize() {
      window.addEventListener("dblclick", this.onDoubleClick.bind(this), { capture: true });
    }
    onDoubleClick(e2) {
      const target = e2.target;
      const inDiagram = target.closest(`#${this.baseDiv}`) !== null;
      if (!inDiagram) return;
      const element = this.findClickedElement(target);
      if (element) {
        e2.preventDefault();
        e2.stopPropagation();
        const elementId = this.extractElementId(element);
        if (elementId) {
          const navigateId = this.resolveNavigationId(elementId);
          this.vscodeApi.postMessage({
            type: "navigateToElement",
            elementId: navigateId
          });
          return;
        }
      }
      const root = document.getElementById(this.baseDiv);
      const resetView = root == null ? void 0 : root.__resetView;
      if (typeof resetView === "function") {
        resetView();
      }
    }
    findClickedElement(target) {
      const targetClasses = this.getClassNames(target);
      if (targetClasses.includes("sprotty-node")) return target;
      if (targetClasses.includes("sprotty-edge")) return target;
      return target.closest('[class*="sprotty-node"]') || target.closest('[class*="sprotty-edge"]');
    }
    getClassNames(element) {
      const className = element.className;
      if (className && typeof className === "object" && "baseVal" in className) {
        return className.baseVal;
      }
      return className || "";
    }
    extractElementId(element) {
      let elementId = element.getAttribute("id");
      if (!elementId && element.parentElement) {
        elementId = element.parentElement.getAttribute("id");
      }
      if (elementId == null ? void 0 : elementId.startsWith("sprotty_")) {
        elementId = elementId.substring("sprotty_".length);
      }
      return elementId;
    }
    resolveNavigationId(searchId) {
      var _a4, _b2;
      const model = this.modelGetter();
      if (!model) return searchId;
      if (searchId.endsWith("-edge1") || searchId.endsWith("-edge2")) {
        const qualifiedName = searchId.replace(/-edge[12]$/, "");
        const node = findElementById(model, qualifiedName);
        if (((_a4 = node == null ? void 0 : node.type) == null ? void 0 : _a4.startsWith("node")) && node.kind === "relation-entity") {
          return qualifiedName;
        }
      }
      const descRelMatch = searchId.match(/^(.+?)-(?:source|target)-edge\d+$/);
      if (descRelMatch) {
        const qualifiedName = descRelMatch[1];
        const node = findElementById(model, qualifiedName);
        if (((_b2 = node == null ? void 0 : node.type) == null ? void 0 : _b2.startsWith("node")) && node.kind === "relation-instance") {
          return qualifiedName;
        }
      }
      const eqEdgeMatch = searchId.match(/^\[(.+?)\]<->\[\d+\]-edge\d+$/);
      if (eqEdgeMatch) return eqEdgeMatch[1];
      const eqNodeMatch = searchId.match(/^\[(.+?)\]<->\[\d+\]$/);
      if (eqNodeMatch) return eqNodeMatch[1];
      const specMatch = searchId.match(/^\[(.+?)\]->\[.+?\]$/);
      if (specMatch) return specMatch[1];
      const directEqMatch = searchId.match(/^\[(.+?)\]<->\[.+?\]$/);
      if (directEqMatch) return directEqMatch[1];
      return searchId;
    }
  };
  var MessageHandler = class {
    constructor(actionDispatcher, modelSource, onModelUpdate) {
      this.actionDispatcher = actionDispatcher;
      this.modelSource = modelSource;
      this.onModelUpdate = onModelUpdate;
    }
    handleMessage(message) {
      if ((message == null ? void 0 : message.type) === "theme") {
        this.handleTheme(message);
      } else if ((message == null ? void 0 : message.type) === "updateModel") {
        this.handleModelUpdate(message);
      }
    }
    handleTheme(message) {
      try {
        const kind = message.kind === "light" ? "light" : "dark";
        document.documentElement.setAttribute("data-vscode-theme-kind", kind);
      } catch (e2) {
      }
    }
    handleModelUpdate(message) {
      try {
        const root = message.model;
        this.onModelUpdate(root);
        try {
          this.actionDispatcher.dispatch({
            kind: "updateModel",
            newRoot: root,
            animate: true
          });
        } catch (_3) {
          if (typeof this.modelSource.updateModel === "function") {
            this.modelSource.updateModel(root);
          } else {
            this.modelSource.setModel(root);
          }
        }
      } catch (err) {
        console.error("[OML Diagram] Error processing model:", err);
      }
    }
  };
  var DiagramApplication = class {
    constructor() {
      this.container = createOmlContainer(BASE_DIV_ID);
      this.viewer = this.container.get(import_sprotty2.ModelViewer);
      this.modelSource = this.container.get(import_sprotty2.TYPES.ModelSource);
      this.actionDispatcher = this.container.get(import_sprotty2.TYPES.IActionDispatcher);
      this.blockSetBoundsActions();
      this.initializeVSCodeAPI();
      this.markerManager = new MarkerManager(BASE_DIV_ID);
      this.messageHandler = new MessageHandler(
        this.actionDispatcher,
        this.modelSource,
        this.onModelUpdate.bind(this)
      );
    }
    start() {
      this.setupMessageListener();
      this.initializePanZoom();
      this.initializeNavigation();
      this.requestInitialModel();
    }
    blockSetBoundsActions() {
      const originalDispatch = this.actionDispatcher.dispatch.bind(this.actionDispatcher);
      this.actionDispatcher.dispatch = (action) => {
        if ((action == null ? void 0 : action.kind) === "setBounds") return;
        return originalDispatch(action);
      };
    }
    initializeVSCodeAPI() {
      this.vscodeApi = acquireVsCodeApi();
    }
    setupMessageListener() {
      window.addEventListener("message", (event) => {
        this.messageHandler.handleMessage(event.data);
      });
    }
    initializePanZoom() {
      const root = document.getElementById(BASE_DIV_ID);
      if (root) {
        new PanZoomController(root, root);
      }
    }
    initializeNavigation() {
      new NavigationHandler(
        BASE_DIV_ID,
        this.vscodeApi,
        () => currentDiagramModel
      );
    }
    onModelUpdate(model) {
      currentDiagramModel = model;
      setTimeout(() => this.markerManager.initialize(), 100);
    }
    requestInitialModel() {
      this.vscodeApi.postMessage({ type: "requestModel" });
    }
  };
  var app = new DiagramApplication();
  app.start();
})();
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=diagram-client.js.map
